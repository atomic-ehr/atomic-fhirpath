{
  "stats": {
    "totalSearchParameters": 1234,
    "withExpressions": 1226,
    "withoutExpressions": 8,
    "uniqueExpressions": 1204
  },
  "expressions": [
    {
      "name": "_in",
      "expression": "Resource.id",
      "base": [
        "Resource"
      ],
      "type": "reference",
      "description": "Allows for the retrieval of resources that are active members of a CareTeam, Group, or List"
    },
    {
      "name": "_language",
      "expression": "Resource.language",
      "base": [
        "Resource"
      ],
      "type": "token",
      "description": "Language of the resource content"
    },
    {
      "name": "_lastUpdated",
      "expression": "Resource.meta.lastUpdated",
      "base": [
        "Resource"
      ],
      "type": "date",
      "description": "When the resource version last changed"
    },
    {
      "name": "_profile",
      "expression": "Resource.meta.profile",
      "base": [
        "Resource"
      ],
      "type": "reference",
      "description": "Profiles this resource claims to conform to"
    },
    {
      "name": "_security",
      "expression": "Resource.meta.security",
      "base": [
        "Resource"
      ],
      "type": "token",
      "description": "Security Labels applied to this resource"
    },
    {
      "name": "_source",
      "expression": "Resource.meta.source",
      "base": [
        "Resource"
      ],
      "type": "uri",
      "description": "Identifies where the resource comes from"
    },
    {
      "name": "_tag",
      "expression": "Resource.meta.tag",
      "base": [
        "Resource"
      ],
      "type": "token",
      "description": "Tags applied to this resource"
    },
    {
      "name": "abatement-age",
      "expression": "Condition.abatement.ofType(Age) | Condition.abatement.ofType(Range)",
      "base": [
        "Condition"
      ],
      "type": "quantity",
      "description": "Abatement as age or age range"
    },
    {
      "name": "abatement-date",
      "expression": "Condition.abatement.ofType(dateTime) | Condition.abatement.ofType(Period)",
      "base": [
        "Condition"
      ],
      "type": "date",
      "description": "Date-related abatements (dateTime and period)"
    },
    {
      "name": "abatement-string",
      "expression": "Condition.abatement.ofType(string)",
      "base": [
        "Condition"
      ],
      "type": "string",
      "description": "Abatement as a string"
    },
    {
      "name": "about",
      "expression": "CommunicationRequest.about",
      "base": [
        "CommunicationRequest"
      ],
      "type": "reference",
      "description": "Resources that pertain to this communication request"
    },
    {
      "name": "abstract",
      "expression": "StructureDefinition.abstract",
      "base": [
        "StructureDefinition"
      ],
      "type": "token",
      "description": "Whether the structure is abstract"
    },
    {
      "name": "accession",
      "expression": "Specimen.accessionIdentifier",
      "base": [
        "Specimen"
      ],
      "type": "token",
      "description": "The accession number associated with the specimen"
    },
    {
      "name": "account",
      "expression": "ChargeItem.account",
      "base": [
        "ChargeItem"
      ],
      "type": "reference",
      "description": "Account to place this charge"
    },
    {
      "name": "account",
      "expression": "ChargeItemDefinition.account",
      "base": [
        "ChargeItemDefinition"
      ],
      "type": "reference",
      "description": "Candidate account for charge items"
    },
    {
      "name": "account",
      "expression": "Encounter.account",
      "base": [
        "Encounter"
      ],
      "type": "reference",
      "description": "The set of accounts that may be used for billing for this Encounter"
    },
    {
      "name": "account",
      "expression": "Invoice.account",
      "base": [
        "Invoice"
      ],
      "type": "reference",
      "description": "Account that is being balanced"
    },
    {
      "name": "achievement-status",
      "expression": "Goal.achievementStatus",
      "base": [
        "Goal"
      ],
      "type": "token",
      "description": "in-progress | improving | worsening | no-change | achieved | sustaining | not-achieved | no-progress | not-attainable"
    },
    {
      "name": "action",
      "expression": "AuditEvent.action",
      "base": [
        "AuditEvent"
      ],
      "type": "token",
      "description": "Type of action performed during the event"
    },
    {
      "name": "action",
      "expression": "Consent.provision.code",
      "base": [
        "Consent"
      ],
      "type": "token",
      "description": "LOINC or SNOMED CT code, etc. in the content"
    },
    {
      "name": "action-resource",
      "expression": "RequestOrchestration.action.resource",
      "base": [
        "RequestOrchestration"
      ],
      "type": "reference",
      "description": "A resource in an action of the request orchestration"
    },
    {
      "name": "active",
      "expression": "HealthcareService.active",
      "base": [
        "HealthcareService"
      ],
      "type": "token",
      "description": "The Healthcare Service is currently marked as active"
    },
    {
      "name": "active",
      "expression": "Organization.active",
      "base": [
        "Organization"
      ],
      "type": "token",
      "description": "Is the Organization record active"
    },
    {
      "name": "active",
      "expression": "OrganizationAffiliation.active",
      "base": [
        "OrganizationAffiliation"
      ],
      "type": "token",
      "description": "Whether this organization affiliation record is in active use"
    },
    {
      "name": "active",
      "expression": "Patient.active",
      "base": [
        "Patient"
      ],
      "type": "token",
      "description": "Whether the patient record is active"
    },
    {
      "name": "active",
      "expression": "Practitioner.active",
      "base": [
        "Practitioner"
      ],
      "type": "token",
      "description": "Whether the practitioner record is active"
    },
    {
      "name": "active",
      "expression": "PractitionerRole.active",
      "base": [
        "PractitionerRole"
      ],
      "type": "token",
      "description": "Whether this practitioner role record is in active use"
    },
    {
      "name": "active",
      "expression": "RelatedPerson.active",
      "base": [
        "RelatedPerson"
      ],
      "type": "token",
      "description": "Indicates if the related person record is active"
    },
    {
      "name": "active",
      "expression": "Schedule.active",
      "base": [
        "Schedule"
      ],
      "type": "token",
      "description": "Is the schedule in active use"
    },
    {
      "name": "activity",
      "expression": "Provenance.activity",
      "base": [
        "Provenance"
      ],
      "type": "token",
      "description": "Activity that occurred"
    },
    {
      "name": "activity-reference",
      "expression": "CarePlan.activity.plannedActivityReference",
      "base": [
        "CarePlan"
      ],
      "type": "reference",
      "description": "Activity that is intended to be part of the care plan"
    },
    {
      "name": "actor",
      "expression": "Appointment.participant.actor",
      "base": [
        "Appointment"
      ],
      "type": "reference",
      "description": "Any one of the individuals participating in the appointment"
    },
    {
      "name": "actor",
      "expression": "Consent.provision.actor.reference",
      "base": [
        "Consent"
      ],
      "type": "reference",
      "description": "Resource for the actor (or group, by role)"
    },
    {
      "name": "actor",
      "expression": "Requirements.actor.reference",
      "base": [
        "Requirements"
      ],
      "type": "reference",
      "description": "An actor these requirements are for"
    },
    {
      "name": "actor",
      "expression": "Schedule.actor",
      "base": [
        "Schedule"
      ],
      "type": "reference",
      "description": "The individual(HealthcareService, Practitioner, Location, ...) to find a Schedule for"
    },
    {
      "name": "actor",
      "expression": "Task.performer.actor",
      "base": [
        "Task"
      ],
      "type": "reference",
      "description": "Search by specific performer."
    },
    {
      "name": "actuality",
      "expression": "AdverseEvent.actuality",
      "base": [
        "AdverseEvent"
      ],
      "type": "token",
      "description": "actual | potential"
    },
    {
      "name": "additive",
      "expression": "NutritionOrder.additive.modularType.concept",
      "base": [
        "NutritionOrder"
      ],
      "type": "token",
      "description": "Type of module component to add to the diet"
    },
    {
      "name": "address",
      "expression": "Organization.contact.address",
      "base": [
        "Organization"
      ],
      "type": "string",
      "description": "A server defined search that may match any of the string fields in the Address, including line, city, district, state, country, postalCode, and/or text"
    },
    {
      "name": "address",
      "expression": "Patient.address | Person.address | Practitioner.address | RelatedPerson.address",
      "base": [
        "Patient",
        "Person",
        "Practitioner",
        "RelatedPerson"
      ],
      "type": "string",
      "description": "Multiple Resources: \r\n\r\n* [Patient](patient.html): A server defined search that may match any of the string fields in the Address, including line, city, district, state, country, postalCode, and/or text\r\n* [Person](person.html): A server defined search that may match any of the string fields in the Address, including line, city, district, state, country, postalCode, and/or text\r\n* [Practitioner](practitioner.html): A server defined search that may match any of the string fields in the Address, including line, city, district, state, country, postalCode, and/or text\r\n* [RelatedPerson](relatedperson.html): A server defined search that may match any of the string fields in the Address, including line, city, district, state, country, postalCode, and/or text\r\n"
    },
    {
      "name": "address-city",
      "expression": "Location.address.city",
      "base": [
        "Location"
      ],
      "type": "string",
      "description": "A city specified in an address"
    },
    {
      "name": "address-city",
      "expression": "Patient.address.city | Person.address.city | Practitioner.address.city | RelatedPerson.address.city",
      "base": [
        "Patient",
        "Person",
        "Practitioner",
        "RelatedPerson"
      ],
      "type": "string",
      "description": "Multiple Resources: \r\n\r\n* [Patient](patient.html): A city specified in an address\r\n* [Person](person.html): A city specified in an address\r\n* [Practitioner](practitioner.html): A city specified in an address\r\n* [RelatedPerson](relatedperson.html): A city specified in an address\r\n"
    },
    {
      "name": "address-country",
      "expression": "Location.address.country",
      "base": [
        "Location"
      ],
      "type": "string",
      "description": "A country specified in an address"
    },
    {
      "name": "address-country",
      "expression": "Organization.contact.address.country",
      "base": [
        "Organization"
      ],
      "type": "string",
      "description": "A country specified in an address"
    },
    {
      "name": "address-country",
      "expression": "Patient.address.country | Person.address.country | Practitioner.address.country | RelatedPerson.address.country",
      "base": [
        "Patient",
        "Person",
        "Practitioner",
        "RelatedPerson"
      ],
      "type": "string",
      "description": "Multiple Resources: \r\n\r\n* [Patient](patient.html): A country specified in an address\r\n* [Person](person.html): A country specified in an address\r\n* [Practitioner](practitioner.html): A country specified in an address\r\n* [RelatedPerson](relatedperson.html): A country specified in an address\r\n"
    },
    {
      "name": "address-postalcode",
      "expression": "Location.address.postalCode",
      "base": [
        "Location"
      ],
      "type": "string",
      "description": "A postal code specified in an address"
    },
    {
      "name": "address-postalcode",
      "expression": "Organization.contact.address.postalCode",
      "base": [
        "Organization"
      ],
      "type": "string",
      "description": "A postal code specified in an address"
    },
    {
      "name": "address-state",
      "expression": "Location.address.state",
      "base": [
        "Location"
      ],
      "type": "string",
      "description": "A state specified in an address"
    },
    {
      "name": "address-state",
      "expression": "Organization.contact.address.state",
      "base": [
        "Organization"
      ],
      "type": "string",
      "description": "A state specified in an address"
    },
    {
      "name": "address-state",
      "expression": "Patient.address.state | Person.address.state | Practitioner.address.state | RelatedPerson.address.state",
      "base": [
        "Patient",
        "Person",
        "Practitioner",
        "RelatedPerson"
      ],
      "type": "string",
      "description": "Multiple Resources: \r\n\r\n* [Patient](patient.html): A state specified in an address\r\n* [Person](person.html): A state specified in an address\r\n* [Practitioner](practitioner.html): A state specified in an address\r\n* [RelatedPerson](relatedperson.html): A state specified in an address\r\n"
    },
    {
      "name": "address-use",
      "expression": "Location.address.use",
      "base": [
        "Location"
      ],
      "type": "token",
      "description": "A use code specified in an address"
    },
    {
      "name": "address-use",
      "expression": "Organization.contact.address.use",
      "base": [
        "Organization"
      ],
      "type": "token",
      "description": "A use code specified in an address"
    },
    {
      "name": "address-use",
      "expression": "Patient.address.use | Person.address.use | Practitioner.address.use | RelatedPerson.address.use",
      "base": [
        "Patient",
        "Person",
        "Practitioner",
        "RelatedPerson"
      ],
      "type": "token",
      "description": "Multiple Resources: \r\n\r\n* [Patient](patient.html): A use code specified in an address\r\n* [Person](person.html): A use code specified in an address\r\n* [Practitioner](practitioner.html): A use code specified in an address\r\n* [RelatedPerson](relatedperson.html): A use code specified in an address\r\n"
    },
    {
      "name": "addresses",
      "expression": "Goal.addresses",
      "base": [
        "Goal"
      ],
      "type": "reference",
      "description": "Issues addressed by this goal"
    },
    {
      "name": "adherence",
      "expression": "MedicationStatement.adherence.code",
      "base": [
        "MedicationStatement"
      ],
      "type": "token",
      "description": "Returns statements based on adherence or compliance"
    },
    {
      "name": "administered-by",
      "expression": "InsuranceProduct.administeredBy",
      "base": [
        "Resource"
      ],
      "type": "reference",
      "description": "Product administrator"
    },
    {
      "name": "agent",
      "expression": "AuditEvent.agent.who",
      "base": [
        "AuditEvent"
      ],
      "type": "reference",
      "description": "Identifier of who"
    },
    {
      "name": "agent",
      "expression": "Provenance.agent.who",
      "base": [
        "Provenance"
      ],
      "type": "reference",
      "description": "Who participated"
    },
    {
      "name": "agent-role",
      "expression": "AuditEvent.agent.role",
      "base": [
        "AuditEvent"
      ],
      "type": "token",
      "description": "Agent role in the event"
    },
    {
      "name": "agent-type",
      "expression": "Provenance.agent.type",
      "base": [
        "Provenance"
      ],
      "type": "token",
      "description": "How the agent participated"
    },
    {
      "name": "allocation-account",
      "expression": "PaymentReconciliation.allocation.account",
      "base": [
        "PaymentReconciliation"
      ],
      "type": "reference",
      "description": "The account to which payment or adjustment was applied."
    },
    {
      "name": "allocation-encounter",
      "expression": "PaymentReconciliation.allocation.encounter",
      "base": [
        "PaymentReconciliation"
      ],
      "type": "reference",
      "description": "The encounter to which payment or adjustment was applied."
    },
    {
      "name": "annunciator-device",
      "expression": "DeviceAlert.signal.annunciator.reference",
      "base": [
        "Resource"
      ],
      "type": "reference",
      "description": "The signalling device annunciating the condition"
    },
    {
      "name": "answer-concept",
      "expression": "QuestionnaireResponse.item.answer.value.ofType(boolean) | QuestionnaireResponse.item.answer.value.ofType(Coding)",
      "base": [
        "QuestionnaireResponse"
      ],
      "type": "token",
      "description": "Question answers of type coding or boolean found within the response.  (Primarily for use as part of other composite search parameters.)  Refer to [questionnaireresponse.html#searching](searching guidance) on the resource page for considerations on the use of this parameter."
    },
    {
      "name": "answer-date",
      "expression": "QuestionnaireResponse.item.answer.value.ofType(date) | QuestionnaireResponse.item.answer.value.ofType(dateTime)",
      "base": [
        "QuestionnaireResponse"
      ],
      "type": "date",
      "description": "Question answers of type date or dateTime found within the response.  (Primarily for use as part of other composite search parameters.)  Refer to [questionnaireresponse.html#searching](searching guidance) on the resource page for considerations on the use of this parameter."
    },
    {
      "name": "answer-number",
      "expression": "QuestionnaireResponse.item.answer.value.ofType(integer) | QuestionnaireResponse.item.answer.value.ofType(decimal)",
      "base": [
        "QuestionnaireResponse"
      ],
      "type": "number",
      "description": "Question answers of type integer or decimal found within the response.  (Primarily for use as part of other composite search parameters.)  Refer to [questionnaireresponse.html#searching](searching guidance) on the resource page for considerations on the use of this parameter."
    },
    {
      "name": "answer-quantity",
      "expression": "QuestionnaireResponse.item.answer.value.ofType(Quantity)",
      "base": [
        "QuestionnaireResponse"
      ],
      "type": "quantity",
      "description": "Question answers of type quantity found within the response.  (Primarily for use as part of other composite search parameters.)  Refer to [questionnaireresponse.html#searching](searching guidance) on the resource page for considerations on the use of this parameter."
    },
    {
      "name": "answer-reference",
      "expression": "QuestionnaireResponse.item.answer.value.ofType(Reference)",
      "base": [
        "QuestionnaireResponse"
      ],
      "type": "reference",
      "description": "Question answers of type reference found within the response.  (Primarily for use as part of other composite search parameters.)  Refer to [questionnaireresponse.html#searching](searching guidance) on the resource page for considerations on the use of this parameter."
    },
    {
      "name": "answer-string",
      "expression": "QuestionnaireResponse.item.answer.value.ofType(string)",
      "base": [
        "QuestionnaireResponse"
      ],
      "type": "string",
      "description": "Question answers of type string found within the response.  (Primarily for use as part of other composite search parameters.)  Refer to [questionnaireresponse.html#searching](searching guidance) on the resource page for considerations on the use of this parameter."
    },
    {
      "name": "appointment",
      "expression": "AppointmentResponse.appointment",
      "base": [
        "AppointmentResponse"
      ],
      "type": "reference",
      "description": "The appointment that the response is attached to"
    },
    {
      "name": "appointment",
      "expression": "Encounter.appointment",
      "base": [
        "Encounter"
      ],
      "type": "reference",
      "description": "The appointment that scheduled this encounter"
    },
    {
      "name": "appointment-type",
      "expression": "Appointment.appointmentType",
      "base": [
        "Appointment"
      ],
      "type": "token",
      "description": "The style of appointment or patient that has been booked in the slot (not service type)"
    },
    {
      "name": "appointment-type",
      "expression": "Slot.appointmentType",
      "base": [
        "Slot"
      ],
      "type": "token",
      "description": "The style of appointment or patient that may be booked in the slot (not service type)"
    },
    {
      "name": "asserter",
      "expression": "AllergyIntolerance.asserter",
      "base": [
        "AllergyIntolerance"
      ],
      "type": "reference",
      "description": "Source of the information about the allergy"
    },
    {
      "name": "asserter",
      "expression": "Condition.asserter",
      "base": [
        "Condition"
      ],
      "type": "reference",
      "description": "Person or device that asserts this condition"
    },
    {
      "name": "attestation-method",
      "expression": "VerificationResult.attestation.communicationMethod",
      "base": [
        "VerificationResult"
      ],
      "type": "token",
      "description": "Select validation information for data that was attested to using the specified method"
    },
    {
      "name": "attestation-onbehalfof",
      "expression": "VerificationResult.attestation.onBehalfOf",
      "base": [
        "VerificationResult"
      ],
      "type": "reference",
      "description": "Select validation information for data that was attested to on behalf of the specified source"
    },
    {
      "name": "attestation-who",
      "expression": "VerificationResult.attestation.who",
      "base": [
        "VerificationResult"
      ],
      "type": "reference",
      "description": "Select validation information for data that was attested to by the specified source"
    },
    {
      "name": "attester",
      "expression": "Composition.attester.party",
      "base": [
        "Composition"
      ],
      "type": "reference",
      "description": "Who attested the composition"
    },
    {
      "name": "attester",
      "expression": "DocumentReference.attester.party",
      "base": [
        "DocumentReference"
      ],
      "type": "reference",
      "description": "Who attested the document"
    },
    {
      "name": "author",
      "expression": "Composition.author",
      "base": [
        "Composition"
      ],
      "type": "reference",
      "description": "Who and/or what authored the composition"
    },
    {
      "name": "author",
      "expression": "DocumentReference.author",
      "base": [
        "DocumentReference"
      ],
      "type": "reference",
      "description": "Who and/or what authored the document"
    },
    {
      "name": "author",
      "expression": "Flag.author",
      "base": [
        "Flag"
      ],
      "type": "reference",
      "description": "Flag creator"
    },
    {
      "name": "author",
      "expression": "Linkage.author",
      "base": [
        "Linkage"
      ],
      "type": "reference",
      "description": "Author of the Linkage"
    },
    {
      "name": "author",
      "expression": "RequestOrchestration.author",
      "base": [
        "RequestOrchestration"
      ],
      "type": "reference",
      "description": "The author of the request orchestration"
    },
    {
      "name": "authored",
      "expression": "QuestionnaireResponse.authored",
      "base": [
        "QuestionnaireResponse"
      ],
      "type": "date",
      "description": "When the questionnaire response was last changed"
    },
    {
      "name": "authored",
      "expression": "RequestOrchestration.authoredOn",
      "base": [
        "RequestOrchestration"
      ],
      "type": "date",
      "description": "The date the request orchestration was authored"
    },
    {
      "name": "authored",
      "expression": "ServiceRequest.authoredOn",
      "base": [
        "ServiceRequest"
      ],
      "type": "date",
      "description": "Date request signed"
    },
    {
      "name": "authored-on",
      "expression": "DeviceRequest.authoredOn",
      "base": [
        "DeviceRequest"
      ],
      "type": "date",
      "description": "When the request transitioned to being actionable"
    },
    {
      "name": "authored-on",
      "expression": "Task.authoredOn",
      "base": [
        "Task"
      ],
      "type": "date",
      "description": "Search by creation date"
    },
    {
      "name": "authoredon",
      "expression": "MedicationRequest.authoredOn",
      "base": [
        "MedicationRequest"
      ],
      "type": "date",
      "description": "Return prescriptions written on this date"
    },
    {
      "name": "authority",
      "expression": "Contract.authority",
      "base": [
        "Contract"
      ],
      "type": "reference",
      "description": "The authority of the contract"
    },
    {
      "name": "base",
      "expression": "OperationDefinition.base",
      "base": [
        "OperationDefinition"
      ],
      "type": "reference",
      "description": "Marks this as a profile of the base"
    },
    {
      "name": "base",
      "expression": "SearchParameter.base",
      "base": [
        "SearchParameter"
      ],
      "type": "token",
      "description": "The resource type(s) this search parameter applies to"
    },
    {
      "name": "base",
      "expression": "StructureDefinition.baseDefinition",
      "base": [
        "StructureDefinition"
      ],
      "type": "reference",
      "description": "Definition that this type is constrained/specialized from"
    },
    {
      "name": "based-on",
      "expression": "Appointment.basedOn",
      "base": [
        "Appointment"
      ],
      "type": "reference",
      "description": "The service request this appointment is allocated to assess"
    },
    {
      "name": "based-on",
      "expression": "AuditEvent.basedOn",
      "base": [
        "AuditEvent"
      ],
      "type": "reference",
      "description": "Reference to the service request."
    },
    {
      "name": "based-on",
      "expression": "CarePlan.basedOn",
      "base": [
        "CarePlan"
      ],
      "type": "reference",
      "description": "Fulfills CarePlan"
    },
    {
      "name": "based-on",
      "expression": "Communication.basedOn",
      "base": [
        "Communication"
      ],
      "type": "reference",
      "description": "Request fulfilled by this communication"
    },
    {
      "name": "based-on",
      "expression": "CommunicationRequest.basedOn",
      "base": [
        "CommunicationRequest"
      ],
      "type": "reference",
      "description": "Fulfills plan or proposal"
    },
    {
      "name": "based-on",
      "expression": "DiagnosticReport.basedOn",
      "base": [
        "DiagnosticReport"
      ],
      "type": "reference",
      "description": "Reference to the service request."
    },
    {
      "name": "based-on",
      "expression": "DocumentReference.basedOn",
      "base": [
        "DocumentReference"
      ],
      "type": "reference",
      "description": "Procedure that caused this media to be created"
    },
    {
      "name": "based-on",
      "expression": "ImagingSelection.basedOn",
      "base": [
        "ImagingSelection"
      ],
      "type": "reference",
      "description": "The request associated with an imaging selection"
    },
    {
      "name": "based-on",
      "expression": "ImagingStudy.basedOn",
      "base": [
        "ImagingStudy"
      ],
      "type": "reference",
      "description": "The order for the image such as Accession Number"
    },
    {
      "name": "based-on",
      "expression": "Observation.basedOn",
      "base": [
        "Observation"
      ],
      "type": "reference",
      "description": "Reference to the service request."
    },
    {
      "name": "based-on",
      "expression": "Procedure.basedOn",
      "base": [
        "Procedure"
      ],
      "type": "reference",
      "description": "A request for this procedure"
    },
    {
      "name": "based-on",
      "expression": "Provenance.basedOn",
      "base": [
        "Provenance"
      ],
      "type": "reference",
      "description": "Reference to the service request."
    },
    {
      "name": "based-on",
      "expression": "QuestionnaireResponse.basedOn",
      "base": [
        "QuestionnaireResponse"
      ],
      "type": "reference",
      "description": "Plan/proposal/order fulfilled by this questionnaire response"
    },
    {
      "name": "based-on",
      "expression": "ServiceRequest.basedOn",
      "base": [
        "ServiceRequest"
      ],
      "type": "reference",
      "description": "What request fulfills"
    },
    {
      "name": "based-on",
      "expression": "Task.basedOn",
      "base": [
        "Task"
      ],
      "type": "reference",
      "description": "Search by requests this task is based on"
    },
    {
      "name": "beneficiary",
      "expression": "Coverage.beneficiary",
      "base": [
        "Coverage"
      ],
      "type": "reference",
      "description": "Covered party"
    },
    {
      "name": "biological",
      "expression": "PackagedProductDefinition.packaging.containedItem.item.reference",
      "base": [
        "PackagedProductDefinition"
      ],
      "type": "reference",
      "description": "A biologically derived product within this packaged product"
    },
    {
      "name": "biological-source-event",
      "expression": "BiologicallyDerivedProduct.biologicalSourceEvent",
      "base": [
        "BiologicallyDerivedProduct"
      ],
      "type": "token",
      "description": "The biological source for the biologically derived product"
    },
    {
      "name": "biological-source-event",
      "expression": "Device.biologicalSourceEvent",
      "base": [
        "Device"
      ],
      "type": "token",
      "description": "The biological source for the device"
    },
    {
      "name": "birthdate",
      "expression": "Patient.birthDate | Person.birthDate | RelatedPerson.birthDate",
      "base": [
        "Patient",
        "Person",
        "RelatedPerson"
      ],
      "type": "date",
      "description": "Multiple Resources: \r\n\r\n* [Patient](patient.html): The patient's date of birth\r\n* [Person](person.html): The person's date of birth\r\n* [RelatedPerson](relatedperson.html): The Related Person's date of birth\r\n"
    },
    {
      "name": "body-site",
      "expression": "Condition.bodySite",
      "base": [
        "Condition"
      ],
      "type": "token",
      "description": "Anatomical location, if relevant"
    },
    {
      "name": "body-site",
      "expression": "ImagingSelection.bodySite.concept",
      "base": [
        "ImagingSelection"
      ],
      "type": "token",
      "description": "The body site code associated with the imaging selection"
    },
    {
      "name": "body-site",
      "expression": "ImagingStudy.series.bodySite.concept",
      "base": [
        "ImagingStudy"
      ],
      "type": "token",
      "description": "The body site code studied"
    },
    {
      "name": "body-site",
      "expression": "ServiceRequest.bodySite",
      "base": [
        "ServiceRequest"
      ],
      "type": "token",
      "description": "Where procedure is going to be done"
    },
    {
      "name": "body-structure",
      "expression": "ImagingStudy.series.bodySite.reference",
      "base": [
        "ImagingStudy"
      ],
      "type": "reference",
      "description": "The body structure resource associated with the ImagingStudy"
    },
    {
      "name": "body-structure",
      "expression": "ServiceRequest.bodyStructure",
      "base": [
        "ServiceRequest"
      ],
      "type": "reference",
      "description": "Body structure Where procedure is going to be done"
    },
    {
      "name": "bodysite",
      "expression": "DocumentReference.bodySite.concept",
      "base": [
        "DocumentReference"
      ],
      "type": "token",
      "description": "The body site studied"
    },
    {
      "name": "bodysite",
      "expression": "Specimen.collection.bodySite.reference",
      "base": [
        "Specimen"
      ],
      "type": "reference",
      "description": "Reference to a resource (by instance)"
    },
    {
      "name": "bodysite-reference",
      "expression": "DocumentReference.bodySite.reference",
      "base": [
        "DocumentReference"
      ],
      "type": "reference",
      "description": "The body site studied"
    },
    {
      "name": "business-status",
      "expression": "Task.businessStatus",
      "base": [
        "Task"
      ],
      "type": "token",
      "description": "Search by business status"
    },
    {
      "name": "care-manager",
      "expression": "EpisodeOfCare.careManager.where(resolve() is Practitioner)",
      "base": [
        "EpisodeOfCare"
      ],
      "type": "reference",
      "description": "Care manager/care coordinator for the episodeOfCare"
    },
    {
      "name": "care-team",
      "expression": "CarePlan.careTeam",
      "base": [
        "CarePlan"
      ],
      "type": "reference",
      "description": "Who's involved in plan?"
    },
    {
      "name": "care-team",
      "expression": "Claim.careTeam.provider",
      "base": [
        "Claim"
      ],
      "type": "reference",
      "description": "Member of the CareTeam"
    },
    {
      "name": "care-team",
      "expression": "ExplanationOfBenefit.careTeam.provider",
      "base": [
        "ExplanationOfBenefit"
      ],
      "type": "reference",
      "description": "Member of the CareTeam"
    },
    {
      "name": "careteam",
      "expression": "Encounter.careTeam",
      "base": [
        "Encounter"
      ],
      "type": "reference",
      "description": "Careteam allocated to participate in the encounter"
    },
    {
      "name": "case",
      "expression": "RegulatedAuthorization.case.identifier",
      "base": [
        "RegulatedAuthorization"
      ],
      "type": "token",
      "description": "The case or procedure number"
    },
    {
      "name": "case-type",
      "expression": "RegulatedAuthorization.case.type",
      "base": [
        "RegulatedAuthorization"
      ],
      "type": "token",
      "description": "The defining type of case"
    },
    {
      "name": "category",
      "expression": "AdverseEvent.category",
      "base": [
        "AdverseEvent"
      ],
      "type": "token",
      "description": "wrong-patient | procedure-mishap | medication-mishap | device | unsafe-physical-environment | hospital-aquired-infection | wrong-body-site"
    },
    {
      "name": "category",
      "expression": "AllergyIntolerance.category",
      "base": [
        "AllergyIntolerance"
      ],
      "type": "token",
      "description": "food | medication | environment | biologic"
    },
    {
      "name": "category",
      "expression": "CarePlan.category",
      "base": [
        "CarePlan"
      ],
      "type": "token",
      "description": "Type of plan"
    },
    {
      "name": "category",
      "expression": "CareTeam.category",
      "base": [
        "CareTeam"
      ],
      "type": "token",
      "description": "Type of team"
    },
    {
      "name": "category",
      "expression": "Communication.category",
      "base": [
        "Communication"
      ],
      "type": "token",
      "description": "Message category"
    },
    {
      "name": "category",
      "expression": "CommunicationRequest.category",
      "base": [
        "CommunicationRequest"
      ],
      "type": "token",
      "description": "Message category"
    },
    {
      "name": "category",
      "expression": "Composition.category",
      "base": [
        "Composition"
      ],
      "type": "token",
      "description": "Categorization of Composition"
    },
    {
      "name": "category",
      "expression": "Condition.category",
      "base": [
        "Condition"
      ],
      "type": "token",
      "description": "The category of the condition"
    },
    {
      "name": "category",
      "expression": "Consent.category",
      "base": [
        "Consent"
      ],
      "type": "token",
      "description": "Classification of the consent statement - for indexing/retrieval"
    },
    {
      "name": "category",
      "expression": "DetectedIssue.category",
      "base": [
        "DetectedIssue"
      ],
      "type": "token",
      "description": "Issue Category, e.g. drug-drug, duplicate therapy, etc."
    },
    {
      "name": "category",
      "expression": "DeviceMetric.category",
      "base": [
        "DeviceMetric"
      ],
      "type": "token",
      "description": "The category of the metric"
    },
    {
      "name": "category",
      "expression": "DiagnosticReport.category",
      "base": [
        "DiagnosticReport"
      ],
      "type": "token",
      "description": "Which diagnostic discipline/department created the report"
    },
    {
      "name": "category",
      "expression": "DocumentReference.category",
      "base": [
        "DocumentReference"
      ],
      "type": "token",
      "description": "Categorization of document"
    },
    {
      "name": "category",
      "expression": "Flag.category",
      "base": [
        "Flag"
      ],
      "type": "token",
      "description": "The category of the flag, such as clinical, administrative, etc."
    },
    {
      "name": "category",
      "expression": "Goal.category",
      "base": [
        "Goal"
      ],
      "type": "token",
      "description": "E.g. Treatment, dietary, behavioral, etc."
    },
    {
      "name": "category",
      "expression": "ImagingSelection.category",
      "base": [
        "ImagingSelection"
      ],
      "type": "token",
      "description": "The imaging selection category"
    },
    {
      "name": "category",
      "expression": "MedicationRequest.category",
      "base": [
        "MedicationRequest"
      ],
      "type": "token",
      "description": "Returns prescriptions with different categories"
    },
    {
      "name": "category",
      "expression": "MedicationStatement.category",
      "base": [
        "MedicationStatement"
      ],
      "type": "token",
      "description": "Returns statements of this category of MedicationStatement"
    },
    {
      "name": "category",
      "expression": "MessageDefinition.category",
      "base": [
        "MessageDefinition"
      ],
      "type": "token",
      "description": "The behavior associated with the message"
    },
    {
      "name": "category",
      "expression": "Observation.category",
      "base": [
        "Observation"
      ],
      "type": "token",
      "description": "The classification of the type of observation"
    },
    {
      "name": "category",
      "expression": "ObservationDefinition.category",
      "base": [
        "ObservationDefinition"
      ],
      "type": "token",
      "description": "Category (class) of observation"
    },
    {
      "name": "category",
      "expression": "Procedure.category",
      "base": [
        "Procedure"
      ],
      "type": "token",
      "description": "Classification of the procedure"
    },
    {
      "name": "category",
      "expression": "ServiceRequest.category",
      "base": [
        "ServiceRequest"
      ],
      "type": "token",
      "description": "Classification of service"
    },
    {
      "name": "category",
      "expression": "Substance.category",
      "base": [
        "Substance"
      ],
      "type": "token",
      "description": "The category of the substance"
    },
    {
      "name": "category",
      "expression": "SupplyRequest.category",
      "base": [
        "SupplyRequest"
      ],
      "type": "token",
      "description": "The kind of supply (central, non-stock, etc.)"
    },
    {
      "name": "category",
      "expression": "TestPlan.category",
      "base": [
        "TestPlan"
      ],
      "type": "token",
      "description": "The category for the test plan"
    },
    {
      "name": "cause",
      "expression": "AdverseEvent.cause.ofType(dateTime) | AdverseEvent.cause.ofType(Period)",
      "base": [
        "AdverseEvent"
      ],
      "type": "date",
      "description": "When the cause of the event occurred"
    },
    {
      "name": "characteristic",
      "expression": "Group.characteristic.code",
      "base": [
        "Group"
      ],
      "type": "token",
      "description": "Kind of characteristic"
    },
    {
      "name": "characteristic",
      "expression": "HealthcareService.characteristic",
      "base": [
        "HealthcareService"
      ],
      "type": "token",
      "description": "One of the HealthcareService's characteristics"
    },
    {
      "name": "characteristic",
      "expression": "Location.form",
      "base": [
        "Location"
      ],
      "type": "token",
      "description": "Physical form of the location (e.g. bed/ward/site/virtual)"
    },
    {
      "name": "characteristic",
      "expression": "MedicinalProductDefinition.characteristic.value.ofType(Quantity) | MedicinalProductDefinition.characteristic.value.ofType(CodeableConcept)",
      "base": [
        "MedicinalProductDefinition"
      ],
      "type": "token",
      "description": "Allows the key product features to be recorded, such as \"sugar free\", \"modified release\", \"parallel import\""
    },
    {
      "name": "characteristic",
      "expression": "PractitionerRole.characteristic",
      "base": [
        "PractitionerRole"
      ],
      "type": "token",
      "description": "One of the PractitionerRole's characteristics"
    },
    {
      "name": "characteristic-type",
      "expression": "MedicinalProductDefinition.characteristic.type",
      "base": [
        "MedicinalProductDefinition"
      ],
      "type": "token",
      "description": "A category for the characteristic"
    },
    {
      "name": "characteristic-value",
      "expression": "Group.characteristic",
      "base": [
        "Group"
      ],
      "type": "composite",
      "description": "A composite of both characteristic and value"
    },
    {
      "name": "claim",
      "expression": "ExplanationOfBenefit.claim",
      "base": [
        "ExplanationOfBenefit"
      ],
      "type": "reference",
      "description": "The reference to the claim"
    },
    {
      "name": "class",
      "expression": "Encounter.class",
      "base": [
        "Encounter"
      ],
      "type": "token",
      "description": "Classification of patient encounter"
    },
    {
      "name": "class-type",
      "expression": "Coverage.class.type",
      "base": [
        "Coverage"
      ],
      "type": "token",
      "description": "Coverage class (e.g. plan, group)"
    },
    {
      "name": "class-value",
      "expression": "Coverage.class.value",
      "base": [
        "Coverage"
      ],
      "type": "token",
      "description": "Value of the class (e.g. Plan number, group number)"
    },
    {
      "name": "classification",
      "expression": "Citation.classification",
      "base": [
        "Citation"
      ],
      "type": "composite",
      "description": "A classification type and value assigned to the citation"
    },
    {
      "name": "classification",
      "expression": "SubstanceDefinition.classification",
      "base": [
        "SubstanceDefinition"
      ],
      "type": "token",
      "description": "High or low level categorization, e.g. polymer vs. nucleic acid or linear vs. branch chain"
    },
    {
      "name": "classification-type",
      "expression": "(Citation.classification.type)",
      "base": [
        "Citation"
      ],
      "type": "token",
      "description": "A type of classification assigned to the citation"
    },
    {
      "name": "classification-type",
      "expression": "MedicationKnowledge.medicineClassification.type",
      "base": [
        "MedicationKnowledge"
      ],
      "type": "token",
      "description": "The type of category for the medication (for example, therapeutic classification, therapeutic sub-classification)"
    },
    {
      "name": "classifier",
      "expression": "(Citation.classification.classifier)",
      "base": [
        "Citation"
      ],
      "type": "token",
      "description": "A classifier assigned to the citation"
    },
    {
      "name": "classifier",
      "expression": "ResearchStudy.classifier",
      "base": [
        "ResearchStudy"
      ],
      "type": "token",
      "description": "Classification for the study"
    },
    {
      "name": "clinical-status",
      "expression": "AllergyIntolerance.clinicalStatus",
      "base": [
        "AllergyIntolerance"
      ],
      "type": "token",
      "description": "active | inactive | resolved"
    },
    {
      "name": "clinical-status",
      "expression": "Condition.clinicalStatus",
      "base": [
        "Condition"
      ],
      "type": "token",
      "description": "The clinical status of the condition"
    },
    {
      "name": "code",
      "expression": "AdverseEvent.code | AllergyIntolerance.code | AllergyIntolerance.reaction.substance | Basic.code | ChargeItem.code | Condition.code | DetectedIssue.code | DeviceRequest.code.concept | DiagnosticReport.code | FamilyMemberHistory.condition.code | ImagingSelection.code | List.code | Medication.code | MedicationAdministration.medication.concept | MedicationDispense.medication.concept | MedicationRequest.medication.concept | MedicationStatement.medication.concept | NutritionIntake.code | Observation.code | Procedure.code | RequestOrchestration.code | Task.code",
      "base": [
        "AdverseEvent",
        "AllergyIntolerance",
        "Basic",
        "ChargeItem",
        "Condition",
        "DetectedIssue",
        "DeviceRequest",
        "DiagnosticReport",
        "FamilyMemberHistory",
        "ImagingSelection",
        "List",
        "Medication",
        "MedicationAdministration",
        "MedicationDispense",
        "MedicationRequest",
        "MedicationStatement",
        "NutritionIntake",
        "Observation",
        "Procedure",
        "RequestOrchestration",
        "Task"
      ],
      "type": "token",
      "description": "Multiple Resources: \r\n\r\n* [AdverseEvent](adverseevent.html): Event or incident that occurred or was averted\r\n* [AllergyIntolerance](allergyintolerance.html): Code that identifies the allergy or intolerance\r\n* [Basic](basic.html): Kind of Resource\r\n* [ChargeItem](chargeitem.html): A code that identifies the charge, like a billing code\r\n* [Condition](condition.html): Code for the condition\r\n* [DetectedIssue](detectedissue.html): Issue Type, e.g. drug-drug, duplicate therapy, etc.\r\n* [DeviceRequest](devicerequest.html): Code for what is being requested/ordered\r\n* [DiagnosticReport](diagnosticreport.html): The code for the report, as opposed to codes for the atomic results, which are the names on the observation resource referred to from the result\r\n* [FamilyMemberHistory](familymemberhistory.html): A search by a condition code\r\n* [ImagingSelection](imagingselection.html): The imaging selection description text or code\r\n* [List](list.html): What the purpose of this list is\r\n* [Medication](medication.html): Returns medications for a specific code\r\n* [MedicationAdministration](medicationadministration.html): Return administrations of this medication code\r\n* [MedicationDispense](medicationdispense.html): Returns dispenses of this medicine code\r\n* [MedicationRequest](medicationrequest.html): Return prescriptions of this medication code\r\n* [MedicationStatement](medicationstatement.html): Return statements of this medication code\r\n* [NutritionIntake](nutritionintake.html): Returns statements of this code of NutritionIntake\r\n* [Observation](observation.html): The code of the observation type\r\n* [Procedure](procedure.html): A code to identify a  procedure\r\n* [RequestOrchestration](requestorchestration.html): The code of the request orchestration\r\n* [Task](task.html): Search by task code\r\n"
    },
    {
      "name": "code",
      "expression": "BiologicallyDerivedProduct.productCode",
      "base": [
        "BiologicallyDerivedProduct"
      ],
      "type": "token",
      "description": "A code that identifies the kind of this biologically derived product (SNOMED CT code)."
    },
    {
      "name": "code",
      "expression": "CodeSystem.concept.code",
      "base": [
        "CodeSystem"
      ],
      "type": "token",
      "description": "A code defined in the code system"
    },
    {
      "name": "code",
      "expression": "CompartmentDefinition.code",
      "base": [
        "CompartmentDefinition"
      ],
      "type": "token",
      "description": "Patient | Encounter | RelatedPerson | Practitioner | Device"
    },
    {
      "name": "code",
      "expression": "Device.type |  Device.definition.resolve().classification.type ",
      "base": [
        "Device"
      ],
      "type": "token",
      "description": "The definition / type of the device (code)"
    },
    {
      "name": "code",
      "expression": "DeviceAlert.condition.code",
      "base": [
        "Resource"
      ],
      "type": "token",
      "description": "Alert condition code"
    },
    {
      "name": "code",
      "expression": "DeviceDispense.device.concept",
      "base": [
        "DeviceDispense"
      ],
      "type": "token",
      "description": "Search for devices that match this code"
    },
    {
      "name": "code",
      "expression": "FormularyItem.code",
      "base": [
        "FormularyItem"
      ],
      "type": "token",
      "description": "Returns formulary items for a specific code"
    },
    {
      "name": "code",
      "expression": "Group.code",
      "base": [
        "Group"
      ],
      "type": "token",
      "description": "The kind of resources contained"
    },
    {
      "name": "code",
      "expression": "InventoryItem.code",
      "base": [
        "InventoryItem"
      ],
      "type": "token",
      "description": "Search for products that match this code"
    },
    {
      "name": "code",
      "expression": "MedicationKnowledge.code",
      "base": [
        "MedicationKnowledge"
      ],
      "type": "token",
      "description": "Code that identifies this medication"
    },
    {
      "name": "code",
      "expression": "MessageHeader.response.code",
      "base": [
        "MessageHeader"
      ],
      "type": "token",
      "description": "ok | transient-error | fatal-error"
    },
    {
      "name": "code",
      "expression": "NutritionProduct.code",
      "base": [
        "NutritionProduct"
      ],
      "type": "token",
      "description": "The code identifying a specific nutrition product"
    },
    {
      "name": "code",
      "expression": "ObservationDefinition.code",
      "base": [
        "ObservationDefinition"
      ],
      "type": "token",
      "description": "Observation code"
    },
    {
      "name": "code",
      "expression": "OperationDefinition.code",
      "base": [
        "OperationDefinition"
      ],
      "type": "token",
      "description": "Name used to invoke the operation"
    },
    {
      "name": "code",
      "expression": "SearchParameter.code",
      "base": [
        "SearchParameter"
      ],
      "type": "token",
      "description": "Code used in URL"
    },
    {
      "name": "code",
      "expression": "Substance.code.concept",
      "base": [
        "Substance"
      ],
      "type": "token",
      "description": "The code of the substance"
    },
    {
      "name": "code",
      "expression": "SubstanceDefinition.code.code",
      "base": [
        "SubstanceDefinition"
      ],
      "type": "token",
      "description": "The specific code"
    },
    {
      "name": "code",
      "expression": "ValueSet.expansion.contains.code | ValueSet.compose.include.concept.code",
      "base": [
        "ValueSet"
      ],
      "type": "token",
      "description": "This special parameter searches for codes in the value set. See additional notes on the ValueSet resource"
    },
    {
      "name": "code-concept",
      "expression": "ServiceRequest.code.concept",
      "base": [
        "ServiceRequest"
      ],
      "type": "token",
      "description": "What is being requested/ordered"
    },
    {
      "name": "code-reference",
      "expression": "ServiceRequest.code.reference",
      "base": [
        "ServiceRequest"
      ],
      "type": "reference",
      "description": "What is being requested/ordered"
    },
    {
      "name": "code-reference",
      "expression": "Substance.code.reference",
      "base": [
        "Substance"
      ],
      "type": "reference",
      "description": "A reference to the defining substance"
    },
    {
      "name": "code-value-concept",
      "expression": "Device",
      "base": [
        "Device"
      ],
      "type": "composite",
      "description": "Code and value parameter pair"
    },
    {
      "name": "code-value-concept",
      "expression": "Observation",
      "base": [
        "Observation"
      ],
      "type": "composite",
      "description": "Code and coded value parameter pair"
    },
    {
      "name": "code-value-date",
      "expression": "Observation",
      "base": [
        "Observation"
      ],
      "type": "composite",
      "description": "Code and date/time value parameter pair"
    },
    {
      "name": "code-value-quantity",
      "expression": "Observation",
      "base": [
        "Observation"
      ],
      "type": "composite",
      "description": "Code and quantity value parameter pair"
    },
    {
      "name": "code-value-string",
      "expression": "Observation",
      "base": [
        "Observation"
      ],
      "type": "composite",
      "description": "Code and string value parameter pair"
    },
    {
      "name": "collected",
      "expression": "Specimen.collection.collected.ofType(dateTime) | Specimen.collection.collected.ofType(Period)",
      "base": [
        "Specimen"
      ],
      "type": "date",
      "description": "The date the specimen was collected"
    },
    {
      "name": "collector",
      "expression": "BiologicallyDerivedProduct.collection.collector",
      "base": [
        "BiologicallyDerivedProduct"
      ],
      "type": "reference",
      "description": "Procedure request to obtain this biologically derived product."
    },
    {
      "name": "collector",
      "expression": "Specimen.collection.collector",
      "base": [
        "Specimen"
      ],
      "type": "reference",
      "description": "Who collected the specimen"
    },
    {
      "name": "combo-code",
      "expression": "Questionnaire.code | Questionnaire.item.code",
      "base": [
        "Questionnaire"
      ],
      "type": "token",
      "description": "A code that corresponds to one of its items in the questionnaire"
    },
    {
      "name": "combo-code-value-concept",
      "expression": "Observation | Observation.component",
      "base": [
        "Observation"
      ],
      "type": "composite",
      "description": "Code and coded value parameter pair, including in components"
    },
    {
      "name": "combo-code-value-quantity",
      "expression": "Observation | Observation.component",
      "base": [
        "Observation"
      ],
      "type": "composite",
      "description": "Code and quantity value parameter pair, including in components"
    },
    {
      "name": "combo-data-absent-reason",
      "expression": "Observation.dataAbsentReason | Observation.component.dataAbsentReason",
      "base": [
        "Observation"
      ],
      "type": "token",
      "description": "The reason why the expected value in the element Observation.value[x] or Observation.component.value[x] is missing."
    },
    {
      "name": "combo-date",
      "expression": "MedicationRequest.dosageInstruction.timing.event | (MedicationRequest.dosageInstruction.timing.repeat.bounds.ofType(Period))",
      "base": [
        "MedicationRequest"
      ],
      "type": "date",
      "description": "Returns medication request to be administered on a specific date or within a date range"
    },
    {
      "name": "combo-interpretation",
      "expression": "Observation.interpretation | Observation.component.interpretation",
      "base": [
        "Observation"
      ],
      "type": "token",
      "description": "The interpretation of the observation type or component type"
    },
    {
      "name": "combo-value-concept",
      "expression": "Observation.value.ofType(CodeableConcept) | Observation.component.value.ofType(CodeableConcept)",
      "base": [
        "Observation"
      ],
      "type": "token",
      "description": "The value or component value of the observation, if the value is a CodeableConcept"
    },
    {
      "name": "combo-value-quantity",
      "expression": "Observation.value.ofType(Quantity) | Observation.value.ofType(SampledData) | Observation.component.value.ofType(Quantity) | Observation.component.value.ofType(SampledData)",
      "base": [
        "Observation"
      ],
      "type": "quantity",
      "description": "The value or component value of the observation, if the value is a Quantity, or a SampledData (just search on the bounds of the values in sampled data)"
    },
    {
      "name": "communication",
      "expression": "Practitioner.communication.language",
      "base": [
        "Practitioner"
      ],
      "type": "token",
      "description": "A language to communicate with the practitioner"
    },
    {
      "name": "communication",
      "expression": "PractitionerRole.communication",
      "base": [
        "PractitionerRole"
      ],
      "type": "token",
      "description": "One of the languages that the practitioner can communicate with"
    },
    {
      "name": "component",
      "expression": "SearchParameter.component.definition",
      "base": [
        "SearchParameter"
      ],
      "type": "reference",
      "description": "Defines how the part works"
    },
    {
      "name": "component-code",
      "expression": "Observation.component.code",
      "base": [
        "Observation"
      ],
      "type": "token",
      "description": "The component code of the observation type"
    },
    {
      "name": "component-code-value-concept",
      "expression": "Observation.component",
      "base": [
        "Observation"
      ],
      "type": "composite",
      "description": "Component code and component coded value parameter pair"
    },
    {
      "name": "component-data-absent-reason",
      "expression": "Observation.component.dataAbsentReason",
      "base": [
        "Observation"
      ],
      "type": "token",
      "description": "The reason why the expected value in the element Observation.component.value[x] is missing."
    },
    {
      "name": "component-interpretation",
      "expression": "Observation.component.interpretation",
      "base": [
        "Observation"
      ],
      "type": "token",
      "description": "The component interpretation of the observation type"
    },
    {
      "name": "component-value-canonical",
      "expression": "Observation.component.value.ofType(canonical)",
      "base": [
        "Observation"
      ],
      "type": "reference",
      "description": "URL contained in valueCanonical."
    },
    {
      "name": "component-value-concept",
      "expression": "Observation.component.value.ofType(CodeableConcept)",
      "base": [
        "Observation"
      ],
      "type": "token",
      "description": "The value of the component observation, if the value is a CodeableConcept"
    },
    {
      "name": "component-value-quantity",
      "expression": "Observation.component.value.ofType(Quantity) | Observation.component.value.ofType(SampledData)",
      "base": [
        "Observation"
      ],
      "type": "quantity",
      "description": "The value of the component observation, if the value is a Quantity, or a SampledData (just search on the bounds of the values in sampled data)"
    },
    {
      "name": "component-value-reference",
      "expression": "Observation.component.value.ofType(Reference)",
      "base": [
        "Observation"
      ],
      "type": "reference",
      "description": "Reference contained in valueReference."
    },
    {
      "name": "composition",
      "expression": "Bundle.entry[0].resource as Composition",
      "base": [
        "Bundle"
      ],
      "type": "resource",
      "description": "The first resource in the bundle, if the bundle type is \"document\" - this is a composition, and this parameter provides access to search its contents"
    },
    {
      "name": "conclusioncode-code",
      "expression": "DiagnosticReport.conclusionCode.concept",
      "base": [
        "DiagnosticReport"
      ],
      "type": "token",
      "description": "A coded conclusion (interpretation/impression) on the report"
    },
    {
      "name": "conclusioncode-reference",
      "expression": "DiagnosticReport.conclusionCode.reference",
      "base": [
        "DiagnosticReport"
      ],
      "type": "reference",
      "description": "A reference for the conclusion (interpretation/impression) on the report"
    },
    {
      "name": "condition",
      "expression": "CarePlan.addresses.reference",
      "base": [
        "CarePlan"
      ],
      "type": "reference",
      "description": "Reference to a resource (by instance)"
    },
    {
      "name": "condition",
      "expression": "RiskAssessment.condition",
      "base": [
        "RiskAssessment"
      ],
      "type": "reference",
      "description": "Condition assessed"
    },
    {
      "name": "conformance",
      "expression": "TestScript.scope.conformance.ofType(CodeableConcept)",
      "base": [
        "TestScript"
      ],
      "type": "token",
      "description": "The artifact conformance testing expectation"
    },
    {
      "name": "connection-type",
      "expression": "Endpoint.connectionType",
      "base": [
        "Endpoint"
      ],
      "type": "token",
      "description": "Protocol/Profile/Standard to be used with this endpoint connection"
    },
    {
      "name": "contact",
      "expression": "Subscription.contact",
      "base": [
        "Subscription"
      ],
      "type": "token",
      "description": "Contact details for the subscription"
    },
    {
      "name": "contact-address",
      "expression": "InsuranceProduct.contact.address",
      "base": [
        "Resource"
      ],
      "type": "string",
      "description": "A server defined search that may match any of the string fields in the Address, including line, city, district, state, country, postalCode, and/or text"
    },
    {
      "name": "contact-address-city",
      "expression": "InsuranceProduct.contact.address.city",
      "base": [
        "Resource"
      ],
      "type": "string",
      "description": "A city specified in an address"
    },
    {
      "name": "contact-address-country",
      "expression": "InsuranceProduct.contact.address.country",
      "base": [
        "Resource"
      ],
      "type": "string",
      "description": "A country specified in an address"
    },
    {
      "name": "contact-address-postalcode",
      "expression": "InsuranceProduct.contact.address.postalCode",
      "base": [
        "Resource"
      ],
      "type": "string",
      "description": "A postal code specified in an address"
    },
    {
      "name": "contact-address-state",
      "expression": "InsuranceProduct.contact.address.state",
      "base": [
        "Resource"
      ],
      "type": "string",
      "description": "A state specified in an address"
    },
    {
      "name": "contact-address-use",
      "expression": "InsuranceProduct.contact.address.use",
      "base": [
        "Resource"
      ],
      "type": "token",
      "description": "A use code specified in an address"
    },
    {
      "name": "contained-item",
      "expression": "PackagedProductDefinition.packaging.containedItem.item.reference",
      "base": [
        "PackagedProductDefinition"
      ],
      "type": "reference",
      "description": "Any of the contained items within this packaged product"
    },
    {
      "name": "container",
      "expression": "SpecimenDefinition.typeTested.container.type",
      "base": [
        "SpecimenDefinition"
      ],
      "type": "token",
      "description": "The type of specimen conditioned in container expected by the lab"
    },
    {
      "name": "container-location",
      "expression": "Specimen.container.device.resolve().location",
      "base": [
        "Specimen"
      ],
      "type": "reference",
      "description": "The location of the specimen container"
    },
    {
      "name": "contains",
      "expression": "Location.extension('http://hl7.org/fhir/StructureDefinition/location-boundary-geojson').value",
      "base": [
        "Location"
      ],
      "type": "special",
      "description": "Select locations that contain the specified co-ordinates"
    },
    {
      "name": "content-level",
      "expression": "Subscription.content",
      "base": [
        "Subscription"
      ],
      "type": "token",
      "description": "Content level included in notifications"
    },
    {
      "name": "content-mode",
      "expression": "CodeSystem.content",
      "base": [
        "CodeSystem"
      ],
      "type": "token",
      "description": "not-present | example | fragment | complete | supplement"
    },
    {
      "name": "content-type",
      "expression": "Library.content.contentType",
      "base": [
        "Library"
      ],
      "type": "token",
      "description": "The type of content in the library (e.g. text/cql)"
    },
    {
      "name": "contenttype",
      "expression": "DocumentReference.content.attachment.contentType",
      "base": [
        "DocumentReference"
      ],
      "type": "token",
      "description": "Mime type of the content, with charset etc."
    },
    {
      "name": "context",
      "expression": "DocumentReference.context",
      "base": [
        "DocumentReference"
      ],
      "type": "reference",
      "description": "Context of the document content"
    },
    {
      "name": "context-quantity",
      "expression": "(ActivityDefinition.useContext.value.ofType(Quantity)) | (ActivityDefinition.useContext.value.ofType(Range)) | (ActorDefinition.useContext.value.ofType(Quantity)) | (ActorDefinition.useContext.value.ofType(Range)) | (CapabilityStatement.useContext.value.ofType(Quantity)) | (CapabilityStatement.useContext.value.ofType(Range)) | (ChargeItemDefinition.useContext.value.ofType(Quantity)) | (ChargeItemDefinition.useContext.value.ofType(Range)) | (Citation.useContext.value.ofType(Quantity)) | (Citation.useContext.value.ofType(Range)) | (CodeSystem.useContext.value.ofType(Quantity)) | (CodeSystem.useContext.value.ofType(Range)) | (CompartmentDefinition.useContext.value.ofType(Quantity)) | (CompartmentDefinition.useContext.value.ofType(Range)) | (ConceptMap.useContext.value.ofType(Quantity)) | (ConceptMap.useContext.value.ofType(Range)) | (ConditionDefinition.useContext.value.ofType(Quantity)) | (ConditionDefinition.useContext.value.ofType(Range)) | (EventDefinition.useContext.value.ofType(Quantity)) | (EventDefinition.useContext.value.ofType(Range)) | (Evidence.useContext.value.ofType(Quantity)) | (Evidence.useContext.value.ofType(Range)) | (EvidenceVariable.useContext.value.ofType(Quantity)) | (EvidenceVariable.useContext.value.ofType(Range)) | (ExampleScenario.useContext.value.ofType(Quantity)) | (ExampleScenario.useContext.value.ofType(Range)) | (GraphDefinition.useContext.value.ofType(Quantity)) | (GraphDefinition.useContext.value.ofType(Range)) | (ImplementationGuide.useContext.value.ofType(Quantity)) | (ImplementationGuide.useContext.value.ofType(Range)) | (Library.useContext.value.ofType(Quantity)) | (Library.useContext.value.ofType(Range)) | (Measure.useContext.value.ofType(Quantity)) | (Measure.useContext.value.ofType(Range)) | (MessageDefinition.useContext.value.ofType(Quantity)) | (MessageDefinition.useContext.value.ofType(Range)) | (NamingSystem.useContext.value.ofType(Quantity)) | (NamingSystem.useContext.value.ofType(Range)) | (OperationDefinition.useContext.value.ofType(Quantity)) | (OperationDefinition.useContext.value.ofType(Range)) | (PlanDefinition.useContext.value.ofType(Quantity)) | (PlanDefinition.useContext.value.ofType(Range)) | (Questionnaire.useContext.value.ofType(Quantity)) | (Questionnaire.useContext.value.ofType(Range)) | (Requirements.useContext.value.ofType(Quantity)) | (Requirements.useContext.value.ofType(Range)) | (SearchParameter.useContext.value.ofType(Quantity)) | (SearchParameter.useContext.value.ofType(Range)) | (StructureDefinition.useContext.value.ofType(Quantity)) | (StructureDefinition.useContext.value.ofType(Range)) | (StructureMap.useContext.value.ofType(Quantity)) | (StructureMap.useContext.value.ofType(Range)) | (TerminologyCapabilities.useContext.value.ofType(Quantity)) | (TerminologyCapabilities.useContext.value.ofType(Range)) | (TestPlan.useContext.value.ofType(Quantity)) | (TestPlan.useContext.value.ofType(Range)) | (TestScript.useContext.value.ofType(Quantity)) | (TestScript.useContext.value.ofType(Range)) | (ValueSet.useContext.value.ofType(Quantity)) | (ValueSet.useContext.value.ofType(Range))",
      "base": [
        "ActivityDefinition",
        "ActorDefinition",
        "CapabilityStatement",
        "ChargeItemDefinition",
        "Citation",
        "CodeSystem",
        "CompartmentDefinition",
        "ConceptMap",
        "ConditionDefinition",
        "EventDefinition",
        "Evidence",
        "EvidenceVariable",
        "ExampleScenario",
        "GraphDefinition",
        "ImplementationGuide",
        "Library",
        "Measure",
        "MessageDefinition",
        "NamingSystem",
        "OperationDefinition",
        "PlanDefinition",
        "Questionnaire",
        "Requirements",
        "SearchParameter",
        "StructureDefinition",
        "StructureMap",
        "TerminologyCapabilities",
        "TestPlan",
        "TestScript",
        "ValueSet"
      ],
      "type": "quantity",
      "description": "Multiple Resources: \r\n\r\n* [ActivityDefinition](activitydefinition.html): A quantity- or range-valued use context assigned to the activity definition\r\n* [ActorDefinition](actordefinition.html): A quantity- or range-valued use context assigned to the Actor Definition\r\n* [CapabilityStatement](capabilitystatement.html): A quantity- or range-valued use context assigned to the capability statement\r\n* [ChargeItemDefinition](chargeitemdefinition.html): A quantity- or range-valued use context assigned to the charge item definition\r\n* [Citation](citation.html): A quantity- or range-valued use context assigned to the citation\r\n* [CodeSystem](codesystem.html): A quantity- or range-valued use context assigned to the code system\r\n* [CompartmentDefinition](compartmentdefinition.html): A quantity- or range-valued use context assigned to the compartment definition\r\n* [ConceptMap](conceptmap.html): A quantity- or range-valued use context assigned to the concept map\r\n* [ConditionDefinition](conditiondefinition.html): A quantity- or range-valued use context assigned to the condition definition\r\n* [EventDefinition](eventdefinition.html): A quantity- or range-valued use context assigned to the event definition\r\n* [Evidence](evidence.html): A quantity- or range-valued use context assigned to the evidence\r\n* [EvidenceVariable](evidencevariable.html): A quantity- or range-valued use context assigned to the evidence variable\r\n* [ExampleScenario](examplescenario.html): A quantity- or range-valued use context assigned to the example scenario\r\n* [GraphDefinition](graphdefinition.html): A quantity- or range-valued use context assigned to the graph definition\r\n* [ImplementationGuide](implementationguide.html): A quantity- or range-valued use context assigned to the implementation guide\r\n* [Library](library.html): A quantity- or range-valued use context assigned to the library\r\n* [Measure](measure.html): A quantity- or range-valued use context assigned to the measure\r\n* [MessageDefinition](messagedefinition.html): A quantity- or range-valued use context assigned to the message definition\r\n* [NamingSystem](namingsystem.html): A quantity- or range-valued use context assigned to the naming system\r\n* [OperationDefinition](operationdefinition.html): A quantity- or range-valued use context assigned to the operation definition\r\n* [PlanDefinition](plandefinition.html): A quantity- or range-valued use context assigned to the plan definition\r\n* [Questionnaire](questionnaire.html): A quantity- or range-valued use context assigned to the questionnaire\r\n* [Requirements](requirements.html): A quantity- or range-valued use context assigned to the requirements\r\n* [SearchParameter](searchparameter.html): A quantity- or range-valued use context assigned to the search parameter\r\n* [StructureDefinition](structuredefinition.html): A quantity- or range-valued use context assigned to the structure definition\r\n* [StructureMap](structuremap.html): A quantity- or range-valued use context assigned to the structure map\r\n* [TerminologyCapabilities](terminologycapabilities.html): A quantity- or range-valued use context assigned to the terminology capabilities\r\n* [TestPlan](testplan.html): A quantity- or range-valued use context assigned to the test script\r\n* [TestScript](testscript.html): A quantity- or range-valued use context assigned to the test script\r\n* [ValueSet](valueset.html): A quantity- or range-valued use context assigned to the value set\r\n"
    },
    {
      "name": "context-type-quantity",
      "expression": "ActivityDefinition.useContext | ActorDefinition.useContext | CapabilityStatement.useContext | ChargeItemDefinition.useContext | Citation.useContext | CodeSystem.useContext | CompartmentDefinition.useContext | ConceptMap.useContext | ConditionDefinition.useContext | EventDefinition.useContext | Evidence.useContext | EvidenceVariable.useContext | ExampleScenario.useContext | GraphDefinition.useContext | ImplementationGuide.useContext | Library.useContext | Measure.useContext | MessageDefinition.useContext | NamingSystem.useContext | OperationDefinition.useContext | PlanDefinition.useContext | Questionnaire.useContext | Requirements.useContext | SearchParameter.useContext | StructureDefinition.useContext | StructureMap.useContext | TerminologyCapabilities.useContext | TestPlan.useContext | TestScript.useContext | ValueSet.useContext",
      "base": [
        "ActivityDefinition",
        "ActorDefinition",
        "CapabilityStatement",
        "ChargeItemDefinition",
        "Citation",
        "CodeSystem",
        "CompartmentDefinition",
        "ConceptMap",
        "ConditionDefinition",
        "EventDefinition",
        "Evidence",
        "EvidenceVariable",
        "ExampleScenario",
        "GraphDefinition",
        "ImplementationGuide",
        "Library",
        "Measure",
        "MessageDefinition",
        "NamingSystem",
        "OperationDefinition",
        "PlanDefinition",
        "Questionnaire",
        "Requirements",
        "SearchParameter",
        "StructureDefinition",
        "StructureMap",
        "TerminologyCapabilities",
        "TestPlan",
        "TestScript",
        "ValueSet"
      ],
      "type": "composite",
      "description": "Multiple Resources: \r\n\r\n* [ActivityDefinition](activitydefinition.html): A use context type and quantity- or range-based value assigned to the activity definition\r\n* [ActorDefinition](actordefinition.html): A use context type and quantity- or range-based value assigned to the Actor Definition\r\n* [CapabilityStatement](capabilitystatement.html): A use context type and quantity- or range-based value assigned to the capability statement\r\n* [ChargeItemDefinition](chargeitemdefinition.html): A use context type and quantity- or range-based value assigned to the charge item definition\r\n* [Citation](citation.html): A use context type and quantity- or range-based value assigned to the citation\r\n* [CodeSystem](codesystem.html): A use context type and quantity- or range-based value assigned to the code system\r\n* [CompartmentDefinition](compartmentdefinition.html): A use context type and quantity- or range-based value assigned to the compartment definition\r\n* [ConceptMap](conceptmap.html): A use context type and quantity- or range-based value assigned to the concept map\r\n* [ConditionDefinition](conditiondefinition.html): A use context type and quantity- or range-based value assigned to the condition definition\r\n* [EventDefinition](eventdefinition.html): A use context type and quantity- or range-based value assigned to the event definition\r\n* [Evidence](evidence.html): A use context type and quantity- or range-based value assigned to the evidence\r\n* [EvidenceVariable](evidencevariable.html): A use context type and quantity- or range-based value assigned to the evidence variable\r\n* [ExampleScenario](examplescenario.html): A use context type and quantity- or range-based value assigned to the example scenario\r\n* [GraphDefinition](graphdefinition.html): A use context type and quantity- or range-based value assigned to the graph definition\r\n* [ImplementationGuide](implementationguide.html): A use context type and quantity- or range-based value assigned to the implementation guide\r\n* [Library](library.html): A use context type and quantity- or range-based value assigned to the library\r\n* [Measure](measure.html): A use context type and quantity- or range-based value assigned to the measure\r\n* [MessageDefinition](messagedefinition.html): A use context type and quantity- or range-based value assigned to the message definition\r\n* [NamingSystem](namingsystem.html): A use context type and quantity- or range-based value assigned to the naming system\r\n* [OperationDefinition](operationdefinition.html): A use context type and quantity- or range-based value assigned to the operation definition\r\n* [PlanDefinition](plandefinition.html): A use context type and quantity- or range-based value assigned to the plan definition\r\n* [Questionnaire](questionnaire.html): A use context type and quantity- or range-based value assigned to the questionnaire\r\n* [Requirements](requirements.html): A use context type and quantity- or range-based value assigned to the requirements\r\n* [SearchParameter](searchparameter.html): A use context type and quantity- or range-based value assigned to the search parameter\r\n* [StructureDefinition](structuredefinition.html): A use context type and quantity- or range-based value assigned to the structure definition\r\n* [StructureMap](structuremap.html): A use context type and quantity- or range-based value assigned to the structure map\r\n* [TerminologyCapabilities](terminologycapabilities.html): A use context type and quantity- or range-based value assigned to the terminology capabilities\r\n* [TestPlan](testplan.html): A use context type and quantity- or range-based value assigned to the test script\r\n* [TestScript](testscript.html): A use context type and quantity- or range-based value assigned to the test script\r\n* [ValueSet](valueset.html): A use context type and quantity- or range-based value assigned to the value set\r\n"
    },
    {
      "name": "contraindication",
      "expression": "ClinicalUseDefinition.contraindication.diseaseSymptomProcedure.concept",
      "base": [
        "ClinicalUseDefinition"
      ],
      "type": "token",
      "description": "The situation that is being documented as contraindicating against this item, as a code"
    },
    {
      "name": "contraindication-reference",
      "expression": "ClinicalUseDefinition.contraindication.diseaseSymptomProcedure.reference",
      "base": [
        "ClinicalUseDefinition"
      ],
      "type": "reference",
      "description": "The situation that is being documented as contraindicating against this item, as a reference"
    },
    {
      "name": "controller",
      "expression": "Consent.controller",
      "base": [
        "Consent"
      ],
      "type": "reference",
      "description": "Consent Enforcer"
    },
    {
      "name": "coverage",
      "expression": "ExplanationOfBenefit.insurance.coverage",
      "base": [
        "ExplanationOfBenefit"
      ],
      "type": "reference",
      "description": "The plan under which the claim was adjudicated"
    },
    {
      "name": "coverage-area",
      "expression": "HealthcareService.coverageArea",
      "base": [
        "HealthcareService"
      ],
      "type": "reference",
      "description": "Location(s) service is intended for/available to"
    },
    {
      "name": "coverage-area",
      "expression": "InsurancePlan.coverageArea",
      "base": [
        "InsurancePlan"
      ],
      "type": "reference",
      "description": "Location(s) insurance product is intended for/available to"
    },
    {
      "name": "created",
      "expression": "Basic.created",
      "base": [
        "Basic"
      ],
      "type": "date",
      "description": "When created"
    },
    {
      "name": "created",
      "expression": "Claim.created",
      "base": [
        "Claim"
      ],
      "type": "date",
      "description": "The creation date for the Claim"
    },
    {
      "name": "created",
      "expression": "ClaimResponse.created",
      "base": [
        "ClaimResponse"
      ],
      "type": "date",
      "description": "The creation date"
    },
    {
      "name": "created",
      "expression": "CoverageEligibilityRequest.created",
      "base": [
        "CoverageEligibilityRequest"
      ],
      "type": "date",
      "description": "The creation date for the EOB"
    },
    {
      "name": "created",
      "expression": "CoverageEligibilityResponse.created",
      "base": [
        "CoverageEligibilityResponse"
      ],
      "type": "date",
      "description": "The creation date"
    },
    {
      "name": "created",
      "expression": "ExplanationOfBenefit.created",
      "base": [
        "ExplanationOfBenefit"
      ],
      "type": "date",
      "description": "The creation date for the EOB"
    },
    {
      "name": "created",
      "expression": "PaymentNotice.created",
      "base": [
        "PaymentNotice"
      ],
      "type": "date",
      "description": "Creation date for the notice"
    },
    {
      "name": "created",
      "expression": "PaymentReconciliation.created",
      "base": [
        "PaymentReconciliation"
      ],
      "type": "date",
      "description": "The creation date"
    },
    {
      "name": "creation",
      "expression": "DocumentReference.content.attachment.creation",
      "base": [
        "DocumentReference"
      ],
      "type": "date",
      "description": "Date attachment was first created"
    },
    {
      "name": "criticality",
      "expression": "AllergyIntolerance.criticality",
      "base": [
        "AllergyIntolerance"
      ],
      "type": "token",
      "description": "low | high | unable-to-assess"
    },
    {
      "name": "custodian",
      "expression": "CarePlan.custodian",
      "base": [
        "CarePlan"
      ],
      "type": "reference",
      "description": "Who is the designated responsible party"
    },
    {
      "name": "custodian",
      "expression": "DocumentReference.custodian",
      "base": [
        "DocumentReference"
      ],
      "type": "reference",
      "description": "Organization which maintains the document"
    },
    {
      "name": "data-absent-reason",
      "expression": "Observation.dataAbsentReason",
      "base": [
        "Observation"
      ],
      "type": "token",
      "description": "The reason why the expected value in the element Observation.value[x] is missing."
    },
    {
      "name": "date",
      "expression": "ActivityDefinition.date | ActorDefinition.date | CapabilityStatement.date | ChargeItemDefinition.date | Citation.date | CodeSystem.date | CompartmentDefinition.date | ConceptMap.date | ConditionDefinition.date | EventDefinition.date | Evidence.date | EvidenceVariable.date | ExampleScenario.date | GraphDefinition.date | ImplementationGuide.date | Library.date | Measure.date | MessageDefinition.date | NamingSystem.date | OperationDefinition.date | PlanDefinition.date | Questionnaire.date | Requirements.date | SearchParameter.date | StructureDefinition.date | StructureMap.date | SubscriptionTopic.date | TerminologyCapabilities.date | TestPlan.date | TestScript.date | ValueSet.date",
      "base": [
        "ActivityDefinition",
        "ActorDefinition",
        "CapabilityStatement",
        "ChargeItemDefinition",
        "Citation",
        "CodeSystem",
        "CompartmentDefinition",
        "ConceptMap",
        "ConditionDefinition",
        "EventDefinition",
        "Evidence",
        "EvidenceVariable",
        "ExampleScenario",
        "GraphDefinition",
        "ImplementationGuide",
        "Library",
        "Measure",
        "MessageDefinition",
        "NamingSystem",
        "OperationDefinition",
        "PlanDefinition",
        "Questionnaire",
        "Requirements",
        "SearchParameter",
        "StructureDefinition",
        "StructureMap",
        "SubscriptionTopic",
        "TerminologyCapabilities",
        "TestPlan",
        "TestScript",
        "ValueSet"
      ],
      "type": "date",
      "description": "Multiple Resources: \r\n\r\n* [ActivityDefinition](activitydefinition.html): The activity definition publication date\r\n* [ActorDefinition](actordefinition.html): The Actor Definition publication date\r\n* [CapabilityStatement](capabilitystatement.html): The capability statement publication date\r\n* [ChargeItemDefinition](chargeitemdefinition.html): The charge item definition publication date\r\n* [Citation](citation.html): The citation publication date\r\n* [CodeSystem](codesystem.html): The code system publication date\r\n* [CompartmentDefinition](compartmentdefinition.html): The compartment definition publication date\r\n* [ConceptMap](conceptmap.html): The concept map publication date\r\n* [ConditionDefinition](conditiondefinition.html): The condition definition publication date\r\n* [EventDefinition](eventdefinition.html): The event definition publication date\r\n* [Evidence](evidence.html): The evidence publication date\r\n* [EvidenceVariable](evidencevariable.html): The evidence variable publication date\r\n* [ExampleScenario](examplescenario.html): The example scenario publication date\r\n* [GraphDefinition](graphdefinition.html): The graph definition publication date\r\n* [ImplementationGuide](implementationguide.html): The implementation guide publication date\r\n* [Library](library.html): The library publication date\r\n* [Measure](measure.html): The measure publication date\r\n* [MessageDefinition](messagedefinition.html): The message definition publication date\r\n* [NamingSystem](namingsystem.html): The naming system publication date\r\n* [OperationDefinition](operationdefinition.html): The operation definition publication date\r\n* [PlanDefinition](plandefinition.html): The plan definition publication date\r\n* [Questionnaire](questionnaire.html): The questionnaire publication date\r\n* [Requirements](requirements.html): The requirements publication date\r\n* [SearchParameter](searchparameter.html): The search parameter publication date\r\n* [StructureDefinition](structuredefinition.html): The structure definition publication date\r\n* [StructureMap](structuremap.html): The structure map publication date\r\n* [SubscriptionTopic](subscriptiontopic.html): Date status first applied\r\n* [TerminologyCapabilities](terminologycapabilities.html): The terminology capabilities publication date\r\n* [TestPlan](testplan.html): The test script publication date\r\n* [TestScript](testscript.html): The test script publication date\r\n* [ValueSet](valueset.html): The value set publication date\r\n"
    },
    {
      "name": "date",
      "expression": "AllergyIntolerance.recordedDate | (start | requestedPeriod.start).first() | AuditEvent.recorded | CarePlan.period | Composition.date | Consent.date | DiagnosticReport.effective.ofType(dateTime) | DiagnosticReport.effective.ofType(Period) | DocumentReference.date | Encounter.actualPeriod | EpisodeOfCare.period | FamilyMemberHistory.date | Flag.period | (Immunization.occurrence.ofType(dateTime)) | ImmunizationEvaluation.date | ImmunizationRecommendation.date | Invoice.date | List.date | MeasureReport.date | NutritionIntake.occurrence.ofType(dateTime) | NutritionIntake.occurrence.ofType(Period) | Observation.effective.ofType(dateTime) | Observation.effective.ofType(Period) | Observation.effective.ofType(Timing) | Observation.effective.ofType(instant) | Procedure.occurrence.ofType(dateTime) | Procedure.occurrence.ofType(Period) | Procedure.occurrence.ofType(Timing) | ResearchSubject.period | (RiskAssessment.occurrence.ofType(dateTime)) | SupplyRequest.authoredOn",
      "base": [
        "AllergyIntolerance",
        "Appointment",
        "AuditEvent",
        "CarePlan",
        "CareTeam",
        "Composition",
        "Consent",
        "DiagnosticReport",
        "DocumentReference",
        "Encounter",
        "EpisodeOfCare",
        "FamilyMemberHistory",
        "Flag",
        "Immunization",
        "ImmunizationEvaluation",
        "ImmunizationRecommendation",
        "Invoice",
        "List",
        "MeasureReport",
        "NutritionIntake",
        "Observation",
        "Procedure",
        "ResearchSubject",
        "RiskAssessment",
        "SupplyRequest"
      ],
      "type": "date",
      "description": "Multiple Resources: \r\n\r\n* [AllergyIntolerance](allergyintolerance.html): Date first version of the resource instance was recorded\r\n* [Appointment](appointment.html): Appointment date/time.\r\n* [AuditEvent](auditevent.html): Time when the event was recorded\r\n* [CarePlan](careplan.html): Time period plan covers\r\n* [CareTeam](careteam.html): A date within the coverage time period.\r\n* [Composition](composition.html): Composition editing time\r\n* [Consent](consent.html): When consent was agreed to\r\n* [DiagnosticReport](diagnosticreport.html): The clinically relevant time of the report\r\n* [DocumentReference](documentreference.html): When this document reference was created\r\n* [Encounter](encounter.html): A date within the actualPeriod the Encounter lasted\r\n* [EpisodeOfCare](episodeofcare.html): The provided date search value falls within the episode of care's period\r\n* [FamilyMemberHistory](familymemberhistory.html): When history was recorded or last updated\r\n* [Flag](flag.html): Time period when flag is active\r\n* [Immunization](immunization.html): Vaccination  (non)-Administration Date\r\n* [ImmunizationEvaluation](immunizationevaluation.html): Date the evaluation was generated\r\n* [ImmunizationRecommendation](immunizationrecommendation.html): Date recommendation(s) created\r\n* [Invoice](invoice.html): Invoice date / posting date\r\n* [List](list.html): When the list was prepared\r\n* [MeasureReport](measurereport.html): The date of the measure report\r\n* [NutritionIntake](nutritionintake.html): Date when patient was taking (or not taking) the medication\r\n* [Observation](observation.html): Clinically relevant time/time-period for observation\r\n* [Procedure](procedure.html): When the procedure occurred or is occurring\r\n* [ResearchSubject](researchsubject.html): Start and end of participation\r\n* [RiskAssessment](riskassessment.html): When was assessment made?\r\n* [SupplyRequest](supplyrequest.html): When the request was made\r\n"
    },
    {
      "name": "date",
      "expression": "ArtifactAssessment.date",
      "base": [
        "ArtifactAssessment"
      ],
      "type": "date",
      "description": "The artifact assessment publication date"
    },
    {
      "name": "date",
      "expression": "ClinicalAssessment.date",
      "base": [
        "Resource"
      ],
      "type": "date",
      "description": "When the assessment was documented"
    },
    {
      "name": "date",
      "expression": "DeviceAssociation.period",
      "base": [
        "DeviceAssociation"
      ],
      "type": "date",
      "description": "Search for associations at or within specific times"
    },
    {
      "name": "date",
      "expression": "OrganizationAffiliation.period",
      "base": [
        "OrganizationAffiliation"
      ],
      "type": "date",
      "description": "The period during which the participatingOrganization is affiliated with the primary organization"
    },
    {
      "name": "date",
      "expression": "PractitionerRole.period",
      "base": [
        "PractitionerRole"
      ],
      "type": "date",
      "description": "The period during which the practitioner is authorized to perform in these role(s)"
    },
    {
      "name": "date",
      "expression": "ResearchStudy.period",
      "base": [
        "ResearchStudy"
      ],
      "type": "date",
      "description": "When the study began and ended"
    },
    {
      "name": "date",
      "expression": "Schedule.planningHorizon",
      "base": [
        "Schedule"
      ],
      "type": "date",
      "description": "Search for Schedule resources that have a period that contains this date specified"
    },
    {
      "name": "date-start",
      "expression": "Encounter.actualPeriod.start",
      "base": [
        "Encounter"
      ],
      "type": "date",
      "description": "The actual start date of the Encounter"
    },
    {
      "name": "datetime",
      "expression": "NutritionOrder.dateTime",
      "base": [
        "NutritionOrder"
      ],
      "type": "date",
      "description": "Return nutrition orders requested on this date"
    },
    {
      "name": "datewritten",
      "expression": "VisionPrescription.dateWritten",
      "base": [
        "VisionPrescription"
      ],
      "type": "date",
      "description": "Return prescriptions written on this date"
    },
    {
      "name": "death-date",
      "expression": "(Patient.deceased.ofType(dateTime))",
      "base": [
        "Patient"
      ],
      "type": "date",
      "description": "The date of death has been provided and satisfies this search value"
    },
    {
      "name": "death-date",
      "expression": "(Person.deceased.ofType(dateTime))",
      "base": [
        "Person"
      ],
      "type": "date",
      "description": "The date of death has been provided and satisfies this search value"
    },
    {
      "name": "death-date",
      "expression": "(Practitioner.deceased.ofType(dateTime))",
      "base": [
        "Practitioner"
      ],
      "type": "date",
      "description": "The date of death has been provided and satisfies this search value"
    },
    {
      "name": "deceased",
      "expression": "Patient.deceased.exists() and Patient.deceased != false",
      "base": [
        "Patient"
      ],
      "type": "token",
      "description": "This patient has been marked as deceased, or has a death date entered"
    },
    {
      "name": "deceased",
      "expression": "Person.deceased.exists() and Person.deceased != false",
      "base": [
        "Person"
      ],
      "type": "token",
      "description": "This person has been marked as deceased, or has a death date entered"
    },
    {
      "name": "deceased",
      "expression": "Practitioner.deceased.exists() and Practitioner.deceased != false",
      "base": [
        "Practitioner"
      ],
      "type": "token",
      "description": "This Practitioner has been marked as deceased, or has a death date entered"
    },
    {
      "name": "definition",
      "expression": "Device.definition",
      "base": [
        "Device"
      ],
      "type": "reference",
      "description": "The definition / type of the device"
    },
    {
      "name": "definition",
      "expression": "PlanDefinition.action.definition.ofType(canonical) | PlanDefinition.action.definition.ofType(uri)",
      "base": [
        "PlanDefinition"
      ],
      "type": "reference",
      "description": "Activity or plan definitions used by plan definition"
    },
    {
      "name": "definition",
      "expression": "Questionnaire.item.definition",
      "base": [
        "Questionnaire"
      ],
      "type": "uri",
      "description": "ElementDefinition - details for the item"
    },
    {
      "name": "dependent",
      "expression": "Coverage.dependent",
      "base": [
        "Coverage"
      ],
      "type": "string",
      "description": "Dependent number"
    },
    {
      "name": "depends-on",
      "expression": "ActivityDefinition.relatedArtifact.where(type='depends-on').resource | ActivityDefinition.library | EventDefinition.relatedArtifact.where(type='depends-on').resource | Library.relatedArtifact.where(type='depends-on').resource | Measure.relatedArtifact.where(type='depends-on').resource | Measure.library | PlanDefinition.relatedArtifact.where(type='depends-on').resource | PlanDefinition.library",
      "base": [
        "ActivityDefinition",
        "EventDefinition",
        "Library",
        "Measure",
        "PlanDefinition"
      ],
      "type": "reference",
      "description": "Multiple Resources: \r\n\r\n* [ActivityDefinition](activitydefinition.html): What resource is being referenced\r\n* [EventDefinition](eventdefinition.html): What resource is being referenced\r\n* [Library](library.html): What resource is being referenced\r\n* [Measure](measure.html): What resource is being referenced\r\n* [PlanDefinition](plandefinition.html): What resource is being referenced\r\n"
    },
    {
      "name": "depends-on",
      "expression": "ImplementationGuide.dependsOn.uri",
      "base": [
        "ImplementationGuide"
      ],
      "type": "reference",
      "description": "Identity of the IG that this depends on"
    },
    {
      "name": "derivation",
      "expression": "StructureDefinition.derivation",
      "base": [
        "StructureDefinition"
      ],
      "type": "token",
      "description": "specialization | constraint - How relates to base definition"
    },
    {
      "name": "derived-from",
      "expression": "ActivityDefinition.relatedArtifact.where(type='derived-from').resource | CodeSystem.relatedArtifact.where(type='derived-from').resource | ConceptMap.relatedArtifact.where(type='derived-from').resource | EventDefinition.relatedArtifact.where(type='derived-from').resource | Library.relatedArtifact.where(type='derived-from').resource | Measure.relatedArtifact.where(type='derived-from').resource | NamingSystem.relatedArtifact.where(type='derived-from').resource | PlanDefinition.relatedArtifact.where(type='derived-from').resource | ValueSet.relatedArtifact.where(type='derived-from').resource",
      "base": [
        "ActivityDefinition",
        "CodeSystem",
        "ConceptMap",
        "EventDefinition",
        "Library",
        "Measure",
        "NamingSystem",
        "PlanDefinition",
        "ValueSet"
      ],
      "type": "reference",
      "description": "Multiple Resources: \r\n\r\n* [ActivityDefinition](activitydefinition.html): What resource is being referenced\r\n* [CodeSystem](codesystem.html): A resource that the CodeSystem is derived from\r\n* [ConceptMap](conceptmap.html): A resource that the ConceptMap is derived from\r\n* [EventDefinition](eventdefinition.html): What resource is being referenced\r\n* [Library](library.html): What resource is being referenced\r\n* [Measure](measure.html): What resource is being referenced\r\n* [NamingSystem](namingsystem.html): A resource that the NamingSystem is derived from\r\n* [PlanDefinition](plandefinition.html): What resource is being referenced\r\n* [ValueSet](valueset.html): A resource that the ValueSet is derived from\r\n"
    },
    {
      "name": "derived-from",
      "expression": "DeviceAlert.derivedFrom",
      "base": [
        "Resource"
      ],
      "type": "reference",
      "description": "Whether the alert is currently occuring"
    },
    {
      "name": "derived-from",
      "expression": "ImagingSelection.derivedFrom",
      "base": [
        "ImagingSelection"
      ],
      "type": "reference",
      "description": "The imaging study from which the imaging selection was derived"
    },
    {
      "name": "derived-from",
      "expression": "Observation.derivedFrom",
      "base": [
        "Observation"
      ],
      "type": "reference",
      "description": "Related measurements the observation is made from"
    },
    {
      "name": "derived-from",
      "expression": "Requirements.derivedFrom",
      "base": [
        "Requirements"
      ],
      "type": "reference",
      "description": "The requirements these are derived from"
    },
    {
      "name": "derived-from",
      "expression": "SearchParameter.derivedFrom",
      "base": [
        "SearchParameter"
      ],
      "type": "reference",
      "description": "Original definition for the search parameter"
    },
    {
      "name": "derived-or-self",
      "expression": "SubscriptionTopic.url | SubscriptionTopic.derivedFrom",
      "base": [
        "SubscriptionTopic"
      ],
      "type": "uri",
      "description": "A server defined search that matches either the url or derivedFrom"
    },
    {
      "name": "description",
      "expression": "DocumentReference.description",
      "base": [
        "DocumentReference"
      ],
      "type": "string",
      "description": "Human-readable description"
    },
    {
      "name": "description",
      "expression": "Goal.description",
      "base": [
        "Goal"
      ],
      "type": "token",
      "description": "Code or text describing goal"
    },
    {
      "name": "description",
      "expression": "ResearchStudy.description",
      "base": [
        "ResearchStudy"
      ],
      "type": "string",
      "description": "Detailed narrative of the study"
    },
    {
      "name": "destination",
      "expression": "MedicationDispense.destination",
      "base": [
        "MedicationDispense"
      ],
      "type": "reference",
      "description": "Returns dispenses that should be sent to a specific destination"
    },
    {
      "name": "detail-udi",
      "expression": "Claim.item.detail.udi",
      "base": [
        "Claim"
      ],
      "type": "reference",
      "description": "UDI associated with a line item, detail product or service"
    },
    {
      "name": "detail-udi",
      "expression": "ExplanationOfBenefit.item.detail.udi",
      "base": [
        "ExplanationOfBenefit"
      ],
      "type": "reference",
      "description": "UDI associated with a line item detail product or service"
    },
    {
      "name": "device",
      "expression": "AdministrableProductDefinition.device",
      "base": [
        "AdministrableProductDefinition"
      ],
      "type": "reference",
      "description": "A device that is integral to the medicinal product, in effect being considered as an \"ingredient\" of the medicinal product. This is not intended for devices that are just co-packaged"
    },
    {
      "name": "device",
      "expression": "DeviceAssociation.device",
      "base": [
        "DeviceAssociation"
      ],
      "type": "reference",
      "description": "Search for products that match this code"
    },
    {
      "name": "device",
      "expression": "DeviceMetric.device",
      "base": [
        "DeviceMetric"
      ],
      "type": "reference",
      "description": "The device resource"
    },
    {
      "name": "device",
      "expression": "DeviceRequest.code.reference",
      "base": [
        "DeviceRequest"
      ],
      "type": "reference",
      "description": "Reference to resource that is being requested/ordered"
    },
    {
      "name": "device",
      "expression": "DeviceUsage.device.concept",
      "base": [
        "DeviceUsage"
      ],
      "type": "token",
      "description": "Search by device"
    },
    {
      "name": "device",
      "expression": "MedicationAdministration.device.reference",
      "base": [
        "MedicationAdministration"
      ],
      "type": "reference",
      "description": "Return administrations with this administration device identity"
    },
    {
      "name": "device",
      "expression": "PackagedProductDefinition.packaging.containedItem.item.reference",
      "base": [
        "PackagedProductDefinition"
      ],
      "type": "reference",
      "description": "A device within this packaged product"
    },
    {
      "name": "device-name",
      "expression": "Device.name.value | Device.type.coding.display | Device.type.text",
      "base": [
        "Device"
      ],
      "type": "string",
      "description": "A server defined search that may match any of the string fields in Device.name or Device.type."
    },
    {
      "name": "device-name",
      "expression": "DeviceDefinition.deviceName.name | DeviceDefinition.classification.type.coding.display | DeviceDefinition.classification.type.text",
      "base": [
        "DeviceDefinition"
      ],
      "type": "string",
      "description": "A server defined search that may match any of the string fields in DeviceDefinition.name or DeviceDefinition.classification.type - the latter to search for 'generic' devices."
    },
    {
      "name": "diagnosis-code",
      "expression": "Encounter.diagnosis.condition.concept",
      "base": [
        "Encounter"
      ],
      "type": "token",
      "description": "The diagnosis or procedure relevant to the encounter (coded)"
    },
    {
      "name": "diagnosis-code",
      "expression": "EpisodeOfCare.diagnosis.condition.concept",
      "base": [
        "EpisodeOfCare"
      ],
      "type": "token",
      "description": "Conditions/problems/diagnoses this episode of care is for (coded)"
    },
    {
      "name": "diagnosis-reference",
      "expression": "Encounter.diagnosis.condition.reference",
      "base": [
        "Encounter"
      ],
      "type": "reference",
      "description": "The diagnosis or procedure relevant to the encounter (resource reference)"
    },
    {
      "name": "diagnosis-reference",
      "expression": "EpisodeOfCare.diagnosis.condition.reference",
      "base": [
        "EpisodeOfCare"
      ],
      "type": "reference",
      "description": "Conditions/problems/diagnoses this episode of care is for (resource reference)"
    },
    {
      "name": "dicom-class",
      "expression": "ImagingStudy.series.instance.sopClass",
      "base": [
        "ImagingStudy"
      ],
      "type": "uri",
      "description": "The type of the instance"
    },
    {
      "name": "disposition",
      "expression": "ClaimResponse.disposition",
      "base": [
        "ClaimResponse"
      ],
      "type": "string",
      "description": "The contents of the disposition message"
    },
    {
      "name": "disposition",
      "expression": "CoverageEligibilityResponse.disposition",
      "base": [
        "CoverageEligibilityResponse"
      ],
      "type": "string",
      "description": "The contents of the disposition message"
    },
    {
      "name": "disposition",
      "expression": "ExplanationOfBenefit.disposition",
      "base": [
        "ExplanationOfBenefit"
      ],
      "type": "string",
      "description": "The contents of the disposition message"
    },
    {
      "name": "disposition",
      "expression": "PaymentReconciliation.disposition",
      "base": [
        "PaymentReconciliation"
      ],
      "type": "string",
      "description": "The contents of the disposition message"
    },
    {
      "name": "domain",
      "expression": "Contract.domain",
      "base": [
        "Contract"
      ],
      "type": "reference",
      "description": "The domain of the contract"
    },
    {
      "name": "domain",
      "expression": "MedicinalProductDefinition.domain",
      "base": [
        "MedicinalProductDefinition"
      ],
      "type": "token",
      "description": "If this medicine applies to human or veterinary uses"
    },
    {
      "name": "domain",
      "expression": "SubstanceDefinition.domain",
      "base": [
        "SubstanceDefinition"
      ],
      "type": "token",
      "description": "If the substance applies to only human or veterinary use"
    },
    {
      "name": "dose-form",
      "expression": "AdministrableProductDefinition.administrableDoseForm",
      "base": [
        "AdministrableProductDefinition"
      ],
      "type": "token",
      "description": "The administrable dose form, i.e. the dose form of the final product after necessary reconstitution or processing"
    },
    {
      "name": "dose-form",
      "expression": "ManufacturedItemDefinition.manufacturedDoseForm",
      "base": [
        "ManufacturedItemDefinition"
      ],
      "type": "token",
      "description": "Dose form as manufactured and before any transformation into the pharmaceutical product"
    },
    {
      "name": "dose-status",
      "expression": "ImmunizationEvaluation.doseStatus",
      "base": [
        "ImmunizationEvaluation"
      ],
      "type": "token",
      "description": "The status of the dose relative to published recommendations"
    },
    {
      "name": "doseform",
      "expression": "MedicationKnowledge.definitional.doseForm",
      "base": [
        "MedicationKnowledge"
      ],
      "type": "token",
      "description": "powder | tablets | capsule +"
    },
    {
      "name": "effect",
      "expression": "AdverseEvent.effect.ofType(dateTime) | AdverseEvent.effect.ofType(Period)",
      "base": [
        "AdverseEvent"
      ],
      "type": "date",
      "description": "When the effect of the event occurred"
    },
    {
      "name": "effect",
      "expression": "ClinicalUseDefinition.undesirableEffect.symptomConditionEffect.concept",
      "base": [
        "ClinicalUseDefinition"
      ],
      "type": "token",
      "description": "The situation in which the undesirable effect may manifest, as a code"
    },
    {
      "name": "effect-reference",
      "expression": "ClinicalUseDefinition.undesirableEffect.symptomConditionEffect.reference",
      "base": [
        "ClinicalUseDefinition"
      ],
      "type": "reference",
      "description": "The situation in which the undesirable effect may manifest, as a reference"
    },
    {
      "name": "effective",
      "expression": "ActivityDefinition.effectivePeriod | ChargeItemDefinition.applicability.effectivePeriod | Citation.effectivePeriod | CodeSystem.effectivePeriod | ConceptMap.effectivePeriod | EventDefinition.effectivePeriod | Library.effectivePeriod | Measure.effectivePeriod | NamingSystem.effectivePeriod | PlanDefinition.effectivePeriod | Questionnaire.effectivePeriod | ValueSet.effectivePeriod",
      "base": [
        "ActivityDefinition",
        "ChargeItemDefinition",
        "Citation",
        "CodeSystem",
        "ConceptMap",
        "EventDefinition",
        "Library",
        "Measure",
        "NamingSystem",
        "PlanDefinition",
        "Questionnaire",
        "ValueSet"
      ],
      "type": "date",
      "description": "Multiple Resources: \r\n\r\n* [ActivityDefinition](activitydefinition.html): The time during which the activity definition is intended to be in use\r\n* [ChargeItemDefinition](chargeitemdefinition.html): The time during which the charge item definition is intended to be in use\r\n* [Citation](citation.html): The time during which the citation is intended to be in use\r\n* [CodeSystem](codesystem.html): The time during which the CodeSystem is intended to be in use\r\n* [ConceptMap](conceptmap.html): The time during which the ConceptMap is intended to be in use\r\n* [EventDefinition](eventdefinition.html): The time during which the event definition is intended to be in use\r\n* [Library](library.html): The time during which the library is intended to be in use\r\n* [Measure](measure.html): The time during which the measure is intended to be in use\r\n* [NamingSystem](namingsystem.html): The time during which the NamingSystem is intended to be in use\r\n* [PlanDefinition](plandefinition.html): The time during which the plan definition is intended to be in use\r\n* [Questionnaire](questionnaire.html): The time during which the questionnaire is intended to be in use\r\n* [ValueSet](valueset.html): The time during which the ValueSet is intended to be in use\r\n"
    },
    {
      "name": "effective",
      "expression": "MedicationStatement.effective.ofType(dateTime) | MedicationStatement.effective.ofType(Period)",
      "base": [
        "MedicationStatement"
      ],
      "type": "date",
      "description": "Date when patient was taking (or not taking) the medication"
    },
    {
      "name": "effective",
      "expression": "SubscriptionTopic.effectivePeriod",
      "base": [
        "SubscriptionTopic"
      ],
      "type": "date",
      "description": "Effective period"
    },
    {
      "name": "eligibility",
      "expression": "HealthcareService.eligibility.code",
      "base": [
        "HealthcareService"
      ],
      "type": "token",
      "description": "One of the HealthcareService's eligibility requirements"
    },
    {
      "name": "eligibility",
      "expression": "ResearchStudy.recruitment.eligibility",
      "base": [
        "ResearchStudy"
      ],
      "type": "reference",
      "description": "Inclusion and exclusion criteria"
    },
    {
      "name": "email",
      "expression": "OrganizationAffiliation.contact.telecom.where(system='email')",
      "base": [
        "OrganizationAffiliation"
      ],
      "type": "token",
      "description": "A value in an email contact"
    },
    {
      "name": "email",
      "expression": "Patient.telecom.where(system='email') | Person.telecom.where(system='email') | Practitioner.telecom.where(system='email') | PractitionerRole.contact.telecom.where(system='email') | RelatedPerson.telecom.where(system='email')",
      "base": [
        "Patient",
        "Person",
        "Practitioner",
        "PractitionerRole",
        "RelatedPerson"
      ],
      "type": "token",
      "description": "Multiple Resources: \r\n\r\n* [Patient](patient.html): A value in an email contact\r\n* [Person](person.html): A value in an email contact\r\n* [Practitioner](practitioner.html): A value in an email contact\r\n* [PractitionerRole](practitionerrole.html): A value in an email contact\r\n* [RelatedPerson](relatedperson.html): A value in an email contact\r\n"
    },
    {
      "name": "empty-reason",
      "expression": "List.emptyReason",
      "base": [
        "List"
      ],
      "type": "token",
      "description": "Why list is empty"
    },
    {
      "name": "encounter",
      "expression": "ClinicalAssessment.encounter",
      "base": [
        "Resource"
      ],
      "type": "reference",
      "description": "The Encounter during which this ClinicalAssessment was created"
    },
    {
      "name": "encounter",
      "expression": "Immunization.encounter",
      "base": [
        "Immunization"
      ],
      "type": "reference",
      "description": "The Encounter this Immunization was part of"
    },
    {
      "name": "encounter",
      "expression": "MedicationAdministration.encounter | MedicationRequest.encounter",
      "base": [
        "MedicationAdministration",
        "MedicationRequest"
      ],
      "type": "reference",
      "description": "Multiple Resources: \r\n\r\n* [MedicationAdministration](medicationadministration.html): Return administrations that share this encounter\r\n* [MedicationRequest](medicationrequest.html): Return prescriptions with this encounter identifier\r\n"
    },
    {
      "name": "end-date",
      "expression": "Encounter.actualPeriod.end",
      "base": [
        "Encounter"
      ],
      "type": "date",
      "description": "The actual end date of the Encounter"
    },
    {
      "name": "endpoint",
      "expression": "HealthcareService.endpoint",
      "base": [
        "HealthcareService"
      ],
      "type": "reference",
      "description": "Technical endpoints providing access to electronic services operated for the healthcare service"
    },
    {
      "name": "endpoint",
      "expression": "ImagingStudy.endpoint | ImagingStudy.series.endpoint",
      "base": [
        "ImagingStudy"
      ],
      "type": "reference",
      "description": "The endpoint for the study or series"
    },
    {
      "name": "endpoint",
      "expression": "InsuranceProduct.endpoint",
      "base": [
        "Resource"
      ],
      "type": "reference",
      "description": "The endpoint(s) applicable to this product"
    },
    {
      "name": "endpoint",
      "expression": "Location.endpoint",
      "base": [
        "Location"
      ],
      "type": "reference",
      "description": "Technical endpoints providing access to services operated for the location"
    },
    {
      "name": "endpoint",
      "expression": "Organization.endpoint",
      "base": [
        "Organization"
      ],
      "type": "reference",
      "description": "Technical endpoints providing access to services operated for the organization"
    },
    {
      "name": "endpoint",
      "expression": "OrganizationAffiliation.endpoint",
      "base": [
        "OrganizationAffiliation"
      ],
      "type": "reference",
      "description": "Technical endpoints providing access to services operated for this role"
    },
    {
      "name": "endpoint",
      "expression": "PractitionerRole.endpoint",
      "base": [
        "PractitionerRole"
      ],
      "type": "reference",
      "description": "Technical endpoints providing access to services operated for the practitioner with this role"
    },
    {
      "name": "entered-date",
      "expression": "ChargeItem.enteredDate",
      "base": [
        "ChargeItem"
      ],
      "type": "date",
      "description": "Date the charge item was entered"
    },
    {
      "name": "enterer",
      "expression": "ChargeItem.enterer",
      "base": [
        "ChargeItem"
      ],
      "type": "reference",
      "description": "Individual who was entering"
    },
    {
      "name": "enterer",
      "expression": "Claim.enterer",
      "base": [
        "Claim"
      ],
      "type": "reference",
      "description": "The party responsible for the entry of the Claim"
    },
    {
      "name": "enterer",
      "expression": "CoverageEligibilityRequest.enterer",
      "base": [
        "CoverageEligibilityRequest"
      ],
      "type": "reference",
      "description": "The party who is responsible for the request"
    },
    {
      "name": "enterer",
      "expression": "ExplanationOfBenefit.enterer",
      "base": [
        "ExplanationOfBenefit"
      ],
      "type": "reference",
      "description": "The party responsible for the entry of the Claim"
    },
    {
      "name": "entity",
      "expression": "AuditEvent.entity.what",
      "base": [
        "AuditEvent"
      ],
      "type": "reference",
      "description": "Specific instance of resource"
    },
    {
      "name": "entity",
      "expression": "Provenance.entity.what",
      "base": [
        "Provenance"
      ],
      "type": "reference",
      "description": "Identity of entity"
    },
    {
      "name": "entity-desc",
      "expression": "AuditEvent.entity.description",
      "base": [
        "AuditEvent"
      ],
      "type": "string",
      "description": "Description of an entity"
    },
    {
      "name": "entity-role",
      "expression": "AuditEvent.entity.role",
      "base": [
        "AuditEvent"
      ],
      "type": "token",
      "description": "What role the entity played"
    },
    {
      "name": "entry",
      "expression": "Composition.section.entry",
      "base": [
        "Composition"
      ],
      "type": "reference",
      "description": "A reference to data that supports this section"
    },
    {
      "name": "episode-of-care",
      "expression": "Encounter.episodeOfCare",
      "base": [
        "Encounter"
      ],
      "type": "reference",
      "description": "Episode(s) of care that this encounter should be recorded against"
    },
    {
      "name": "event",
      "expression": "MessageDefinition.event.ofType(Coding)",
      "base": [
        "MessageDefinition"
      ],
      "type": "token",
      "description": "The event that triggers the message or link to the event definition."
    },
    {
      "name": "event",
      "expression": "MessageHeader.event.ofType(Coding) | MessageHeader.event.ofType(canonical)",
      "base": [
        "MessageHeader"
      ],
      "type": "token",
      "description": "Code for the event this message represents or link to event definition"
    },
    {
      "name": "event",
      "expression": "SubscriptionTopic.trigger.event",
      "base": [
        "SubscriptionTopic"
      ],
      "type": "token",
      "description": "Event trigger"
    },
    {
      "name": "event-code",
      "expression": "Composition.event.detail.concept",
      "base": [
        "Composition"
      ],
      "type": "token",
      "description": "Main clinical acts documented as codes"
    },
    {
      "name": "event-code",
      "expression": "DocumentReference.event.concept",
      "base": [
        "DocumentReference"
      ],
      "type": "token",
      "description": "Main clinical acts documented"
    },
    {
      "name": "event-date",
      "expression": "(DeviceRequest.occurrence.ofType(dateTime)) | (DeviceRequest.occurrence.ofType(Period))",
      "base": [
        "DeviceRequest"
      ],
      "type": "date",
      "description": "When service should occur"
    },
    {
      "name": "event-reference",
      "expression": "Composition.event.detail.reference",
      "base": [
        "Composition"
      ],
      "type": "reference",
      "description": "Main clinical acts documented as references"
    },
    {
      "name": "event-reference",
      "expression": "DocumentReference.event.reference",
      "base": [
        "DocumentReference"
      ],
      "type": "reference",
      "description": "Main clinical acts documented"
    },
    {
      "name": "evidence",
      "expression": "Condition.evidence.concept",
      "base": [
        "Condition"
      ],
      "type": "token",
      "description": "Manifestation/symptom"
    },
    {
      "name": "Exampleconstraint",
      "expression": "Bundle.entry[0].resource",
      "base": [
        "Bundle"
      ],
      "type": "reference",
      "description": "Search Composition Bundle"
    },
    {
      "name": "ExampleSearchParameterOnAnExtension",
      "expression": "Patient.extension('http://example.org/fhir/StructureDefinition/participation-agreement').value",
      "base": [
        "Patient"
      ],
      "type": "reference",
      "description": "Search by url for a participation agreement, which is stored as an extension referencing a DocumentReference"
    },
    {
      "name": "exclude",
      "expression": "Group.characteristic.exclude",
      "base": [
        "Group"
      ],
      "type": "token",
      "description": "Group includes or excludes"
    },
    {
      "name": "excluded_structure",
      "expression": "BodyStructure.excludedStructure.structure",
      "base": [
        "BodyStructure"
      ],
      "type": "token",
      "description": "Body site excludedStructure structure"
    },
    {
      "name": "expansion",
      "expression": "ValueSet.expansion.identifier",
      "base": [
        "ValueSet"
      ],
      "type": "uri",
      "description": "Identifies the value set expansion (business identifier)"
    },
    {
      "name": "experimental",
      "expression": "ImplementationGuide.experimental",
      "base": [
        "ImplementationGuide"
      ],
      "type": "token",
      "description": "For testing only - never for real usage"
    },
    {
      "name": "experimental",
      "expression": "ObservationDefinition.experimental",
      "base": [
        "ObservationDefinition"
      ],
      "type": "token",
      "description": "Not for genuine usage (true)"
    },
    {
      "name": "experimental",
      "expression": "SpecimenDefinition.experimental",
      "base": [
        "SpecimenDefinition"
      ],
      "type": "token",
      "description": "Not for genuine usage (true)"
    },
    {
      "name": "experimental",
      "expression": "StructureDefinition.experimental",
      "base": [
        "StructureDefinition"
      ],
      "type": "token",
      "description": "For testing only - never for real usage"
    },
    {
      "name": "expiration-date",
      "expression": "Device.expirationDate",
      "base": [
        "Device"
      ],
      "type": "date",
      "description": "The expiration date of the device"
    },
    {
      "name": "expiration-date",
      "expression": "Medication.batch.expirationDate",
      "base": [
        "Medication"
      ],
      "type": "date",
      "description": "Returns medications in a batch with this expiration date"
    },
    {
      "name": "expiration-date",
      "expression": "NutritionProduct.instance.expiry",
      "base": [
        "NutritionProduct"
      ],
      "type": "date",
      "description": "When the product expired (or is expected to expire)"
    },
    {
      "name": "expiry",
      "expression": "Substance.expiry",
      "base": [
        "Substance"
      ],
      "type": "date",
      "description": "Expiry date of package or container of substance"
    },
    {
      "name": "ext-context",
      "expression": "StructureDefinition.context",
      "base": [
        "StructureDefinition"
      ],
      "type": "composite",
      "description": "An extension context assigned to the structure definition"
    },
    {
      "name": "ext-context-expression",
      "expression": "StructureDefinition.context.expression",
      "base": [
        "StructureDefinition"
      ],
      "type": "token",
      "description": "An expression of extension context assigned to the structure definition"
    },
    {
      "name": "ext-context-type",
      "expression": "StructureDefinition.context.type",
      "base": [
        "StructureDefinition"
      ],
      "type": "token",
      "description": "A type of extension context assigned to the structure definition"
    },
    {
      "name": "facility",
      "expression": "CoverageEligibilityRequest.facility",
      "base": [
        "CoverageEligibilityRequest"
      ],
      "type": "reference",
      "description": "Facility responsible for the goods and services"
    },
    {
      "name": "facility",
      "expression": "DocumentReference.facilityType",
      "base": [
        "DocumentReference"
      ],
      "type": "token",
      "description": "Kind of facility where patient was seen"
    },
    {
      "name": "facility",
      "expression": "ExplanationOfBenefit.facility",
      "base": [
        "ExplanationOfBenefit"
      ],
      "type": "reference",
      "description": "Facility responsible for the goods and services"
    },
    {
      "name": "factor-override",
      "expression": "ChargeItem.totalPriceComponent.factor",
      "base": [
        "ChargeItem"
      ],
      "type": "number",
      "description": "Factor overriding the associated rules"
    },
    {
      "name": "family",
      "expression": "Patient.name.family | Practitioner.name.family",
      "base": [
        "Patient",
        "Practitioner"
      ],
      "type": "string",
      "description": "Multiple Resources: \r\n\r\n* [Patient](patient.html): A portion of the family name of the patient\r\n* [Practitioner](practitioner.html): A portion of the family name\r\n"
    },
    {
      "name": "family",
      "expression": "Person.name.family",
      "base": [
        "Person"
      ],
      "type": "string",
      "description": "A portion of the family name of the person"
    },
    {
      "name": "family",
      "expression": "RelatedPerson.name.family",
      "base": [
        "RelatedPerson"
      ],
      "type": "string",
      "description": "A portion of the family name of the related person"
    },
    {
      "name": "fhirversion",
      "expression": "CapabilityStatement.fhirVersion",
      "base": [
        "CapabilityStatement"
      ],
      "type": "token",
      "description": "The version of FHIR"
    },
    {
      "name": "filter-event",
      "expression": "Subscription.filterBy.event",
      "base": [
        "Subscription"
      ],
      "type": "token",
      "description": "Filter event used to narrow notifications"
    },
    {
      "name": "filter-value",
      "expression": "Subscription.filterBy.value",
      "base": [
        "Subscription"
      ],
      "type": "string",
      "description": "Filter value used to narrow notifications"
    },
    {
      "name": "finding-code",
      "expression": "ClinicalAssessment.finding.item.concept",
      "base": [
        "Resource"
      ],
      "type": "token",
      "description": "Reference to a concept (by class)"
    },
    {
      "name": "finding-ref",
      "expression": "ClinicalAssessment.finding.item.reference",
      "base": [
        "Resource"
      ],
      "type": "reference",
      "description": "Reference to a resource (by instance)"
    },
    {
      "name": "focus",
      "expression": "GenomicStudy.analysis.focus",
      "base": [
        "GenomicStudy"
      ],
      "type": "reference",
      "description": "What the genomic study analysis is about, when it is not about the subject of record"
    },
    {
      "name": "focus",
      "expression": "MessageDefinition.focus.code",
      "base": [
        "MessageDefinition"
      ],
      "type": "token",
      "description": "A resource that is a permitted focus of the message"
    },
    {
      "name": "focus",
      "expression": "MessageHeader.focus",
      "base": [
        "MessageHeader"
      ],
      "type": "reference",
      "description": "The actual content of the message"
    },
    {
      "name": "focus",
      "expression": "Observation.focus",
      "base": [
        "Observation"
      ],
      "type": "reference",
      "description": "The focus of an observation when the focus is not the patient of record."
    },
    {
      "name": "focus",
      "expression": "Task.focus",
      "base": [
        "Task"
      ],
      "type": "reference",
      "description": "Search by task focus"
    },
    {
      "name": "focus-code",
      "expression": "ResearchStudy.focus.concept",
      "base": [
        "ResearchStudy"
      ],
      "type": "token",
      "description": "Drugs, devices, etc. under study, as a code"
    },
    {
      "name": "focus-reference",
      "expression": "ResearchStudy.focus.reference",
      "base": [
        "ResearchStudy"
      ],
      "type": "reference",
      "description": "Drugs, devices, etc. under study, as a reference"
    },
    {
      "name": "for",
      "expression": "Ingredient.for",
      "base": [
        "Ingredient"
      ],
      "type": "reference",
      "description": "The product which this ingredient is a constituent part of"
    },
    {
      "name": "form",
      "expression": "Medication.doseForm",
      "base": [
        "Medication"
      ],
      "type": "token",
      "description": "Returns medications for a specific dose form"
    },
    {
      "name": "form-of",
      "expression": "AdministrableProductDefinition.formOf",
      "base": [
        "AdministrableProductDefinition"
      ],
      "type": "reference",
      "description": "The medicinal product that this is an administrable form of. This is not a reference to the item(s) that make up this administrable form - it is the whole product"
    },
    {
      "name": "format",
      "expression": "CapabilityStatement.format",
      "base": [
        "CapabilityStatement"
      ],
      "type": "token",
      "description": "formats supported (xml | json | ttl | mime type)"
    },
    {
      "name": "format-canonical",
      "expression": "(DocumentReference.content.profile.value.ofType(canonical))",
      "base": [
        "DocumentReference"
      ],
      "type": "uri",
      "description": "Profile canonical content rules for the document"
    },
    {
      "name": "format-code",
      "expression": "(DocumentReference.content.profile.value.ofType(Coding))",
      "base": [
        "DocumentReference"
      ],
      "type": "token",
      "description": "Format code content rules for the document"
    },
    {
      "name": "format-uri",
      "expression": "(DocumentReference.content.profile.value.ofType(uri))",
      "base": [
        "DocumentReference"
      ],
      "type": "uri",
      "description": "Profile URI content rules for the document"
    },
    {
      "name": "formula",
      "expression": "NutritionOrder.enteralFormula.type.concept",
      "base": [
        "NutritionOrder"
      ],
      "type": "token",
      "description": "Type of enteral or infant formula"
    },
    {
      "name": "function",
      "expression": "Ingredient.function",
      "base": [
        "Ingredient"
      ],
      "type": "token",
      "description": "A classification of the ingredient identifying its precise purpose(s) in the drug product. This extends the Ingredient.role to add more detail. Example: Antioxidant, Alkalizing Agent"
    },
    {
      "name": "gender",
      "expression": "Patient.gender | Person.gender | Practitioner.gender | RelatedPerson.gender",
      "base": [
        "Patient",
        "Person",
        "Practitioner",
        "RelatedPerson"
      ],
      "type": "token",
      "description": "Multiple Resources: \r\n\r\n* [Patient](patient.html): Gender of the patient\r\n* [Person](person.html): The gender of the person\r\n* [Practitioner](practitioner.html): Gender of the practitioner\r\n* [RelatedPerson](relatedperson.html): Gender of the related person\r\n"
    },
    {
      "name": "general-practitioner",
      "expression": "Patient.generalPractitioner",
      "base": [
        "Patient"
      ],
      "type": "reference",
      "description": "Patient's nominated general practitioner, not the organization that manages the record"
    },
    {
      "name": "given",
      "expression": "Person.name.given",
      "base": [
        "Person"
      ],
      "type": "string",
      "description": "A portion of the given name of the person"
    },
    {
      "name": "given",
      "expression": "RelatedPerson.name.given",
      "base": [
        "RelatedPerson"
      ],
      "type": "string",
      "description": "A portion of the given name of the related person"
    },
    {
      "name": "global",
      "expression": "ImplementationGuide.global.profile",
      "base": [
        "ImplementationGuide"
      ],
      "type": "reference",
      "description": "Profile that all resources must conform to"
    },
    {
      "name": "goal",
      "expression": "CarePlan.goal",
      "base": [
        "CarePlan"
      ],
      "type": "reference",
      "description": "Desired outcome of plan"
    },
    {
      "name": "grantee",
      "expression": "Consent.grantee",
      "base": [
        "Consent"
      ],
      "type": "reference",
      "description": "Who is agreeing to the policy and rules"
    },
    {
      "name": "group",
      "expression": "Appointment.participant.actor.where(resolve() is Group) | Appointment.subject.where(resolve() is Group)",
      "base": [
        "Appointment"
      ],
      "type": "reference",
      "description": "One of the individuals of the appointment is this patient"
    },
    {
      "name": "group",
      "expression": "AppointmentResponse.actor.where(resolve() is Group)",
      "base": [
        "AppointmentResponse"
      ],
      "type": "reference",
      "description": "This Response is for this Group"
    },
    {
      "name": "group-identifier",
      "expression": "CommunicationRequest.groupIdentifier",
      "base": [
        "CommunicationRequest"
      ],
      "type": "token",
      "description": "Composite request this is part of"
    },
    {
      "name": "group-identifier",
      "expression": "DeviceRequest.groupIdentifier",
      "base": [
        "DeviceRequest"
      ],
      "type": "token",
      "description": "Composite request this is part of"
    },
    {
      "name": "group-identifier",
      "expression": "MedicationRequest.groupIdentifier",
      "base": [
        "MedicationRequest"
      ],
      "type": "token",
      "description": "Composite request this is part of"
    },
    {
      "name": "group-identifier",
      "expression": "RequestOrchestration.groupIdentifier",
      "base": [
        "RequestOrchestration"
      ],
      "type": "token",
      "description": "The group identifier for the request orchestration"
    },
    {
      "name": "group-identifier",
      "expression": "Task.groupIdentifier",
      "base": [
        "Task"
      ],
      "type": "token",
      "description": "Search by group identifier"
    },
    {
      "name": "group-or-identifier",
      "expression": "MedicationRequest.groupIdentifier | MedicationRequest.identifier",
      "base": [
        "MedicationRequest"
      ],
      "type": "token",
      "description": "Group ID or other identifier"
    },
    {
      "name": "guarantor",
      "expression": "Account.guarantor.party",
      "base": [
        "Account"
      ],
      "type": "reference",
      "description": "The parties ultimately responsible for balancing the Account"
    },
    {
      "name": "guarantor-account",
      "expression": "Account.guarantor.account",
      "base": [
        "Account"
      ],
      "type": "reference",
      "description": "Account to use for the guarantor"
    },
    {
      "name": "guide",
      "expression": "CapabilityStatement.implementationGuide",
      "base": [
        "CapabilityStatement"
      ],
      "type": "reference",
      "description": "Implementation guides supported"
    },
    {
      "name": "has-member",
      "expression": "Observation.hasMember",
      "base": [
        "Observation"
      ],
      "type": "reference",
      "description": "Related resource that belongs to the Observation group"
    },
    {
      "name": "has-part",
      "expression": "DeviceDefinition.hasPart.reference",
      "base": [
        "DeviceDefinition"
      ],
      "type": "reference",
      "description": "The manufacturer of the device"
    },
    {
      "name": "has-recurrence-template",
      "expression": "Appointment.recurrenceTemplate.exists()",
      "base": [
        "Appointment"
      ],
      "type": "token",
      "description": "This Appointment contains a recurrence template"
    },
    {
      "name": "holder",
      "expression": "RegulatedAuthorization.holder",
      "base": [
        "RegulatedAuthorization"
      ],
      "type": "reference",
      "description": "The organization that holds the granted authorization"
    },
    {
      "name": "id-type",
      "expression": "NamingSystem.uniqueId.type",
      "base": [
        "NamingSystem"
      ],
      "type": "token",
      "description": "oid | uuid | uri | other"
    },
    {
      "name": "identified",
      "expression": "DetectedIssue.identified.ofType(dateTime) | DetectedIssue.identified.ofType(Period)",
      "base": [
        "DetectedIssue"
      ],
      "type": "date",
      "description": "When identified"
    },
    {
      "name": "identifier",
      "expression": "ActivityDefinition.identifier | ActorDefinition.identifier | CapabilityStatement.identifier | ChargeItemDefinition.identifier | Citation.identifier | CodeSystem.identifier | ConceptMap.identifier | ConditionDefinition.identifier | DeviceDefinition.identifier | DeviceDefinition.udiDeviceIdentifier | EventDefinition.identifier | Evidence.identifier | EvidenceVariable.identifier | ExampleScenario.identifier | GraphDefinition.identifier | Group.identifier | ImplementationGuide.identifier | Library.identifier | Measure.identifier | MedicationKnowledge.identifier | MessageDefinition.identifier | NamingSystem.identifier | ObservationDefinition.identifier | OperationDefinition.identifier | PlanDefinition.identifier | Questionnaire.identifier | Requirements.identifier | SearchParameter.identifier | SpecimenDefinition.identifier | StructureDefinition.identifier | StructureMap.identifier | SubscriptionTopic.identifier | TerminologyCapabilities.identifier | TestPlan.identifier | TestScript.identifier | ValueSet.identifier",
      "base": [
        "ActivityDefinition",
        "ActorDefinition",
        "CapabilityStatement",
        "ChargeItemDefinition",
        "Citation",
        "CodeSystem",
        "ConceptMap",
        "ConditionDefinition",
        "DeviceDefinition",
        "EventDefinition",
        "Evidence",
        "EvidenceVariable",
        "ExampleScenario",
        "GraphDefinition",
        "Group",
        "ImplementationGuide",
        "Library",
        "Measure",
        "MedicationKnowledge",
        "MessageDefinition",
        "NamingSystem",
        "ObservationDefinition",
        "OperationDefinition",
        "PlanDefinition",
        "Questionnaire",
        "Requirements",
        "SearchParameter",
        "SpecimenDefinition",
        "StructureDefinition",
        "StructureMap",
        "SubscriptionTopic",
        "TerminologyCapabilities",
        "TestPlan",
        "TestScript",
        "ValueSet"
      ],
      "type": "token",
      "description": "Multiple Resources: \r\n\r\n* [ActivityDefinition](activitydefinition.html): External identifier for the activity definition\r\n* [ActorDefinition](actordefinition.html): External identifier for the Actor Definition\r\n* [CapabilityStatement](capabilitystatement.html): External identifier for the capability statement\r\n* [ChargeItemDefinition](chargeitemdefinition.html): External identifier for the charge item definition\r\n* [Citation](citation.html): External identifier for the citation\r\n* [CodeSystem](codesystem.html): External identifier for the code system\r\n* [ConceptMap](conceptmap.html): External identifier for the concept map\r\n* [ConditionDefinition](conditiondefinition.html): External identifier for the condition definition\r\n* [DeviceDefinition](devicedefinition.html): The identifier of the component\r\n* [EventDefinition](eventdefinition.html): External identifier for the event definition\r\n* [Evidence](evidence.html): External identifier for the evidence\r\n* [EvidenceVariable](evidencevariable.html): External identifier for the evidence variable\r\n* [ExampleScenario](examplescenario.html): External identifier for the example scenario\r\n* [GraphDefinition](graphdefinition.html): External identifier for the graph definition\r\n* [Group](group.html): Unique id\r\n* [ImplementationGuide](implementationguide.html): External identifier for the implementation guide\r\n* [Library](library.html): External identifier for the library\r\n* [Measure](measure.html): External identifier for the measure\r\n* [MedicationKnowledge](medicationknowledge.html): Business identifier for this medication\r\n* [MessageDefinition](messagedefinition.html): External identifier for the message definition\r\n* [NamingSystem](namingsystem.html): External identifier for the naming system\r\n* [ObservationDefinition](observationdefinition.html): The unique identifier associated with the specimen definition\r\n* [OperationDefinition](operationdefinition.html): External identifier for the search parameter\r\n* [PlanDefinition](plandefinition.html): External identifier for the plan definition\r\n* [Questionnaire](questionnaire.html): External identifier for the questionnaire\r\n* [Requirements](requirements.html): External identifier for the requirements\r\n* [SearchParameter](searchparameter.html): External identifier for the search parameter\r\n* [SpecimenDefinition](specimendefinition.html): The unique identifier associated with the SpecimenDefinition\r\n* [StructureDefinition](structuredefinition.html): External identifier for the structure definition\r\n* [StructureMap](structuremap.html): External identifier for the structure map\r\n* [SubscriptionTopic](subscriptiontopic.html): Business Identifier for SubscriptionTopic\r\n* [TerminologyCapabilities](terminologycapabilities.html): External identifier for the terminology capabilities\r\n* [TestPlan](testplan.html): An identifier for the test plan\r\n* [TestScript](testscript.html): External identifier for the test script\r\n* [ValueSet](valueset.html): External identifier for the value set\r\n"
    },
    {
      "name": "identifier",
      "expression": "AdministrableProductDefinition.identifier",
      "base": [
        "AdministrableProductDefinition"
      ],
      "type": "token",
      "description": "An identifier for the administrable product"
    },
    {
      "name": "identifier",
      "expression": "ArtifactAssessment.identifier",
      "base": [
        "ArtifactAssessment"
      ],
      "type": "token",
      "description": "The artifact assessment identifier"
    },
    {
      "name": "identifier",
      "expression": "BiologicallyDerivedProduct.identifier",
      "base": [
        "BiologicallyDerivedProduct"
      ],
      "type": "token",
      "description": "Identifier"
    },
    {
      "name": "identifier",
      "expression": "BiologicallyDerivedProductDispense.identifier",
      "base": [
        "BiologicallyDerivedProductDispense"
      ],
      "type": "token",
      "description": "The identifier of the dispense"
    },
    {
      "name": "identifier",
      "expression": "Bundle.identifier",
      "base": [
        "Bundle"
      ],
      "type": "token",
      "description": "Persistent identifier for the bundle"
    },
    {
      "name": "identifier",
      "expression": "ClinicalAssessment.identifier",
      "base": [
        "Resource"
      ],
      "type": "token",
      "description": "Business identifier"
    },
    {
      "name": "identifier",
      "expression": "ClinicalUseDefinition.identifier",
      "base": [
        "ClinicalUseDefinition"
      ],
      "type": "token",
      "description": "Business identifier for this issue"
    },
    {
      "name": "identifier",
      "expression": "Device.identifier",
      "base": [
        "Device"
      ],
      "type": "token",
      "description": "Instance id from manufacturer, owner, and others"
    },
    {
      "name": "identifier",
      "expression": "DeviceAlert.identifier",
      "base": [
        "Resource"
      ],
      "type": "token",
      "description": "The identifier of the alert"
    },
    {
      "name": "identifier",
      "expression": "DeviceAssociation.identifier",
      "base": [
        "DeviceAssociation"
      ],
      "type": "token",
      "description": "The identifier of the device association"
    },
    {
      "name": "identifier",
      "expression": "DeviceDispense.identifier",
      "base": [
        "DeviceDispense"
      ],
      "type": "token",
      "description": "The identifier of the dispense"
    },
    {
      "name": "identifier",
      "expression": "DeviceMetric.identifier",
      "base": [
        "DeviceMetric"
      ],
      "type": "token",
      "description": "The identifier of the metric"
    },
    {
      "name": "identifier",
      "expression": "EncounterHistory.identifier",
      "base": [
        "EncounterHistory"
      ],
      "type": "token",
      "description": "Identifier(s) by which this encounter is known"
    },
    {
      "name": "identifier",
      "expression": "Endpoint.identifier",
      "base": [
        "Endpoint"
      ],
      "type": "token",
      "description": "Identifies this endpoint across multiple systems"
    },
    {
      "name": "identifier",
      "expression": "EnrollmentResponse.identifier",
      "base": [
        "EnrollmentResponse"
      ],
      "type": "token",
      "description": "The business identifier of the EnrollmentResponse"
    },
    {
      "name": "identifier",
      "expression": "FormularyItem.identifier",
      "base": [
        "FormularyItem"
      ],
      "type": "token",
      "description": "Returns formulary items with this external identifier"
    },
    {
      "name": "identifier",
      "expression": "GenomicStudy.identifier",
      "base": [
        "GenomicStudy"
      ],
      "type": "token",
      "description": "Identifiers for the Study"
    },
    {
      "name": "identifier",
      "expression": "HealthcareService.identifier",
      "base": [
        "HealthcareService"
      ],
      "type": "token",
      "description": "External identifiers for this item"
    },
    {
      "name": "identifier",
      "expression": "Ingredient.identifier",
      "base": [
        "Ingredient"
      ],
      "type": "token",
      "description": "An identifier or code by which the ingredient can be referenced"
    },
    {
      "name": "identifier",
      "expression": "InsuranceProduct.identifier",
      "base": [
        "Resource"
      ],
      "type": "token",
      "description": "Any identifier for the product (not the accreditation issuer's identifier)"
    },
    {
      "name": "identifier",
      "expression": "InventoryItem.identifier",
      "base": [
        "InventoryItem"
      ],
      "type": "token",
      "description": "The identifier of the item"
    },
    {
      "name": "identifier",
      "expression": "InventoryReport.identifier",
      "base": [
        "InventoryReport"
      ],
      "type": "token",
      "description": "Search by identifier"
    },
    {
      "name": "identifier",
      "expression": "Location.identifier",
      "base": [
        "Location"
      ],
      "type": "token",
      "description": "An identifier for the location"
    },
    {
      "name": "identifier",
      "expression": "ManufacturedItemDefinition.identifier",
      "base": [
        "ManufacturedItemDefinition"
      ],
      "type": "token",
      "description": "Unique identifier"
    },
    {
      "name": "identifier",
      "expression": "MedicinalProductDefinition.identifier",
      "base": [
        "MedicinalProductDefinition"
      ],
      "type": "token",
      "description": "Business identifier for this product. Could be an MPID"
    },
    {
      "name": "identifier",
      "expression": "MolecularDefinition.identifier",
      "base": [
        "Resource"
      ],
      "type": "token",
      "description": "The unique identity for a particular sequence"
    },
    {
      "name": "identifier",
      "expression": "NutritionProduct.instance.identifier",
      "base": [
        "NutritionProduct"
      ],
      "type": "token",
      "description": "The identifier for the physical instance, typically a serial number"
    },
    {
      "name": "identifier",
      "expression": "Organization.identifier | Organization.qualification.identifier",
      "base": [
        "Organization"
      ],
      "type": "token",
      "description": "Any identifier for the organization (not the accreditation issuer's identifier)"
    },
    {
      "name": "identifier",
      "expression": "PackagedProductDefinition.identifier",
      "base": [
        "PackagedProductDefinition"
      ],
      "type": "token",
      "description": "Unique identifier"
    },
    {
      "name": "identifier",
      "expression": "Patient.identifier",
      "base": [
        "Patient"
      ],
      "type": "token",
      "description": "A patient identifier"
    },
    {
      "name": "identifier",
      "expression": "PaymentNotice.identifier",
      "base": [
        "PaymentNotice"
      ],
      "type": "token",
      "description": "The business identifier of the notice"
    },
    {
      "name": "identifier",
      "expression": "PaymentReconciliation.identifier",
      "base": [
        "PaymentReconciliation"
      ],
      "type": "token",
      "description": "The business identifier of the ExplanationOfBenefit"
    },
    {
      "name": "identifier",
      "expression": "Permission.identifier",
      "base": [
        "Permission"
      ],
      "type": "token",
      "description": "The unique id for a particular permission"
    },
    {
      "name": "identifier",
      "expression": "Practitioner.identifier | Practitioner.qualification.identifier",
      "base": [
        "Practitioner"
      ],
      "type": "token",
      "description": "A practitioner's Identifier"
    },
    {
      "name": "identifier",
      "expression": "PractitionerRole.identifier",
      "base": [
        "PractitionerRole"
      ],
      "type": "token",
      "description": "A practitioner's Identifier"
    },
    {
      "name": "identifier",
      "expression": "RegulatedAuthorization.identifier",
      "base": [
        "RegulatedAuthorization"
      ],
      "type": "token",
      "description": "Business identifier for the authorization, typically assigned by the authorizing body"
    },
    {
      "name": "identifier",
      "expression": "ResearchStudy.identifier",
      "base": [
        "ResearchStudy"
      ],
      "type": "token",
      "description": "Business Identifier for study"
    },
    {
      "name": "identifier",
      "expression": "Schedule.identifier",
      "base": [
        "Schedule"
      ],
      "type": "token",
      "description": "A Schedule Identifier"
    },
    {
      "name": "identifier",
      "expression": "Slot.identifier",
      "base": [
        "Slot"
      ],
      "type": "token",
      "description": "A Slot Identifier"
    },
    {
      "name": "identifier",
      "expression": "Subscription.identifier",
      "base": [
        "Subscription"
      ],
      "type": "token",
      "description": "A subscription identifier"
    },
    {
      "name": "identifier",
      "expression": "SubstanceDefinition.identifier",
      "base": [
        "SubstanceDefinition"
      ],
      "type": "token",
      "description": "Identifier by which this substance is known"
    },
    {
      "name": "identifier",
      "expression": "TestReport.identifier",
      "base": [
        "TestReport"
      ],
      "type": "token",
      "description": "An external identifier for the test report"
    },
    {
      "name": "identifier",
      "expression": "Transport.identifier",
      "base": [
        "Transport"
      ],
      "type": "token",
      "description": "External identifier"
    },
    {
      "name": "IDSEARCHPARAMETER",
      "expression": "id",
      "base": [
        "Resource"
      ],
      "type": "token",
      "description": "Search by resource identifier - e.g. same as the read interaction, but can return included resources"
    },
    {
      "name": "immunization-event",
      "expression": "ImmunizationEvaluation.immunizationEvent",
      "base": [
        "ImmunizationEvaluation"
      ],
      "type": "reference",
      "description": "The vaccine administration event being evaluated"
    },
    {
      "name": "implicated",
      "expression": "DetectedIssue.implicated",
      "base": [
        "DetectedIssue"
      ],
      "type": "reference",
      "description": "Problem resource"
    },
    {
      "name": "in-response-to",
      "expression": "Communication.inResponseTo",
      "base": [
        "Communication"
      ],
      "type": "reference",
      "description": "Reply to"
    },
    {
      "name": "included_structure",
      "expression": "BodyStructure.includedStructure.structure",
      "base": [
        "BodyStructure"
      ],
      "type": "token",
      "description": "Body site includedStructure structure"
    },
    {
      "name": "incoming-referral",
      "expression": "EpisodeOfCare.referralRequest",
      "base": [
        "EpisodeOfCare"
      ],
      "type": "reference",
      "description": "Incoming Referral Request"
    },
    {
      "name": "indication",
      "expression": "ClinicalUseDefinition.indication.diseaseSymptomProcedure.concept",
      "base": [
        "ClinicalUseDefinition"
      ],
      "type": "token",
      "description": "The situation that is being documented as an indicaton for this item, as a code"
    },
    {
      "name": "indication",
      "expression": "DeviceAlert.signal.indication",
      "base": [
        "Resource"
      ],
      "type": "date",
      "description": "When the signal was being annunciated"
    },
    {
      "name": "indication-reference",
      "expression": "ClinicalUseDefinition.indication.diseaseSymptomProcedure.reference",
      "base": [
        "ClinicalUseDefinition"
      ],
      "type": "reference",
      "description": "The situation that is being documented as an indicaton for this item, as a reference"
    },
    {
      "name": "information",
      "expression": "ImmunizationRecommendation.recommendation.supportingPatientInformation",
      "base": [
        "ImmunizationRecommendation"
      ],
      "type": "reference",
      "description": "Patient observations supporting recommendation"
    },
    {
      "name": "information-provider",
      "expression": "CommunicationRequest.informationProvider",
      "base": [
        "CommunicationRequest"
      ],
      "type": "reference",
      "description": "Who should share the information"
    },
    {
      "name": "ingredient",
      "expression": "AdministrableProductDefinition.ingredient",
      "base": [
        "AdministrableProductDefinition"
      ],
      "type": "token",
      "description": "The ingredients of this administrable medicinal product"
    },
    {
      "name": "ingredient",
      "expression": "ManufacturedItemDefinition.ingredient",
      "base": [
        "ManufacturedItemDefinition"
      ],
      "type": "token",
      "description": "An ingredient of this item"
    },
    {
      "name": "ingredient",
      "expression": "Medication.ingredient.item.reference",
      "base": [
        "Medication"
      ],
      "type": "reference",
      "description": "Returns medications for this ingredient reference"
    },
    {
      "name": "ingredient",
      "expression": "MedicationKnowledge.definitional.ingredient.item.reference",
      "base": [
        "MedicationKnowledge"
      ],
      "type": "reference",
      "description": "Reference to a resource (by instance)"
    },
    {
      "name": "ingredient",
      "expression": "MedicinalProductDefinition.ingredient",
      "base": [
        "MedicinalProductDefinition"
      ],
      "type": "token",
      "description": "An ingredient of this product"
    },
    {
      "name": "ingredient-code",
      "expression": "Medication.ingredient.item.concept",
      "base": [
        "Medication"
      ],
      "type": "token",
      "description": "Returns medications for this ingredient code"
    },
    {
      "name": "ingredient-item",
      "expression": "NutritionProduct.ingredient.item.concept",
      "base": [
        "NutritionProduct"
      ],
      "type": "token",
      "description": "The specific ingredient"
    },
    {
      "name": "input",
      "expression": "Task.input.value.ofType(Reference)",
      "base": [
        "Task"
      ],
      "type": "reference",
      "description": "Search by task input"
    },
    {
      "name": "input-profile",
      "expression": "OperationDefinition.inputProfile",
      "base": [
        "OperationDefinition"
      ],
      "type": "reference",
      "description": "Validation information for in parameters"
    },
    {
      "name": "instance",
      "expression": "ImagingStudy.series.instance.uid",
      "base": [
        "ImagingStudy"
      ],
      "type": "token",
      "description": "SOP Instance UID for an instance"
    },
    {
      "name": "instance",
      "expression": "OperationDefinition.instance",
      "base": [
        "OperationDefinition"
      ],
      "type": "token",
      "description": "Invoke on an instance?"
    },
    {
      "name": "instantiates",
      "expression": "Contract.instantiatesUri",
      "base": [
        "Contract"
      ],
      "type": "uri",
      "description": "A source definition of the contract"
    },
    {
      "name": "instantiates-canonical",
      "expression": "DeviceRequest.instantiatesCanonical",
      "base": [
        "DeviceRequest"
      ],
      "type": "reference",
      "description": "Instantiates FHIR protocol or definition"
    },
    {
      "name": "instantiates-canonical",
      "expression": "Observation.instantiates.ofType(canonical)",
      "base": [
        "Observation"
      ],
      "type": "uri",
      "description": "URL contained in instantiatesCanonical."
    },
    {
      "name": "instantiates-canonical",
      "expression": "RequestOrchestration.instantiatesCanonical",
      "base": [
        "RequestOrchestration"
      ],
      "type": "reference",
      "description": "The FHIR-based definition from which the request orchestration is realized"
    },
    {
      "name": "instantiates-canonical",
      "expression": "ServiceRequest.instantiatesCanonical",
      "base": [
        "ServiceRequest"
      ],
      "type": "reference",
      "description": "Instantiates FHIR protocol or definition"
    },
    {
      "name": "instantiates-reference",
      "expression": "Observation.instantiates.ofType(Reference)",
      "base": [
        "Observation"
      ],
      "type": "reference",
      "description": "Reference contained in instantiatesReference."
    },
    {
      "name": "instantiates-uri",
      "expression": "DeviceRequest.instantiatesUri",
      "base": [
        "DeviceRequest"
      ],
      "type": "uri",
      "description": "Instantiates external protocol or definition"
    },
    {
      "name": "instantiates-uri",
      "expression": "RequestOrchestration.instantiatesUri",
      "base": [
        "RequestOrchestration"
      ],
      "type": "uri",
      "description": "The external definition from which the request orchestration is realized"
    },
    {
      "name": "instantiates-uri",
      "expression": "ServiceRequest.instantiatesUri",
      "base": [
        "ServiceRequest"
      ],
      "type": "uri",
      "description": "Instantiates external protocol or definition"
    },
    {
      "name": "insurance",
      "expression": "DeviceRequest.insurance",
      "base": [
        "DeviceRequest"
      ],
      "type": "reference",
      "description": "Associated insurance coverage"
    },
    {
      "name": "insurer",
      "expression": "Claim.insurer",
      "base": [
        "Claim"
      ],
      "type": "reference",
      "description": "The target payor/insurer for the Claim"
    },
    {
      "name": "insurer",
      "expression": "ClaimResponse.insurer",
      "base": [
        "ClaimResponse"
      ],
      "type": "reference",
      "description": "The organization which generated this resource"
    },
    {
      "name": "insurer",
      "expression": "Coverage.insurer",
      "base": [
        "Coverage"
      ],
      "type": "reference",
      "description": "The identity of the insurer"
    },
    {
      "name": "insurer",
      "expression": "CoverageEligibilityResponse.insurer",
      "base": [
        "CoverageEligibilityResponse"
      ],
      "type": "reference",
      "description": "The organization which generated this resource"
    },
    {
      "name": "intended-performer",
      "expression": "MedicationRequest.performer",
      "base": [
        "MedicationRequest"
      ],
      "type": "reference",
      "description": "Returns the intended performer of the administration of the medication request"
    },
    {
      "name": "intended-performertype",
      "expression": "MedicationRequest.performerType",
      "base": [
        "MedicationRequest"
      ],
      "type": "token",
      "description": "Returns requests for a specific type of performer"
    },
    {
      "name": "intent",
      "expression": "CarePlan.intent",
      "base": [
        "CarePlan"
      ],
      "type": "token",
      "description": "proposal | plan | order | option | directive"
    },
    {
      "name": "intent",
      "expression": "DeviceRequest.intent",
      "base": [
        "DeviceRequest"
      ],
      "type": "token",
      "description": "proposal | plan | original-order |reflex-order"
    },
    {
      "name": "intent",
      "expression": "MedicationRequest.intent",
      "base": [
        "MedicationRequest"
      ],
      "type": "token",
      "description": "Returns prescriptions with different intents"
    },
    {
      "name": "intent",
      "expression": "RequestOrchestration.intent",
      "base": [
        "RequestOrchestration"
      ],
      "type": "token",
      "description": "The intent of the request orchestration"
    },
    {
      "name": "intent",
      "expression": "ServiceRequest.intent",
      "base": [
        "ServiceRequest"
      ],
      "type": "token",
      "description": "proposal | plan | directive | order +"
    },
    {
      "name": "interaction",
      "expression": "ClinicalUseDefinition.interaction.type",
      "base": [
        "ClinicalUseDefinition"
      ],
      "type": "token",
      "description": "The type of the interaction e.g. drug-drug interaction, drug-food interaction, drug-lab test interaction"
    },
    {
      "name": "interpretation",
      "expression": "Observation.interpretation",
      "base": [
        "Observation"
      ],
      "type": "token",
      "description": "The interpretation of the observation type"
    },
    {
      "name": "is-derived",
      "expression": "SpecimenDefinition.typeTested.isDerived",
      "base": [
        "SpecimenDefinition"
      ],
      "type": "token",
      "description": "Primary specimen (false) or derived specimen (true)"
    },
    {
      "name": "is-recurring",
      "expression": "Appointment.recurrenceTemplate.exists() | Appointment.originatingAppointment.exists()",
      "base": [
        "Appointment"
      ],
      "type": "token",
      "description": "This Appointment is a part of a recurring series of appointments (has a template or an originating appointment)"
    },
    {
      "name": "issued",
      "expression": "DiagnosticReport.issued",
      "base": [
        "DiagnosticReport"
      ],
      "type": "date",
      "description": "When the report was issued"
    },
    {
      "name": "issued",
      "expression": "ImagingSelection.issued",
      "base": [
        "ImagingSelection"
      ],
      "type": "date",
      "description": "The date / time the imaging selection was created"
    },
    {
      "name": "issued",
      "expression": "TestReport.issued",
      "base": [
        "TestReport"
      ],
      "type": "date",
      "description": "The test report generation date"
    },
    {
      "name": "issuer",
      "expression": "Invoice.issuer",
      "base": [
        "Invoice"
      ],
      "type": "reference",
      "description": "Issuing Organization of Invoice"
    },
    {
      "name": "item",
      "expression": "InventoryReport.inventoryListing.item.item.concept",
      "base": [
        "InventoryReport"
      ],
      "type": "token",
      "description": "Search by items in inventory report"
    },
    {
      "name": "item",
      "expression": "List.entry.item",
      "base": [
        "List"
      ],
      "type": "reference",
      "description": "Actual entry"
    },
    {
      "name": "item-code",
      "expression": "Questionnaire.item.code",
      "base": [
        "Questionnaire"
      ],
      "type": "token",
      "description": "A code that corresponds to one of the items in the questionnaire"
    },
    {
      "name": "item-date",
      "expression": "QuestionnaireResponse",
      "base": [
        "QuestionnaireResponse"
      ],
      "type": "composite",
      "description": "Question with items having the specified linkId and answers of type date or dateTime found within the response.  (Primarily for use as part of other composite search parameters.)  Refer to [questionnaireresponse.html#searching](searching guidance) on the resource page for considerations on the use of this parameter."
    },
    {
      "name": "item-number",
      "expression": "QuestionnaireResponse",
      "base": [
        "QuestionnaireResponse"
      ],
      "type": "composite",
      "description": "Question with items having the specified linkId and answers of type integer or decimal found within the response.  (Primarily for use as part of other composite search parameters.)  Refer to [questionnaireresponse.html#searching](searching guidance) on the resource page for considerations on the use of this parameter."
    },
    {
      "name": "item-quantity",
      "expression": "QuestionnaireResponse",
      "base": [
        "QuestionnaireResponse"
      ],
      "type": "composite",
      "description": "Question with items having the specified linkId and answers of type quantity found within the response.  (Primarily for use as part of other composite search parameters.)  Refer to [questionnaireresponse.html#searching](searching guidance) on the resource page for considerations on the use of this parameter."
    },
    {
      "name": "item-reference",
      "expression": "InventoryReport.inventoryListing.item.item.reference",
      "base": [
        "InventoryReport"
      ],
      "type": "reference",
      "description": "Search by items in inventory report"
    },
    {
      "name": "item-reference",
      "expression": "QuestionnaireResponse",
      "base": [
        "QuestionnaireResponse"
      ],
      "type": "composite",
      "description": "Question with items having the specified linkId and answers of type reference found within the response.  (Primarily for use as part of other composite search parameters.)  Refer to [questionnaireresponse.html#searching](searching guidance) on the resource page for considerations on the use of this parameter."
    },
    {
      "name": "item-string",
      "expression": "QuestionnaireResponse",
      "base": [
        "QuestionnaireResponse"
      ],
      "type": "composite",
      "description": "Question with items having the specified linkId and answers of type string found within the response.  (Primarily for use as part of other composite search parameters.)  Refer to [questionnaireresponse.html#searching](searching guidance) on the resource page for considerations on the use of this parameter."
    },
    {
      "name": "item-subject",
      "expression": "QuestionnaireResponse.item.where(extension('http://hl7.org/fhir/StructureDefinition/questionnaireresponse-isSubject').exists()).answer.value.ofType(Reference)",
      "base": [
        "QuestionnaireResponse"
      ],
      "type": "reference",
      "description": "Allows searching for QuestionnaireResponses by item value where the item has isSubject=true"
    },
    {
      "name": "item-udi",
      "expression": "Claim.item.udi",
      "base": [
        "Claim"
      ],
      "type": "reference",
      "description": "UDI associated with a line item product or service"
    },
    {
      "name": "item-udi",
      "expression": "ExplanationOfBenefit.item.udi",
      "base": [
        "ExplanationOfBenefit"
      ],
      "type": "reference",
      "description": "UDI associated with a line item product or service"
    },
    {
      "name": "item-uri",
      "expression": "QuestionnaireResponse",
      "base": [
        "QuestionnaireResponse"
      ],
      "type": "composite",
      "description": "Question with items having the specified linkId and answers of type uri found within the response.  (Primarily for use as part of other composite search parameters.)  Refer to [questionnaireresponse.html#searching](searching guidance) on the resource page for considerations on the use of this parameter."
    },
    {
      "name": "keyword",
      "expression": "ResearchStudy.keyword",
      "base": [
        "ResearchStudy"
      ],
      "type": "token",
      "description": "Used to search for the study"
    },
    {
      "name": "keyword",
      "expression": "StructureDefinition.keyword",
      "base": [
        "StructureDefinition"
      ],
      "type": "token",
      "description": "A code for the StructureDefinition"
    },
    {
      "name": "kind",
      "expression": "ActivityDefinition.kind",
      "base": [
        "ActivityDefinition"
      ],
      "type": "token",
      "description": "The kind of activity definition"
    },
    {
      "name": "kind",
      "expression": "NamingSystem.kind",
      "base": [
        "NamingSystem"
      ],
      "type": "token",
      "description": "codesystem | identifier | root"
    },
    {
      "name": "kind",
      "expression": "OperationDefinition.kind",
      "base": [
        "OperationDefinition"
      ],
      "type": "token",
      "description": "operation | query"
    },
    {
      "name": "kind",
      "expression": "StructureDefinition.kind",
      "base": [
        "StructureDefinition"
      ],
      "type": "token",
      "description": "primitive-type | complex-type | resource | logical"
    },
    {
      "name": "language",
      "expression": "CodeSystem.concept.designation.language",
      "base": [
        "CodeSystem"
      ],
      "type": "token",
      "description": "A language in which a designation is provided"
    },
    {
      "name": "language",
      "expression": "DocumentReference.content.attachment.language",
      "base": [
        "DocumentReference"
      ],
      "type": "token",
      "description": "Human language of the content (BCP-47)"
    },
    {
      "name": "language",
      "expression": "Patient.communication.language",
      "base": [
        "Patient"
      ],
      "type": "token",
      "description": "Language code (irrespective of use value)"
    },
    {
      "name": "last-reaction-date",
      "expression": "AllergyIntolerance.lastReactionOccurrence",
      "base": [
        "AllergyIntolerance"
      ],
      "type": "date",
      "description": "Date(/time) of last known occurrence of a reaction"
    },
    {
      "name": "length",
      "expression": "Encounter.length",
      "base": [
        "Encounter"
      ],
      "type": "quantity",
      "description": "Length of encounter in days"
    },
    {
      "name": "lifecycle-status",
      "expression": "Goal.lifecycleStatus",
      "base": [
        "Goal"
      ],
      "type": "token",
      "description": "proposed | planned | accepted | active | on-hold | completed | cancelled | entered-in-error | rejected"
    },
    {
      "name": "link",
      "expression": "Patient.link.other",
      "base": [
        "Patient"
      ],
      "type": "reference",
      "description": "All patients/related persons linked to the given patient"
    },
    {
      "name": "link",
      "expression": "Person.link.target",
      "base": [
        "Person"
      ],
      "type": "reference",
      "description": "Any link has this Patient, Person, RelatedPerson or Practitioner reference"
    },
    {
      "name": "linkid",
      "expression": "QuestionnaireResponse.item.linkId",
      "base": [
        "QuestionnaireResponse"
      ],
      "type": "token",
      "description": "Question linkIds found within the response"
    },
    {
      "name": "location",
      "expression": "AdverseEvent.location",
      "base": [
        "AdverseEvent"
      ],
      "type": "reference",
      "description": "Location where adverse event occurred"
    },
    {
      "name": "location",
      "expression": "Appointment.participant.actor.where(resolve() is Location)",
      "base": [
        "Appointment"
      ],
      "type": "reference",
      "description": "This location is listed in the participants of the appointment"
    },
    {
      "name": "location",
      "expression": "AppointmentResponse.actor.where(resolve() is Location)",
      "base": [
        "AppointmentResponse"
      ],
      "type": "reference",
      "description": "This Response is for this Location"
    },
    {
      "name": "location",
      "expression": "Device.location",
      "base": [
        "Device"
      ],
      "type": "reference",
      "description": "A location, where the resource is found"
    },
    {
      "name": "location",
      "expression": "DocumentReference.content.attachment.url",
      "base": [
        "DocumentReference"
      ],
      "type": "uri",
      "description": "Uri where the data can be found"
    },
    {
      "name": "location",
      "expression": "Encounter.location.location",
      "base": [
        "Encounter"
      ],
      "type": "reference",
      "description": "Location the encounter takes place"
    },
    {
      "name": "location",
      "expression": "HealthcareService.location",
      "base": [
        "HealthcareService"
      ],
      "type": "reference",
      "description": "The location of the Healthcare Service"
    },
    {
      "name": "location",
      "expression": "Immunization.location",
      "base": [
        "Immunization"
      ],
      "type": "reference",
      "description": "The service delivery location or facility in which the vaccine was / was to be administered"
    },
    {
      "name": "location",
      "expression": "MeasureReport.location",
      "base": [
        "MeasureReport"
      ],
      "type": "reference",
      "description": "The location to return measure report results for"
    },
    {
      "name": "location",
      "expression": "OrganizationAffiliation.location",
      "base": [
        "OrganizationAffiliation"
      ],
      "type": "reference",
      "description": "The location(s) at which the role occurs"
    },
    {
      "name": "location",
      "expression": "PractitionerRole.location",
      "base": [
        "PractitionerRole"
      ],
      "type": "reference",
      "description": "One of the locations at which this practitioner provides care"
    },
    {
      "name": "location",
      "expression": "Procedure.location",
      "base": [
        "Procedure"
      ],
      "type": "reference",
      "description": "Where the procedure happened"
    },
    {
      "name": "location",
      "expression": "Provenance.location",
      "base": [
        "Provenance"
      ],
      "type": "reference",
      "description": "Where the activity occurred, if relevant"
    },
    {
      "name": "location-code",
      "expression": "ServiceRequest.location.concept",
      "base": [
        "ServiceRequest"
      ],
      "type": "token",
      "description": "The preferred location specified in the ServiceRequest (coded)"
    },
    {
      "name": "location-period",
      "expression": "Encounter.location.period",
      "base": [
        "Encounter"
      ],
      "type": "date",
      "description": "Time period during which the patient was present at a location (generally used via composite location-period)"
    },
    {
      "name": "location-reference",
      "expression": "ServiceRequest.location.reference",
      "base": [
        "ServiceRequest"
      ],
      "type": "reference",
      "description": "The preferred location specified in the ServiceRequest (resource reference)"
    },
    {
      "name": "location-value-period",
      "expression": "Encounter.location",
      "base": [
        "Encounter"
      ],
      "type": "composite",
      "description": "Time period during which the patient was present at the location"
    },
    {
      "name": "lot-number",
      "expression": "Immunization.lotNumber",
      "base": [
        "Immunization"
      ],
      "type": "string",
      "description": "Vaccine Lot Number"
    },
    {
      "name": "lot-number",
      "expression": "Medication.batch.lotNumber",
      "base": [
        "Medication"
      ],
      "type": "token",
      "description": "Returns medications in a batch with this lot number"
    },
    {
      "name": "lot-number",
      "expression": "NutritionProduct.instance.lotNumber",
      "base": [
        "NutritionProduct"
      ],
      "type": "token",
      "description": "The lot number"
    },
    {
      "name": "manager",
      "expression": "Consent.manager",
      "base": [
        "Consent"
      ],
      "type": "reference",
      "description": "Consent workflow management"
    },
    {
      "name": "managing-entity",
      "expression": "Group.managingEntity",
      "base": [
        "Group"
      ],
      "type": "reference",
      "description": "Entity that is the custodian of the Group's definition"
    },
    {
      "name": "manifestation",
      "expression": "DeviceAlert.signal.manifestation",
      "base": [
        "Resource"
      ],
      "type": "token",
      "description": "How the alert signal is manifested"
    },
    {
      "name": "manifestation-code",
      "expression": "AllergyIntolerance.reaction.manifestation.concept",
      "base": [
        "AllergyIntolerance"
      ],
      "type": "token",
      "description": "Clinical symptoms/signs associated with the Event"
    },
    {
      "name": "manifestation-reference",
      "expression": "AllergyIntolerance.reaction.manifestation.reference",
      "base": [
        "AllergyIntolerance"
      ],
      "type": "reference",
      "description": "Clinical symptoms/signs associated with the Event"
    },
    {
      "name": "manufacture-date",
      "expression": "Device.manufactureDate",
      "base": [
        "Device"
      ],
      "type": "date",
      "description": "The manufacture date of the device"
    },
    {
      "name": "manufactured-item",
      "expression": "AdministrableProductDefinition.producedFrom",
      "base": [
        "AdministrableProductDefinition"
      ],
      "type": "reference",
      "description": "The manufactured item(s) that this administrable product is produced from. Either a single item, or several that are mixed before administration (e.g. a power item and a solution item). Note that these are not raw ingredients"
    },
    {
      "name": "manufacturer",
      "expression": "Device.manufacturer",
      "base": [
        "Device"
      ],
      "type": "string",
      "description": "The manufacturer of the device"
    },
    {
      "name": "manufacturer",
      "expression": "DeviceDefinition.manufacturer",
      "base": [
        "DeviceDefinition"
      ],
      "type": "reference",
      "description": "The manufacturer of the device"
    },
    {
      "name": "manufacturer",
      "expression": "Immunization.manufacturer.reference",
      "base": [
        "Immunization"
      ],
      "type": "reference",
      "description": "Vaccine Manufacturer"
    },
    {
      "name": "manufacturer",
      "expression": "Ingredient.manufacturer.manufacturer",
      "base": [
        "Ingredient"
      ],
      "type": "reference",
      "description": "The organization that manufactures this ingredient"
    },
    {
      "name": "mapping-property",
      "expression": "ConceptMap.property.uri",
      "base": [
        "ConceptMap"
      ],
      "type": "uri",
      "description": "Other properties required for this mapping"
    },
    {
      "name": "marketingauthorizationholder",
      "expression": "Medication.marketingAuthorizationHolder",
      "base": [
        "Medication"
      ],
      "type": "reference",
      "description": "Returns medications made or sold for this marketing authorization holder"
    },
    {
      "name": "master-file",
      "expression": "MedicinalProductDefinition.masterFile",
      "base": [
        "MedicinalProductDefinition"
      ],
      "type": "reference",
      "description": "A master file for to the medicinal product (e.g. Pharmacovigilance System Master File)"
    },
    {
      "name": "measure",
      "expression": "MeasureReport.measure",
      "base": [
        "MeasureReport"
      ],
      "type": "reference",
      "description": "The measure to return measure report results for"
    },
    {
      "name": "media",
      "expression": "DiagnosticReport.media.link",
      "base": [
        "DiagnosticReport"
      ],
      "type": "reference",
      "description": "A reference to the image source."
    },
    {
      "name": "medication",
      "expression": "MedicationAdministration.medication.reference | MedicationDispense.medication.reference | MedicationRequest.medication.reference | MedicationStatement.medication.reference",
      "base": [
        "MedicationAdministration",
        "MedicationDispense",
        "MedicationRequest",
        "MedicationStatement"
      ],
      "type": "reference",
      "description": "Multiple Resources: \r\n\r\n* [MedicationAdministration](medicationadministration.html): Return administrations of this medication reference\r\n* [MedicationDispense](medicationdispense.html): Returns dispenses of this medicine resource\r\n* [MedicationRequest](medicationrequest.html): Return prescriptions for this medication reference\r\n* [MedicationStatement](medicationstatement.html): Return statements of this medication reference\r\n"
    },
    {
      "name": "medication",
      "expression": "PackagedProductDefinition.packaging.containedItem.item.reference",
      "base": [
        "PackagedProductDefinition"
      ],
      "type": "reference",
      "description": "A manufactured item of medication within this packaged product"
    },
    {
      "name": "medium",
      "expression": "Communication.medium",
      "base": [
        "Communication"
      ],
      "type": "token",
      "description": "A channel of communication"
    },
    {
      "name": "medium",
      "expression": "CommunicationRequest.medium",
      "base": [
        "CommunicationRequest"
      ],
      "type": "token",
      "description": "A channel of communication"
    },
    {
      "name": "member",
      "expression": "Group.member.entity",
      "base": [
        "Group"
      ],
      "type": "reference",
      "description": "Reference to the group member"
    },
    {
      "name": "member",
      "expression": "MolecularDefinition.member",
      "base": [
        "Resource"
      ],
      "type": "reference",
      "description": "Reference to the state of the molecular member"
    },
    {
      "name": "membership",
      "expression": "Group.membership",
      "base": [
        "Group"
      ],
      "type": "token",
      "description": "Definitional or enumerated group"
    },
    {
      "name": "message",
      "expression": "Bundle.entry[0].resource as MessageHeader",
      "base": [
        "Bundle"
      ],
      "type": "resource",
      "description": "The first resource in the bundle, if the bundle type is \"message\" - this is a message header, and this parameter provides access to search its contents"
    },
    {
      "name": "method",
      "expression": "Observation.method",
      "base": [
        "Observation"
      ],
      "type": "token",
      "description": "The method used for the observation"
    },
    {
      "name": "method",
      "expression": "ObservationDefinition.method",
      "base": [
        "ObservationDefinition"
      ],
      "type": "token",
      "description": "Method of observation"
    },
    {
      "name": "method",
      "expression": "RiskAssessment.method",
      "base": [
        "RiskAssessment"
      ],
      "type": "token",
      "description": "Evaluation mechanism"
    },
    {
      "name": "modality",
      "expression": "DocumentReference.modality",
      "base": [
        "DocumentReference"
      ],
      "type": "token",
      "description": "The modality used"
    },
    {
      "name": "modality",
      "expression": "ImagingStudy.series.modality",
      "base": [
        "ImagingStudy"
      ],
      "type": "token",
      "description": "The modality of the series"
    },
    {
      "name": "mode",
      "expression": "CapabilityStatement.rest.mode",
      "base": [
        "CapabilityStatement"
      ],
      "type": "token",
      "description": "Mode - restful (server/client) or messaging (sender/receiver)"
    },
    {
      "name": "mode",
      "expression": "Location.mode",
      "base": [
        "Location"
      ],
      "type": "token",
      "description": "The mode of the location (instance | kind)"
    },
    {
      "name": "model",
      "expression": "Device.modelNumber",
      "base": [
        "Device"
      ],
      "type": "string",
      "description": "The model of the device"
    },
    {
      "name": "model-number",
      "expression": "DeviceDefinition.modelNumber",
      "base": [
        "DeviceDefinition"
      ],
      "type": "token",
      "description": "The model of the device"
    },
    {
      "name": "modified",
      "expression": "Task.lastModified",
      "base": [
        "Task"
      ],
      "type": "date",
      "description": "Search by last modification date"
    },
    {
      "name": "moleculetype",
      "expression": "MolecularDefinition.moleculeType",
      "base": [
        "Resource"
      ],
      "type": "token",
      "description": "Amino Acid Sequence/ DNA Sequence / RNA Sequence"
    },
    {
      "name": "monitoring-program-name",
      "expression": "MedicationKnowledge.monitoringProgram.name",
      "base": [
        "MedicationKnowledge"
      ],
      "type": "token",
      "description": "Name of the reviewing program"
    },
    {
      "name": "monitoring-program-type",
      "expression": "MedicationKnowledge.monitoringProgram.type",
      "base": [
        "MedicationKnowledge"
      ],
      "type": "token",
      "description": "Type of program under which the medication is monitored"
    },
    {
      "name": "monograph",
      "expression": "MedicationKnowledge.monograph.source",
      "base": [
        "MedicationKnowledge"
      ],
      "type": "reference",
      "description": "Associated documentation about the medication"
    },
    {
      "name": "monograph-type",
      "expression": "MedicationKnowledge.monograph.type",
      "base": [
        "MedicationKnowledge"
      ],
      "type": "token",
      "description": "The category of medication document"
    },
    {
      "name": "morphology",
      "expression": "BodyStructure.morphology",
      "base": [
        "BodyStructure"
      ],
      "type": "token",
      "description": "Kind of Structure"
    },
    {
      "name": "name",
      "expression": "Account.name",
      "base": [
        "Account"
      ],
      "type": "string",
      "description": "Human-readable label"
    },
    {
      "name": "name",
      "expression": "ActivityDefinition.name | CapabilityStatement.name | Citation.name | CodeSystem.name | CompartmentDefinition.name | ConceptMap.name | ConditionDefinition.name | EventDefinition.name | EvidenceVariable.name | ExampleScenario.name | GraphDefinition.name | Group.name | ImplementationGuide.name | Library.name | Measure.name | MessageDefinition.name | NamingSystem.name | OperationDefinition.name | PlanDefinition.name | Questionnaire.name | Requirements.name | SearchParameter.name | StructureDefinition.name | StructureMap.name | TerminologyCapabilities.name | TestPlan.name | TestScript.name | ValueSet.name",
      "base": [
        "ActivityDefinition",
        "CapabilityStatement",
        "Citation",
        "CodeSystem",
        "CompartmentDefinition",
        "ConceptMap",
        "ConditionDefinition",
        "EventDefinition",
        "EvidenceVariable",
        "ExampleScenario",
        "GraphDefinition",
        "Group",
        "ImplementationGuide",
        "Library",
        "Measure",
        "MessageDefinition",
        "NamingSystem",
        "OperationDefinition",
        "PlanDefinition",
        "Questionnaire",
        "Requirements",
        "SearchParameter",
        "StructureDefinition",
        "StructureMap",
        "TerminologyCapabilities",
        "TestPlan",
        "TestScript",
        "ValueSet"
      ],
      "type": "string",
      "description": "Multiple Resources: \r\n\r\n* [ActivityDefinition](activitydefinition.html): Computationally friendly name of the activity definition\r\n* [CapabilityStatement](capabilitystatement.html): Computationally friendly name of the capability statement\r\n* [Citation](citation.html): Computationally friendly name of the citation\r\n* [CodeSystem](codesystem.html): Computationally friendly name of the code system\r\n* [CompartmentDefinition](compartmentdefinition.html): Computationally friendly name of the compartment definition\r\n* [ConceptMap](conceptmap.html): Computationally friendly name of the concept map\r\n* [ConditionDefinition](conditiondefinition.html): Computationally friendly name of the condition definition\r\n* [EventDefinition](eventdefinition.html): Computationally friendly name of the event definition\r\n* [EvidenceVariable](evidencevariable.html): Computationally friendly name of the evidence variable\r\n* [ExampleScenario](examplescenario.html): Computationally friendly name of the example scenario\r\n* [GraphDefinition](graphdefinition.html): Computationally friendly name of the graph definition\r\n* [Group](group.html): A portion of the Group's name\r\n* [ImplementationGuide](implementationguide.html): Computationally friendly name of the implementation guide\r\n* [Library](library.html): Computationally friendly name of the library\r\n* [Measure](measure.html): Computationally friendly name of the measure\r\n* [MessageDefinition](messagedefinition.html): Computationally friendly name of the message definition\r\n* [NamingSystem](namingsystem.html): Computationally friendly name of the naming system\r\n* [OperationDefinition](operationdefinition.html): Computationally friendly name of the operation definition\r\n* [PlanDefinition](plandefinition.html): Computationally friendly name of the plan definition\r\n* [Questionnaire](questionnaire.html): Computationally friendly name of the questionnaire\r\n* [Requirements](requirements.html): Computationally friendly name of the requirements\r\n* [SearchParameter](searchparameter.html): Computationally friendly name of the search parameter\r\n* [StructureDefinition](structuredefinition.html): Computationally friendly name of the structure definition\r\n* [StructureMap](structuremap.html): Computationally friendly name of the structure map\r\n* [TerminologyCapabilities](terminologycapabilities.html): Computationally friendly name of the terminology capabilities\r\n* [TestPlan](testplan.html): Computationally friendly name of the test script\r\n* [TestScript](testscript.html): Computationally friendly name of the test script\r\n* [ValueSet](valueset.html): Computationally friendly name of the value set\r\n"
    },
    {
      "name": "name",
      "expression": "CareTeam.name | CareTeam.extension('http://hl7.org/fhir/StructureDefinition/careteam-alias').value",
      "base": [
        "CareTeam"
      ],
      "type": "string",
      "description": "Name of the team, such as crisis assessment team"
    },
    {
      "name": "name",
      "expression": "Endpoint.name",
      "base": [
        "Endpoint"
      ],
      "type": "string",
      "description": "A name that this endpoint can be identified by"
    },
    {
      "name": "name",
      "expression": "HealthcareService.name",
      "base": [
        "HealthcareService"
      ],
      "type": "string",
      "description": "A portion of the Healthcare service name"
    },
    {
      "name": "name",
      "expression": "InsuranceProduct.name | InsuranceProduct.alias",
      "base": [
        "Resource"
      ],
      "type": "string",
      "description": "A portion of the insurance product's name or alias"
    },
    {
      "name": "name",
      "expression": "Location.name | Location.alias",
      "base": [
        "Location"
      ],
      "type": "string",
      "description": "A portion of the location's name or alias"
    },
    {
      "name": "name",
      "expression": "ManufacturedItemDefinition.name",
      "base": [
        "ManufacturedItemDefinition"
      ],
      "type": "token",
      "description": "A descriptive name applied to this item"
    },
    {
      "name": "name",
      "expression": "MedicinalProductDefinition.name.productName",
      "base": [
        "MedicinalProductDefinition"
      ],
      "type": "string",
      "description": "The full product name"
    },
    {
      "name": "name",
      "expression": "Organization.name | Organization.alias",
      "base": [
        "Organization"
      ],
      "type": "string",
      "description": "A portion of the organization's name or alias"
    },
    {
      "name": "name",
      "expression": "PackagedProductDefinition.name",
      "base": [
        "PackagedProductDefinition"
      ],
      "type": "token",
      "description": "A name for this package. Typically what it would be listed as in a drug formulary or catalogue, inventory etc."
    },
    {
      "name": "name",
      "expression": "Patient.name",
      "base": [
        "Patient"
      ],
      "type": "string",
      "description": "A server defined search that may match any of the string fields in the HumanName, including family, given, prefix, suffix, and/or text"
    },
    {
      "name": "name",
      "expression": "Person.name",
      "base": [
        "Person"
      ],
      "type": "string",
      "description": "A server defined search that may match any of the string fields in the HumanName, including family, give, prefix, suffix, suffix, and/or text"
    },
    {
      "name": "name",
      "expression": "RelatedPerson.name",
      "base": [
        "RelatedPerson"
      ],
      "type": "string",
      "description": "A server defined search that may match any of the string fields in the HumanName, including family, give, prefix, suffix, suffix, and/or text"
    },
    {
      "name": "name",
      "expression": "ResearchStudy.name",
      "base": [
        "ResearchStudy"
      ],
      "type": "string",
      "description": "Name for this study"
    },
    {
      "name": "name",
      "expression": "Schedule.name",
      "base": [
        "Schedule"
      ],
      "type": "string",
      "description": "A portion of the Schedule name"
    },
    {
      "name": "name",
      "expression": "SubstanceDefinition.name.name",
      "base": [
        "SubstanceDefinition"
      ],
      "type": "string",
      "description": "The actual name"
    },
    {
      "name": "name-language",
      "expression": "MedicinalProductDefinition.name.usage.language",
      "base": [
        "MedicinalProductDefinition"
      ],
      "type": "token",
      "description": "Language code for this name"
    },
    {
      "name": "near",
      "expression": "Location.position",
      "base": [
        "Location"
      ],
      "type": "special",
      "description": "Search for locations where the location.position is near to, or within a specified distance of, the provided coordinates expressed as [latitude]|[longitude]|[distance]|[units] (using the WGS84 datum, see notes).\n\nServers which support the near parameter SHALL support the unit string 'km' for kilometers and SHOULD support '[mi_us]' for miles, support for other units is optional. If the units are omitted, then kms should be assumed. If the distance is omitted, then the server can use its own discretion as to what distances should be considered near (and units are irrelevant).\r\rIf the server is unable to understand the units (and does support the near search parameter), it MIGHT return an OperationOutcome and fail the search with a http status 400 BadRequest. If the server does not support the near parameter, the parameter MIGHT report the unused parameter in a bundled OperationOutcome and still perform the search ignoring the near parameter.\n\nNote: The algorithm to determine the distance is not defined by the specification, and systems might have different engines that calculate things differently. They could consider geographic point to point, or path via road, or including current traffic conditions, or just simple neighboring postcodes/localities if that's all it had access to."
    },
    {
      "name": "network",
      "expression": "InsurancePlan.network",
      "base": [
        "InsurancePlan"
      ],
      "type": "reference",
      "description": "The product this plan is available to"
    },
    {
      "name": "network",
      "expression": "OrganizationAffiliation.network",
      "base": [
        "OrganizationAffiliation"
      ],
      "type": "reference",
      "description": "Health insurance provider network in which the participatingOrganization provides the role's services (if defined) at the indicated locations (if defined)"
    },
    {
      "name": "network",
      "expression": "PractitionerRole.network",
      "base": [
        "PractitionerRole"
      ],
      "type": "reference",
      "description": "Health insurance provider network in which the PractitionerRole provides the role's services (if defined) at the indicated locations (if defined)"
    },
    {
      "name": "notes",
      "expression": "List.note.text",
      "base": [
        "List"
      ],
      "type": "string",
      "description": "The annotation  - text content (as markdown)"
    },
    {
      "name": "nutrition",
      "expression": "NutritionIntake.nutritionItem.nutritionProduct.concept",
      "base": [
        "NutritionIntake"
      ],
      "type": "token",
      "description": "Return intakes for a specific consumed item"
    },
    {
      "name": "nutrition",
      "expression": "PackagedProductDefinition.packaging.containedItem.item.reference",
      "base": [
        "PackagedProductDefinition"
      ],
      "type": "reference",
      "description": "A nutrition product within this packaged product"
    },
    {
      "name": "objective-description",
      "expression": "ResearchStudy.objective.description",
      "base": [
        "ResearchStudy"
      ],
      "type": "string",
      "description": "Free text description of the objective of the study"
    },
    {
      "name": "objective-type",
      "expression": "ResearchStudy.objective.type",
      "base": [
        "ResearchStudy"
      ],
      "type": "token",
      "description": "The kind of study objective"
    },
    {
      "name": "occurrence",
      "expression": "ChargeItem.occurrence.ofType(dateTime) | ChargeItem.occurrence.ofType(Period) | ChargeItem.occurrence.ofType(Timing)",
      "base": [
        "ChargeItem"
      ],
      "type": "date",
      "description": "When the charged service was applied"
    },
    {
      "name": "occurrence",
      "expression": "CommunicationRequest.occurrence.ofType(dateTime) | CommunicationRequest.occurrence.ofType(Period)",
      "base": [
        "CommunicationRequest"
      ],
      "type": "date",
      "description": "When scheduled"
    },
    {
      "name": "occurrence",
      "expression": "ServiceRequest.occurrence.ofType(dateTime) | ServiceRequest.occurrence.ofType(Period) | ServiceRequest.occurrence.ofType(Timing)",
      "base": [
        "ServiceRequest"
      ],
      "type": "date",
      "description": "When service should occur"
    },
    {
      "name": "occurrence-changed",
      "expression": "Appointment.occurrenceChanged",
      "base": [
        "Appointment"
      ],
      "type": "token",
      "description": "This Appointment has been changed from the recurrence template"
    },
    {
      "name": "offered-in",
      "expression": "HealthcareService.offeredIn",
      "base": [
        "HealthcareService"
      ],
      "type": "reference",
      "description": "The service within which this service is offered"
    },
    {
      "name": "onset-age",
      "expression": "Condition.onset.ofType(Age) | Condition.onset.ofType(Range)",
      "base": [
        "Condition"
      ],
      "type": "quantity",
      "description": "Onsets as age or age range"
    },
    {
      "name": "onset-date",
      "expression": "Condition.onset.ofType(dateTime) | Condition.onset.ofType(Period)",
      "base": [
        "Condition"
      ],
      "type": "date",
      "description": "Date related onsets (dateTime and Period)"
    },
    {
      "name": "onset-info",
      "expression": "Condition.onset.ofType(string)",
      "base": [
        "Condition"
      ],
      "type": "string",
      "description": "Onsets as a string"
    },
    {
      "name": "operational-status",
      "expression": "Location.operationalStatus",
      "base": [
        "Location"
      ],
      "type": "token",
      "description": "Searches for locations (typically bed/room) that have an operational status (e.g. contaminated, housekeeping)"
    },
    {
      "name": "operator",
      "expression": "DeviceAssociation.operation.operator",
      "base": [
        "DeviceAssociation"
      ],
      "type": "reference",
      "description": "The identity of a operator for whom to list associations"
    },
    {
      "name": "oraldiet",
      "expression": "NutritionOrder.oralDiet.type",
      "base": [
        "NutritionOrder"
      ],
      "type": "token",
      "description": "Type of diet that can be consumed orally (i.e., take via the mouth)."
    },
    {
      "name": "organization",
      "expression": "EpisodeOfCare.managingOrganization",
      "base": [
        "EpisodeOfCare"
      ],
      "type": "reference",
      "description": "The organization that has assumed the specific responsibilities of this EpisodeOfCare"
    },
    {
      "name": "organization",
      "expression": "HealthcareService.providedBy",
      "base": [
        "HealthcareService"
      ],
      "type": "reference",
      "description": "The organization that provides this Healthcare Service"
    },
    {
      "name": "organization",
      "expression": "Patient.managingOrganization",
      "base": [
        "Patient"
      ],
      "type": "reference",
      "description": "The organization that is the custodian of the patient record"
    },
    {
      "name": "organization",
      "expression": "Person.managingOrganization",
      "base": [
        "Person"
      ],
      "type": "reference",
      "description": "The organization at which this person record is being managed"
    },
    {
      "name": "organization",
      "expression": "PractitionerRole.organization",
      "base": [
        "PractitionerRole"
      ],
      "type": "reference",
      "description": "The identity of the organization the practitioner represents / acts on behalf of"
    },
    {
      "name": "organization",
      "expression": "Specimen.container.device.resolve().owner",
      "base": [
        "Specimen"
      ],
      "type": "reference",
      "description": "The organization where the specimen is located"
    },
    {
      "name": "originating-appointment",
      "expression": "Appointment.originatingAppointment",
      "base": [
        "Appointment"
      ],
      "type": "reference",
      "description": "Reference to the Appointment that contains the recurrence template"
    },
    {
      "name": "other-map",
      "expression": "ConceptMap.group.unmapped.otherMap",
      "base": [
        "ConceptMap"
      ],
      "type": "reference",
      "description": "canonical reference to an additional ConceptMap to use for mapping if the source concept is unmapped"
    },
    {
      "name": "outcome",
      "expression": "AuditEvent.outcome.code",
      "base": [
        "AuditEvent"
      ],
      "type": "token",
      "description": "Whether the event succeeded or failed"
    },
    {
      "name": "outcome",
      "expression": "ClaimResponse.outcome",
      "base": [
        "ClaimResponse"
      ],
      "type": "token",
      "description": "The processing outcome"
    },
    {
      "name": "outcome",
      "expression": "CoverageEligibilityResponse.outcome",
      "base": [
        "CoverageEligibilityResponse"
      ],
      "type": "token",
      "description": "The processing outcome"
    },
    {
      "name": "outcome",
      "expression": "PaymentReconciliation.outcome",
      "base": [
        "PaymentReconciliation"
      ],
      "type": "token",
      "description": "The processing outcome"
    },
    {
      "name": "output",
      "expression": "Task.output.value.ofType(Reference)",
      "base": [
        "Task"
      ],
      "type": "reference",
      "description": "Search by task output"
    },
    {
      "name": "output-profile",
      "expression": "OperationDefinition.outputProfile",
      "base": [
        "OperationDefinition"
      ],
      "type": "reference",
      "description": "Validation information for out parameters"
    },
    {
      "name": "owner",
      "expression": "Account.owner",
      "base": [
        "Account"
      ],
      "type": "reference",
      "description": "Entity managing the Account"
    },
    {
      "name": "owner",
      "expression": "Subscription.managingEntity",
      "base": [
        "Subscription"
      ],
      "type": "reference",
      "description": "The managing entity"
    },
    {
      "name": "owner",
      "expression": "Task.owner",
      "base": [
        "Task"
      ],
      "type": "reference",
      "description": "Search by task owner"
    },
    {
      "name": "package",
      "expression": "PackagedProductDefinition.packaging.containedItem.item.reference",
      "base": [
        "PackagedProductDefinition"
      ],
      "type": "reference",
      "description": "A complete packaged product within this packaged product"
    },
    {
      "name": "package-for",
      "expression": "PackagedProductDefinition.packageFor",
      "base": [
        "PackagedProductDefinition"
      ],
      "type": "reference",
      "description": "The product that this is a pack for"
    },
    {
      "name": "packaging-cost",
      "expression": "MedicationKnowledge.packaging.cost.cost as Quantity",
      "base": [
        "MedicationKnowledge"
      ],
      "type": "quantity",
      "description": "The cost of the packaged medication, if the cost is Money"
    },
    {
      "name": "packaging-cost-concept",
      "expression": "MedicationKnowledge.packaging.cost.cost as CodeableConcept",
      "base": [
        "MedicationKnowledge"
      ],
      "type": "token",
      "description": "The cost of the packaged medication, if the cost is a CodeableConcept"
    },
    {
      "name": "parent",
      "expression": "Device.parent",
      "base": [
        "Device"
      ],
      "type": "reference",
      "description": "The parent device"
    },
    {
      "name": "parent",
      "expression": "Specimen.parent",
      "base": [
        "Specimen"
      ],
      "type": "reference",
      "description": "The parent of the specimen"
    },
    {
      "name": "part-of",
      "expression": "CarePlan.partOf",
      "base": [
        "CarePlan"
      ],
      "type": "reference",
      "description": "Part of referenced CarePlan"
    },
    {
      "name": "part-of",
      "expression": "Communication.partOf",
      "base": [
        "Communication"
      ],
      "type": "reference",
      "description": "Part of referenced event (e.g. Communication, Procedure)"
    },
    {
      "name": "part-of",
      "expression": "Encounter.partOf",
      "base": [
        "Encounter"
      ],
      "type": "reference",
      "description": "Another Encounter this encounter is part of"
    },
    {
      "name": "part-of",
      "expression": "Observation.partOf",
      "base": [
        "Observation"
      ],
      "type": "reference",
      "description": "Part of referenced event"
    },
    {
      "name": "part-of",
      "expression": "Procedure.partOf",
      "base": [
        "Procedure"
      ],
      "type": "reference",
      "description": "Part of referenced event"
    },
    {
      "name": "part-of",
      "expression": "QuestionnaireResponse.partOf",
      "base": [
        "QuestionnaireResponse"
      ],
      "type": "reference",
      "description": "Procedure or observation this questionnaire response was performed as a part of"
    },
    {
      "name": "part-of",
      "expression": "ResearchStudy.partOf",
      "base": [
        "ResearchStudy"
      ],
      "type": "reference",
      "description": "Part of larger study"
    },
    {
      "name": "part-of",
      "expression": "Task.partOf",
      "base": [
        "Task"
      ],
      "type": "reference",
      "description": "Search by task this task is part of"
    },
    {
      "name": "part-status",
      "expression": "Appointment.participant.status",
      "base": [
        "Appointment"
      ],
      "type": "token",
      "description": "The Participation status of the subject, or other participant on the appointment. Can be used to locate participants that have not responded to meeting requests."
    },
    {
      "name": "part-status",
      "expression": "AppointmentResponse.participantStatus",
      "base": [
        "AppointmentResponse"
      ],
      "type": "token",
      "description": "The participants acceptance status for this appointment"
    },
    {
      "name": "participant",
      "expression": "CareTeam.participant.member",
      "base": [
        "CareTeam"
      ],
      "type": "reference",
      "description": "Who is involved"
    },
    {
      "name": "participant",
      "expression": "Encounter.participant.actor",
      "base": [
        "Encounter"
      ],
      "type": "reference",
      "description": "Persons involved in the encounter other than the patient"
    },
    {
      "name": "participant",
      "expression": "RequestOrchestration.action.participant.actor.ofType(Reference) | RequestOrchestration.action.participant.actor.ofType(canonical)",
      "base": [
        "RequestOrchestration"
      ],
      "type": "reference",
      "description": "The participant in the requests in the orchestration"
    },
    {
      "name": "participant",
      "expression": "TestReport.participant.uri",
      "base": [
        "TestReport"
      ],
      "type": "uri",
      "description": "The reference to a participant in the test execution"
    },
    {
      "name": "participant-role",
      "expression": "Invoice.participant.role",
      "base": [
        "Invoice"
      ],
      "type": "token",
      "description": "Type of involvement in creation of this Invoice"
    },
    {
      "name": "participant-type",
      "expression": "Encounter.participant.type",
      "base": [
        "Encounter"
      ],
      "type": "token",
      "description": "Role of participant in encounter"
    },
    {
      "name": "participating-organization",
      "expression": "OrganizationAffiliation.participatingOrganization",
      "base": [
        "OrganizationAffiliation"
      ],
      "type": "reference",
      "description": "The organization that provides services to the primary organization"
    },
    {
      "name": "partof",
      "expression": "Location.partOf",
      "base": [
        "Location"
      ],
      "type": "reference",
      "description": "A location of which this location is a part"
    },
    {
      "name": "partof",
      "expression": "Organization.partOf",
      "base": [
        "Organization"
      ],
      "type": "reference",
      "description": "An organization of which this organization forms a part"
    },
    {
      "name": "path",
      "expression": "StructureDefinition.snapshot.element.path | StructureDefinition.differential.element.path",
      "base": [
        "StructureDefinition"
      ],
      "type": "token",
      "description": "A path that is constrained in the StructureDefinition"
    },
    {
      "name": "patient",
      "expression": "ClinicalAssessment.subject.where(resolve() is Patient)",
      "base": [
        "Resource"
      ],
      "type": "reference",
      "description": "Patient assessed"
    },
    {
      "name": "patient",
      "expression": "DeviceAlert.subject.where(resolve() is Patient)",
      "base": [
        "Resource"
      ],
      "type": "reference",
      "description": "The patient subject of the alert"
    },
    {
      "name": "patient",
      "expression": "DeviceDispense.subject.where(resolve() is Patient)",
      "base": [
        "DeviceDispense"
      ],
      "type": "reference",
      "description": "Returns device dispenses for a specific patient"
    },
    {
      "name": "patient",
      "expression": "EncounterHistory.subject.where(resolve() is Patient)",
      "base": [
        "EncounterHistory"
      ],
      "type": "reference",
      "description": "The patient present at the encounter"
    },
    {
      "name": "payee",
      "expression": "Claim.payee.party",
      "base": [
        "Claim"
      ],
      "type": "reference",
      "description": "The party receiving any payment for the Claim"
    },
    {
      "name": "payee",
      "expression": "ExplanationOfBenefit.payee.party",
      "base": [
        "ExplanationOfBenefit"
      ],
      "type": "reference",
      "description": "The party receiving any payment for the Claim"
    },
    {
      "name": "payload",
      "expression": "Subscription.contentType",
      "base": [
        "Subscription"
      ],
      "type": "token",
      "description": "The mime-type of notifications"
    },
    {
      "name": "payload-type",
      "expression": "Endpoint.payload.type",
      "base": [
        "Endpoint"
      ],
      "type": "token",
      "description": "The type of content that may be used at this endpoint (e.g. XDS Discharge summaries)"
    },
    {
      "name": "payment-date",
      "expression": "ClaimResponse.payment.date",
      "base": [
        "ClaimResponse"
      ],
      "type": "date",
      "description": "The expected payment date"
    },
    {
      "name": "payment-status",
      "expression": "PaymentNotice.paymentStatus",
      "base": [
        "PaymentNotice"
      ],
      "type": "token",
      "description": "The type of payment notice"
    },
    {
      "name": "paymentby-party",
      "expression": "Coverage.paymentBy.party",
      "base": [
        "Coverage"
      ],
      "type": "reference",
      "description": "Parties who will pay for services"
    },
    {
      "name": "performer",
      "expression": "BiologicallyDerivedProductDispense.performer.actor",
      "base": [
        "BiologicallyDerivedProductDispense"
      ],
      "type": "reference",
      "description": "The identity of a patient for whom to list dispenses"
    },
    {
      "name": "performer",
      "expression": "ClinicalAssessment.performer",
      "base": [
        "Resource"
      ],
      "type": "reference",
      "description": "The clinician performing the assessment"
    },
    {
      "name": "performer",
      "expression": "DeviceRequest.performer.reference",
      "base": [
        "DeviceRequest"
      ],
      "type": "reference",
      "description": "Desired performer for service"
    },
    {
      "name": "performer",
      "expression": "DiagnosticReport.performer",
      "base": [
        "DiagnosticReport"
      ],
      "type": "reference",
      "description": "Who is responsible for the report"
    },
    {
      "name": "performer",
      "expression": "ImagingStudy.series.performer.actor",
      "base": [
        "ImagingStudy"
      ],
      "type": "reference",
      "description": "The person who performed the study"
    },
    {
      "name": "performer",
      "expression": "Immunization.performer.actor",
      "base": [
        "Immunization"
      ],
      "type": "reference",
      "description": "The practitioner, individual or organization who played a role in the vaccination"
    },
    {
      "name": "performer",
      "expression": "MedicationAdministration.performer.actor.reference",
      "base": [
        "MedicationAdministration"
      ],
      "type": "reference",
      "description": "The identity of the individual who administered the medication"
    },
    {
      "name": "performer",
      "expression": "MedicationDispense.performer.actor",
      "base": [
        "MedicationDispense"
      ],
      "type": "reference",
      "description": "Returns dispenses performed by a specific individual"
    },
    {
      "name": "performer",
      "expression": "Observation.performer",
      "base": [
        "Observation"
      ],
      "type": "reference",
      "description": "Who performed the observation"
    },
    {
      "name": "performer",
      "expression": "Procedure.performer.actor",
      "base": [
        "Procedure"
      ],
      "type": "reference",
      "description": "Who performed the procedure"
    },
    {
      "name": "performer",
      "expression": "RiskAssessment.performer",
      "base": [
        "RiskAssessment"
      ],
      "type": "reference",
      "description": "Who did assessment?"
    },
    {
      "name": "performer",
      "expression": "ServiceRequest.performer",
      "base": [
        "ServiceRequest"
      ],
      "type": "reference",
      "description": "Requested performer"
    },
    {
      "name": "performer",
      "expression": "Task.requestedPerformer.concept",
      "base": [
        "Task"
      ],
      "type": "token",
      "description": "Search by recommended type of performer (e.g., Requester, Performer, Scheduler)."
    },
    {
      "name": "performer-actor",
      "expression": "ChargeItem.performer.actor",
      "base": [
        "ChargeItem"
      ],
      "type": "reference",
      "description": "Individual who was performing"
    },
    {
      "name": "performer-code",
      "expression": "DeviceRequest.performer.concept",
      "base": [
        "DeviceRequest"
      ],
      "type": "token",
      "description": "Desired performer for service"
    },
    {
      "name": "performer-device-code",
      "expression": "MedicationAdministration.performer.actor.concept",
      "base": [
        "MedicationAdministration"
      ],
      "type": "token",
      "description": "The identity of the individual who administered the medication"
    },
    {
      "name": "performer-function",
      "expression": "ChargeItem.performer.function",
      "base": [
        "ChargeItem"
      ],
      "type": "token",
      "description": "What type of performance was done"
    },
    {
      "name": "performer-type",
      "expression": "ServiceRequest.performerType",
      "base": [
        "ServiceRequest"
      ],
      "type": "token",
      "description": "Performer role"
    },
    {
      "name": "performing-organization",
      "expression": "ChargeItem.performingOrganization",
      "base": [
        "ChargeItem"
      ],
      "type": "reference",
      "description": "Organization providing the charged service"
    },
    {
      "name": "period",
      "expression": "Account.servicePeriod",
      "base": [
        "Account"
      ],
      "type": "date",
      "description": "Transaction window"
    },
    {
      "name": "period",
      "expression": "Composition.event.period",
      "base": [
        "Composition"
      ],
      "type": "date",
      "description": "The period covered by the documentation"
    },
    {
      "name": "period",
      "expression": "Consent.provision.period",
      "base": [
        "Consent"
      ],
      "type": "date",
      "description": "Timeframe for this rule"
    },
    {
      "name": "period",
      "expression": "DocumentReference.period",
      "base": [
        "DocumentReference"
      ],
      "type": "date",
      "description": "Time of service that is being documented"
    },
    {
      "name": "period",
      "expression": "MeasureReport.period",
      "base": [
        "MeasureReport"
      ],
      "type": "date",
      "description": "The period of the measure report"
    },
    {
      "name": "period",
      "expression": "NamingSystem.uniqueId.period",
      "base": [
        "NamingSystem"
      ],
      "type": "date",
      "description": "When is identifier valid?"
    },
    {
      "name": "period",
      "expression": "Task.executionPeriod",
      "base": [
        "Task"
      ],
      "type": "date",
      "description": "Search by period Task is/was underway"
    },
    {
      "name": "phase",
      "expression": "ResearchStudy.phase",
      "base": [
        "ResearchStudy"
      ],
      "type": "token",
      "description": "The stage in the progression of a study"
    },
    {
      "name": "phase",
      "expression": "TestScript.scope.phase.ofType(CodeableConcept)",
      "base": [
        "TestScript"
      ],
      "type": "token",
      "description": "The artifact phase of testing"
    },
    {
      "name": "phone",
      "expression": "OrganizationAffiliation.contact.telecom.where(system='phone')",
      "base": [
        "OrganizationAffiliation"
      ],
      "type": "token",
      "description": "A value in a phone contact"
    },
    {
      "name": "phone",
      "expression": "Patient.telecom.where(system='phone') | Person.telecom.where(system='phone') | Practitioner.telecom.where(system='phone') | PractitionerRole.contact.telecom.where(system='phone') | RelatedPerson.telecom.where(system='phone')",
      "base": [
        "Patient",
        "Person",
        "Practitioner",
        "PractitionerRole",
        "RelatedPerson"
      ],
      "type": "token",
      "description": "Multiple Resources: \r\n\r\n* [Patient](patient.html): A value in a phone contact\r\n* [Person](person.html): A value in a phone contact\r\n* [Practitioner](practitioner.html): A value in a phone contact\r\n* [PractitionerRole](practitionerrole.html): A value in a phone contact\r\n* [RelatedPerson](relatedperson.html): A value in a phone contact\r\n"
    },
    {
      "name": "phonetic",
      "expression": "InsuranceProduct.name",
      "base": [
        "Resource"
      ],
      "type": "string",
      "description": "A portion of the product's name using some kind of phonetic matching algorithm"
    },
    {
      "name": "phonetic",
      "expression": "Organization.name",
      "base": [
        "Organization"
      ],
      "type": "string",
      "description": "A portion of the organization's name using some kind of phonetic matching algorithm"
    },
    {
      "name": "phonetic",
      "expression": "Patient.name | Person.name | Practitioner.name | RelatedPerson.name",
      "base": [
        "Patient",
        "Person",
        "Practitioner",
        "RelatedPerson"
      ],
      "type": "string",
      "description": "Multiple Resources: \r\n\r\n* [Patient](patient.html): A portion of either family or given name using some kind of phonetic matching algorithm\r\n* [Person](person.html): A portion of name using some kind of phonetic matching algorithm\r\n* [Practitioner](practitioner.html): A portion of either family or given name using some kind of phonetic matching algorithm\r\n* [RelatedPerson](relatedperson.html): A portion of name using some kind of phonetic matching algorithm\r\n"
    },
    {
      "name": "policy",
      "expression": "AuditEvent.agent.policy",
      "base": [
        "AuditEvent"
      ],
      "type": "uri",
      "description": "Policy that authorized event"
    },
    {
      "name": "policy-holder",
      "expression": "Coverage.policyHolder",
      "base": [
        "Coverage"
      ],
      "type": "reference",
      "description": "Reference to the policyholder"
    },
    {
      "name": "practitioner",
      "expression": "Appointment.participant.actor.where(resolve() is Practitioner)",
      "base": [
        "Appointment"
      ],
      "type": "reference",
      "description": "One of the individuals of the appointment is this practitioner"
    },
    {
      "name": "practitioner",
      "expression": "AppointmentResponse.actor.where(resolve() is Practitioner)",
      "base": [
        "AppointmentResponse"
      ],
      "type": "reference",
      "description": "This Response is for this Practitioner"
    },
    {
      "name": "practitioner",
      "expression": "Encounter.participant.actor.where(resolve() is Practitioner)",
      "base": [
        "Encounter"
      ],
      "type": "reference",
      "description": "Persons involved in the encounter other than the patient"
    },
    {
      "name": "practitioner",
      "expression": "Person.link.target.where(resolve() is Practitioner)",
      "base": [
        "Person"
      ],
      "type": "reference",
      "description": "The Person links to this Practitioner"
    },
    {
      "name": "practitioner",
      "expression": "PractitionerRole.practitioner",
      "base": [
        "PractitionerRole"
      ],
      "type": "reference",
      "description": "Practitioner that is able to provide the defined services for the organization"
    },
    {
      "name": "predecessor",
      "expression": "ActivityDefinition.relatedArtifact.where(type='predecessor').resource | CodeSystem.relatedArtifact.where(type='predecessor').resource | ConceptMap.relatedArtifact.where(type='predecessor').resource | EventDefinition.relatedArtifact.where(type='predecessor').resource | Library.relatedArtifact.where(type='predecessor').resource | Measure.relatedArtifact.where(type='predecessor').resource | NamingSystem.relatedArtifact.where(type='predecessor').resource | PlanDefinition.relatedArtifact.where(type='predecessor').resource | ValueSet.relatedArtifact.where(type='predecessor').resource",
      "base": [
        "ActivityDefinition",
        "CodeSystem",
        "ConceptMap",
        "EventDefinition",
        "Library",
        "Measure",
        "NamingSystem",
        "PlanDefinition",
        "ValueSet"
      ],
      "type": "reference",
      "description": "Multiple Resources: \r\n\r\n* [ActivityDefinition](activitydefinition.html): What resource is being referenced\r\n* [CodeSystem](codesystem.html): The predecessor of the CodeSystem\r\n* [ConceptMap](conceptmap.html): The predecessor of the ConceptMap\r\n* [EventDefinition](eventdefinition.html): What resource is being referenced\r\n* [Library](library.html): What resource is being referenced\r\n* [Measure](measure.html): What resource is being referenced\r\n* [NamingSystem](namingsystem.html): The predecessor of the NamingSystem\r\n* [PlanDefinition](plandefinition.html): What resource is being referenced\r\n* [ValueSet](valueset.html): The predecessor of the ValueSet\r\n"
    },
    {
      "name": "prescriber",
      "expression": "VisionPrescription.prescriber",
      "base": [
        "VisionPrescription"
      ],
      "type": "reference",
      "description": "Who authorized the vision prescription"
    },
    {
      "name": "prescription",
      "expression": "MedicationDispense.authorizingPrescription",
      "base": [
        "MedicationDispense"
      ],
      "type": "reference",
      "description": "Multiple Resources: \r\n\r\n* [MedicationDispense](medicationdispense.html): The identity of a prescription to list dispenses from\r\n"
    },
    {
      "name": "presence",
      "expression": "DeviceAlert.condition.presence",
      "base": [
        "Resource"
      ],
      "type": "token",
      "description": "Whether the alert condition is currently occuring"
    },
    {
      "name": "previous",
      "expression": "ClinicalAssessment.previous",
      "base": [
        "Resource"
      ],
      "type": "reference",
      "description": "Reference to last assessment"
    },
    {
      "name": "primary-organization",
      "expression": "OrganizationAffiliation.organization",
      "base": [
        "OrganizationAffiliation"
      ],
      "type": "reference",
      "description": "The organization that receives the services from the participating organization"
    },
    {
      "name": "primarysource-type",
      "expression": "VerificationResult.primarySource.type",
      "base": [
        "VerificationResult"
      ],
      "type": "token",
      "description": "Select validation information for data that was validated against the specified type of primary source organization"
    },
    {
      "name": "primarysource-who",
      "expression": "VerificationResult.primarySource.who",
      "base": [
        "VerificationResult"
      ],
      "type": "reference",
      "description": "Select validation information for data that was validated against the specified primary source"
    },
    {
      "name": "prior-request",
      "expression": "DeviceRequest.replaces",
      "base": [
        "DeviceRequest"
      ],
      "type": "reference",
      "description": "Request takes the place of referenced completed or terminated requests"
    },
    {
      "name": "priority",
      "expression": "Claim.priority",
      "base": [
        "Claim"
      ],
      "type": "token",
      "description": "Processing priority requested"
    },
    {
      "name": "priority",
      "expression": "CommunicationRequest.priority",
      "base": [
        "CommunicationRequest"
      ],
      "type": "token",
      "description": "routine | urgent | asap | stat"
    },
    {
      "name": "priority",
      "expression": "DeviceAlert.priority",
      "base": [
        "Resource"
      ],
      "type": "token",
      "description": "Priority of the alert condition"
    },
    {
      "name": "priority",
      "expression": "MedicationRequest.priority",
      "base": [
        "MedicationRequest"
      ],
      "type": "token",
      "description": "Returns prescriptions with different priorities"
    },
    {
      "name": "priority",
      "expression": "RequestOrchestration.priority",
      "base": [
        "RequestOrchestration"
      ],
      "type": "token",
      "description": "The priority of the request orchestration"
    },
    {
      "name": "priority",
      "expression": "ServiceRequest.priority",
      "base": [
        "ServiceRequest"
      ],
      "type": "token",
      "description": "routine | urgent | asap | stat"
    },
    {
      "name": "priority",
      "expression": "Task.priority",
      "base": [
        "Task"
      ],
      "type": "token",
      "description": "Search by task priority"
    },
    {
      "name": "probability",
      "expression": "RiskAssessment.prediction.probability.ofType(decimal)",
      "base": [
        "RiskAssessment"
      ],
      "type": "number",
      "description": "Likelihood of specified outcome"
    },
    {
      "name": "problem",
      "expression": "ClinicalAssessment.problem",
      "base": [
        "Resource"
      ],
      "type": "reference",
      "description": "Relevant impressions of patient state"
    },
    {
      "name": "procedure",
      "expression": "DiagnosticReport.procedure",
      "base": [
        "DiagnosticReport"
      ],
      "type": "reference",
      "description": "The procedure(s) from which the report was produced."
    },
    {
      "name": "procedure",
      "expression": "Specimen.collection.procedure",
      "base": [
        "Specimen"
      ],
      "type": "reference",
      "description": "The procedure that collected the specimen"
    },
    {
      "name": "procedure-udi",
      "expression": "Claim.procedure.udi",
      "base": [
        "Claim"
      ],
      "type": "reference",
      "description": "UDI associated with a procedure"
    },
    {
      "name": "procedure-udi",
      "expression": "ExplanationOfBenefit.procedure.udi",
      "base": [
        "ExplanationOfBenefit"
      ],
      "type": "reference",
      "description": "UDI associated with a procedure"
    },
    {
      "name": "product",
      "expression": "BiologicallyDerivedProductDispense.product",
      "base": [
        "BiologicallyDerivedProductDispense"
      ],
      "type": "reference",
      "description": "Search for products that match this code"
    },
    {
      "name": "product",
      "expression": "ClinicalUseDefinition.subject.where(resolve() is MedicinalProductDefinition)",
      "base": [
        "ClinicalUseDefinition"
      ],
      "type": "reference",
      "description": "The medicinal product for which this is a clinical usage issue"
    },
    {
      "name": "product",
      "expression": "InsurancePlan.product",
      "base": [
        "InsurancePlan"
      ],
      "type": "reference",
      "description": "The product this plan is available to"
    },
    {
      "name": "product-category",
      "expression": "BiologicallyDerivedProduct.productCategory",
      "base": [
        "BiologicallyDerivedProduct"
      ],
      "type": "token",
      "description": "Broad category of this product."
    },
    {
      "name": "product-classification",
      "expression": "MedicinalProductDefinition.classification",
      "base": [
        "MedicinalProductDefinition"
      ],
      "type": "token",
      "description": "Allows the product to be classified by various systems"
    },
    {
      "name": "product-status",
      "expression": "BiologicallyDerivedProduct.productStatus",
      "base": [
        "BiologicallyDerivedProduct"
      ],
      "type": "token",
      "description": "Whether the product is currently available."
    },
    {
      "name": "product-type",
      "expression": "MedicationKnowledge.productType",
      "base": [
        "MedicationKnowledge"
      ],
      "type": "token",
      "description": "Category of the medication or product"
    },
    {
      "name": "program",
      "expression": "HealthcareService.program",
      "base": [
        "HealthcareService"
      ],
      "type": "token",
      "description": "One of the Programs supported by this HealthcareService"
    },
    {
      "name": "progress-actual",
      "expression": "ResearchStudy.progressStatus.actual",
      "base": [
        "ResearchStudy"
      ],
      "type": "token",
      "description": "Actual if true else anticipated"
    },
    {
      "name": "progress-period",
      "expression": "ResearchStudy.progressStatus.period",
      "base": [
        "ResearchStudy"
      ],
      "type": "date",
      "description": "Date range"
    },
    {
      "name": "progress-status-state-actual",
      "expression": "ResearchStudy.progressStatus",
      "base": [
        "ResearchStudy"
      ],
      "type": "composite",
      "description": "Status of study by state and actual"
    },
    {
      "name": "progress-status-state-period",
      "expression": "ResearchStudy.progressStatus",
      "base": [
        "ResearchStudy"
      ],
      "type": "composite",
      "description": "Status of study by state and period"
    },
    {
      "name": "progress-status-state-period-actual",
      "expression": "ResearchStudy.progressStatus",
      "base": [
        "ResearchStudy"
      ],
      "type": "composite",
      "description": "Status of study by state, period and actual"
    },
    {
      "name": "protocol",
      "expression": "ResearchStudy.protocol",
      "base": [
        "ResearchStudy"
      ],
      "type": "reference",
      "description": "Steps followed in executing study"
    },
    {
      "name": "provider",
      "expression": "Claim.provider",
      "base": [
        "Claim"
      ],
      "type": "reference",
      "description": "Provider responsible for the Claim"
    },
    {
      "name": "provider",
      "expression": "CoverageEligibilityRequest.provider",
      "base": [
        "CoverageEligibilityRequest"
      ],
      "type": "reference",
      "description": "The reference to the provider"
    },
    {
      "name": "provider",
      "expression": "ExplanationOfBenefit.provider",
      "base": [
        "ExplanationOfBenefit"
      ],
      "type": "reference",
      "description": "The reference to the provider"
    },
    {
      "name": "purpose",
      "expression": "AuditEvent.authorization | AuditEvent.agent.authorization",
      "base": [
        "AuditEvent"
      ],
      "type": "token",
      "description": "The authorization (purposeOfUse) of the event"
    },
    {
      "name": "purpose",
      "expression": "Consent.provision.purpose",
      "base": [
        "Consent"
      ],
      "type": "token",
      "description": "Context of activities covered by this rule"
    },
    {
      "name": "qual-code-period",
      "expression": "Practitioner.qualification",
      "base": [
        "Practitioner"
      ],
      "type": "composite",
      "description": "The practitioner has a qualification during a specific period"
    },
    {
      "name": "qualification-code",
      "expression": "Practitioner.qualification.code",
      "base": [
        "Practitioner"
      ],
      "type": "token",
      "description": "The type of qualification"
    },
    {
      "name": "qualification-period",
      "expression": "Practitioner.qualification.period",
      "base": [
        "Practitioner"
      ],
      "type": "date",
      "description": "The date(s) a qualification is valid for"
    },
    {
      "name": "quantity",
      "expression": "ChargeItem.quantity",
      "base": [
        "ChargeItem"
      ],
      "type": "quantity",
      "description": "Quantity of which the charge item has been serviced"
    },
    {
      "name": "quantity",
      "expression": "Substance.quantity",
      "base": [
        "Substance"
      ],
      "type": "quantity",
      "description": "Amount of substance in the package"
    },
    {
      "name": "questionnaire",
      "expression": "QuestionnaireResponse.questionnaire",
      "base": [
        "QuestionnaireResponse"
      ],
      "type": "reference",
      "description": "The questionnaire the answers are provided for"
    },
    {
      "name": "questionnaire-code",
      "expression": "Questionnaire.code",
      "base": [
        "Questionnaire"
      ],
      "type": "token",
      "description": "A code that matches one of the Questionnaire.code codings"
    },
    {
      "name": "reaction",
      "expression": "Immunization.reaction.manifestation.reference",
      "base": [
        "Immunization"
      ],
      "type": "reference",
      "description": "Additional information on reaction"
    },
    {
      "name": "reaction-date",
      "expression": "Immunization.reaction.date",
      "base": [
        "Immunization"
      ],
      "type": "date",
      "description": "When reaction started"
    },
    {
      "name": "reason-code",
      "expression": "Appointment.reason.concept",
      "base": [
        "Appointment"
      ],
      "type": "token",
      "description": "Reference to a concept (by class)"
    },
    {
      "name": "reason-code",
      "expression": "EpisodeOfCare.reason.value.concept",
      "base": [
        "EpisodeOfCare"
      ],
      "type": "token",
      "description": "Reference to a concept (coded)"
    },
    {
      "name": "reason-code",
      "expression": "Immunization.reason.concept",
      "base": [
        "Immunization"
      ],
      "type": "token",
      "description": "Reason why the vaccine was administered"
    },
    {
      "name": "reason-code",
      "expression": "Procedure.reason.concept",
      "base": [
        "Procedure"
      ],
      "type": "token",
      "description": "Reference to a concept (by class)"
    },
    {
      "name": "reason-given",
      "expression": "MedicationAdministration.reason.reference",
      "base": [
        "MedicationAdministration"
      ],
      "type": "reference",
      "description": "Reference to a resource (by instance)"
    },
    {
      "name": "reason-given-code",
      "expression": "MedicationAdministration.reason.concept",
      "base": [
        "MedicationAdministration"
      ],
      "type": "token",
      "description": "Reasons for administering the medication"
    },
    {
      "name": "reason-not-given",
      "expression": "MedicationAdministration.statusReason",
      "base": [
        "MedicationAdministration"
      ],
      "type": "token",
      "description": "Reasons for not administering the medication"
    },
    {
      "name": "reason-reference",
      "expression": "Appointment.reason.reference",
      "base": [
        "Appointment"
      ],
      "type": "reference",
      "description": "Reference to a resource (by instance)"
    },
    {
      "name": "reason-reference",
      "expression": "Communication.reason.reference",
      "base": [
        "Communication"
      ],
      "type": "reference",
      "description": "Indication for the message"
    },
    {
      "name": "reason-reference",
      "expression": "Encounter.reason.value.reference",
      "base": [
        "Encounter"
      ],
      "type": "reference",
      "description": "Reference to a resource (resource reference)"
    },
    {
      "name": "reason-reference",
      "expression": "EpisodeOfCare.reason.value.reference",
      "base": [
        "EpisodeOfCare"
      ],
      "type": "reference",
      "description": "Reference to a resource (resource reference)"
    },
    {
      "name": "reason-reference",
      "expression": "ImagingStudy.reason.reference",
      "base": [
        "ImagingStudy"
      ],
      "type": "reference",
      "description": "The resource reference describing the reason for the study"
    },
    {
      "name": "reason-reference",
      "expression": "Procedure.reason.reference",
      "base": [
        "Procedure"
      ],
      "type": "reference",
      "description": "Reference to a resource (by instance)"
    },
    {
      "name": "received",
      "expression": "Communication.received",
      "base": [
        "Communication"
      ],
      "type": "date",
      "description": "When received"
    },
    {
      "name": "receiver",
      "expression": "MedicationDispense.receiver",
      "base": [
        "MedicationDispense"
      ],
      "type": "reference",
      "description": "The identity of a receiver to list dispenses for"
    },
    {
      "name": "receiver",
      "expression": "MessageHeader.destination.receiver",
      "base": [
        "MessageHeader"
      ],
      "type": "reference",
      "description": "Intended \"real-world\" recipient for the data"
    },
    {
      "name": "receiver",
      "expression": "SupplyDelivery.receiver",
      "base": [
        "SupplyDelivery"
      ],
      "type": "reference",
      "description": "Who collected the Supply"
    },
    {
      "name": "recipient",
      "expression": "Communication.recipient",
      "base": [
        "Communication"
      ],
      "type": "reference",
      "description": "Who the information is shared with"
    },
    {
      "name": "recipient",
      "expression": "CommunicationRequest.recipient",
      "base": [
        "CommunicationRequest"
      ],
      "type": "reference",
      "description": "Who to share the information with"
    },
    {
      "name": "recipient",
      "expression": "Invoice.recipient",
      "base": [
        "Invoice"
      ],
      "type": "reference",
      "description": "Recipient of this invoice"
    },
    {
      "name": "recorded",
      "expression": "MedicationDispense.recorded",
      "base": [
        "MedicationDispense"
      ],
      "type": "date",
      "description": "Returns dispenses where dispensing activity began on this date"
    },
    {
      "name": "recorded",
      "expression": "Provenance.recorded",
      "base": [
        "Provenance"
      ],
      "type": "date",
      "description": "When the activity was recorded / updated"
    },
    {
      "name": "recorded-date",
      "expression": "Condition.recordedDate",
      "base": [
        "Condition"
      ],
      "type": "date",
      "description": "Date record was first recorded"
    },
    {
      "name": "recorder",
      "expression": "AdverseEvent.recorder",
      "base": [
        "AdverseEvent"
      ],
      "type": "reference",
      "description": "Who recorded the adverse event"
    },
    {
      "name": "recruitment-actual",
      "expression": "ResearchStudy.recruitment.actualNumber",
      "base": [
        "ResearchStudy"
      ],
      "type": "number",
      "description": "Actual number of participants enrolled in study across all groups"
    },
    {
      "name": "recruitment-target",
      "expression": "ResearchStudy.recruitment.targetNumber",
      "base": [
        "ResearchStudy"
      ],
      "type": "number",
      "description": "Target number of participants enrolled in study across all groups"
    },
    {
      "name": "reference",
      "expression": "ValueSet.compose.include.system",
      "base": [
        "ValueSet"
      ],
      "type": "uri",
      "description": "A code system included or excluded in the value set or an imported value set"
    },
    {
      "name": "referrer",
      "expression": "ImagingStudy.referrer",
      "base": [
        "ImagingStudy"
      ],
      "type": "reference",
      "description": "The referring physician"
    },
    {
      "name": "region",
      "expression": "ResearchStudy.region",
      "base": [
        "ResearchStudy"
      ],
      "type": "token",
      "description": "Geographic area for the study"
    },
    {
      "name": "relatedperson",
      "expression": "Person.link.target.where(resolve() is RelatedPerson)",
      "base": [
        "Person"
      ],
      "type": "reference",
      "description": "The Person links to this RelatedPerson"
    },
    {
      "name": "relatesto",
      "expression": "DocumentReference.relatesTo.target",
      "base": [
        "DocumentReference"
      ],
      "type": "reference",
      "description": "Target of the relationship"
    },
    {
      "name": "relation",
      "expression": "DocumentReference.relatesTo.code",
      "base": [
        "DocumentReference"
      ],
      "type": "token",
      "description": "replaces | transforms | signs | appends"
    },
    {
      "name": "relationship",
      "expression": "DeviceAssociation.relationship",
      "base": [
        "DeviceAssociation"
      ],
      "type": "token",
      "description": "Search for specific device association relationships"
    },
    {
      "name": "relationship",
      "expression": "DocumentReference.relatesTo",
      "base": [
        "DocumentReference"
      ],
      "type": "composite",
      "description": "Combination of relation and relatesTo"
    },
    {
      "name": "relationship",
      "expression": "FamilyMemberHistory.relationship",
      "base": [
        "FamilyMemberHistory"
      ],
      "type": "token",
      "description": "A search by a relationship type"
    },
    {
      "name": "relationship",
      "expression": "PersonalRelationship.relationshipType",
      "base": [
        "Resource"
      ],
      "type": "token",
      "description": "The personal relationship between the patient and the PersonalRelationship"
    },
    {
      "name": "relationship",
      "expression": "RelatedPerson.relationship",
      "base": [
        "RelatedPerson"
      ],
      "type": "token",
      "description": "The personal relationship between the patient and the relatedperson"
    },
    {
      "name": "replaces",
      "expression": "CarePlan.replaces",
      "base": [
        "CarePlan"
      ],
      "type": "reference",
      "description": "CarePlan replaced by this CarePlan"
    },
    {
      "name": "replaces",
      "expression": "CommunicationRequest.replaces",
      "base": [
        "CommunicationRequest"
      ],
      "type": "reference",
      "description": "Request(s) replaced by this request"
    },
    {
      "name": "replaces",
      "expression": "ServiceRequest.replaces",
      "base": [
        "ServiceRequest"
      ],
      "type": "reference",
      "description": "What request replaces"
    },
    {
      "name": "report",
      "expression": "Procedure.report",
      "base": [
        "Procedure"
      ],
      "type": "reference",
      "description": "Any report resulting from the procedure"
    },
    {
      "name": "reporter",
      "expression": "MeasureReport.reporter",
      "base": [
        "MeasureReport"
      ],
      "type": "reference",
      "description": "The reporter to return measure report results for"
    },
    {
      "name": "reporter",
      "expression": "PaymentNotice.reporter",
      "base": [
        "PaymentNotice"
      ],
      "type": "reference",
      "description": "The reference to the reporter"
    },
    {
      "name": "request",
      "expression": "BiologicallyDerivedProduct.request",
      "base": [
        "BiologicallyDerivedProduct"
      ],
      "type": "reference",
      "description": "Procedure request to obtain this biologically derived product."
    },
    {
      "name": "request",
      "expression": "ClaimResponse.request",
      "base": [
        "ClaimResponse"
      ],
      "type": "reference",
      "description": "The claim reference"
    },
    {
      "name": "request",
      "expression": "CoverageEligibilityResponse.request",
      "base": [
        "CoverageEligibilityResponse"
      ],
      "type": "reference",
      "description": "The EligibilityRequest reference"
    },
    {
      "name": "request",
      "expression": "EnrollmentResponse.request",
      "base": [
        "EnrollmentResponse"
      ],
      "type": "reference",
      "description": "The reference to the claim"
    },
    {
      "name": "request",
      "expression": "GuidanceResponse.requestIdentifier",
      "base": [
        "GuidanceResponse"
      ],
      "type": "token",
      "description": "The identifier of the request associated with the response"
    },
    {
      "name": "request",
      "expression": "MedicationAdministration.request",
      "base": [
        "MedicationAdministration"
      ],
      "type": "reference",
      "description": "The identity of a request to list administrations from"
    },
    {
      "name": "request",
      "expression": "PaymentReconciliation.request",
      "base": [
        "PaymentReconciliation"
      ],
      "type": "reference",
      "description": "The reference to the claim"
    },
    {
      "name": "request",
      "expression": "Specimen.request",
      "base": [
        "Specimen"
      ],
      "type": "reference",
      "description": "The request/order associated with the specimen"
    },
    {
      "name": "requested-period",
      "expression": "requestedPeriod",
      "base": [
        "Appointment"
      ],
      "type": "date",
      "description": "During what period was the Appointment requested to take place"
    },
    {
      "name": "requestedperformer-reference",
      "expression": "Task.requestedPerformer.reference",
      "base": [
        "Task"
      ],
      "type": "reference",
      "description": "Search by specific requested performer."
    },
    {
      "name": "requester",
      "expression": "CommunicationRequest.requester",
      "base": [
        "CommunicationRequest"
      ],
      "type": "reference",
      "description": "Who asks for the information to be shared"
    },
    {
      "name": "requester",
      "expression": "DeviceRequest.requester",
      "base": [
        "DeviceRequest"
      ],
      "type": "reference",
      "description": "Who/what is requesting service"
    },
    {
      "name": "requester",
      "expression": "MedicationRequest.requester",
      "base": [
        "MedicationRequest"
      ],
      "type": "reference",
      "description": "Returns prescriptions prescribed by this prescriber"
    },
    {
      "name": "requester",
      "expression": "NutritionOrder.requester",
      "base": [
        "NutritionOrder"
      ],
      "type": "reference",
      "description": "The identity of the provider who placed the nutrition order"
    },
    {
      "name": "requester",
      "expression": "ServiceRequest.requester",
      "base": [
        "ServiceRequest"
      ],
      "type": "reference",
      "description": "Who/what is requesting service"
    },
    {
      "name": "requester",
      "expression": "SupplyRequest.requester",
      "base": [
        "SupplyRequest"
      ],
      "type": "reference",
      "description": "Individual making the request"
    },
    {
      "name": "requester",
      "expression": "Task.requester",
      "base": [
        "Task"
      ],
      "type": "reference",
      "description": "Search by task requester"
    },
    {
      "name": "requesting-organization",
      "expression": "ChargeItem.requestingOrganization",
      "base": [
        "ChargeItem"
      ],
      "type": "reference",
      "description": "Organization requesting the charged service"
    },
    {
      "name": "requestor",
      "expression": "CoverageEligibilityResponse.requestor",
      "base": [
        "CoverageEligibilityResponse"
      ],
      "type": "reference",
      "description": "The EligibilityRequest provider"
    },
    {
      "name": "requestor",
      "expression": "PaymentReconciliation.requestor",
      "base": [
        "PaymentReconciliation"
      ],
      "type": "reference",
      "description": "The reference to the provider who submitted the claim"
    },
    {
      "name": "requirement",
      "expression": "TestPlan.testCase.requirement.reference",
      "base": [
        "TestPlan"
      ],
      "type": "uri",
      "description": "Canonical reference to a requirement this TestPlan supports"
    },
    {
      "name": "requirement-key",
      "expression": "TestPlan.testCase.requirement",
      "base": [
        "TestPlan"
      ],
      "type": "composite",
      "description": "Canonical reference to a requirement and statement (key) this TestPlan supports"
    },
    {
      "name": "requisition",
      "expression": "ServiceRequest.requisition",
      "base": [
        "ServiceRequest"
      ],
      "type": "token",
      "description": "Composite Request ID"
    },
    {
      "name": "resource",
      "expression": "CompartmentDefinition.resource.code",
      "base": [
        "CompartmentDefinition"
      ],
      "type": "token",
      "description": "Name of resource type"
    },
    {
      "name": "resource",
      "expression": "ImplementationGuide.definition.resource.reference",
      "base": [
        "ImplementationGuide"
      ],
      "type": "reference",
      "description": "Location of the resource"
    },
    {
      "name": "resource",
      "expression": "SubscriptionTopic.trigger.resource",
      "base": [
        "SubscriptionTopic"
      ],
      "type": "uri",
      "description": "Allowed resource for this definition"
    },
    {
      "name": "resource-profile",
      "expression": "CapabilityStatement.rest.resource.profile",
      "base": [
        "CapabilityStatement"
      ],
      "type": "reference",
      "description": "A profile id invoked in a capability statement"
    },
    {
      "name": "response",
      "expression": "PaymentNotice.response",
      "base": [
        "PaymentNotice"
      ],
      "type": "reference",
      "description": "The ClaimResponse"
    },
    {
      "name": "response-id",
      "expression": "MessageHeader.response.identifier",
      "base": [
        "MessageHeader"
      ],
      "type": "token",
      "description": "Id of original message"
    },
    {
      "name": "responsible",
      "expression": "NamingSystem.responsible",
      "base": [
        "NamingSystem"
      ],
      "type": "string",
      "description": "Who maintains system namespace?"
    },
    {
      "name": "responsibleparty",
      "expression": "MedicationDispense.substitution.responsibleParty",
      "base": [
        "MedicationDispense"
      ],
      "type": "reference",
      "description": "Returns dispenses with the specified responsible party"
    },
    {
      "name": "result",
      "expression": "DiagnosticReport.result",
      "base": [
        "DiagnosticReport"
      ],
      "type": "reference",
      "description": "Link to an atomic result (observation resource)"
    },
    {
      "name": "result",
      "expression": "TestReport.result",
      "base": [
        "TestReport"
      ],
      "type": "token",
      "description": "The result disposition of the test execution"
    },
    {
      "name": "resultingeffect-code",
      "expression": "AdverseEvent.resultingEffect.concept",
      "base": [
        "AdverseEvent"
      ],
      "type": "token",
      "description": "Effect on the subject due to this event"
    },
    {
      "name": "resultingeffect-reference",
      "expression": "AdverseEvent.resultingEffect.reference",
      "base": [
        "AdverseEvent"
      ],
      "type": "reference",
      "description": "Effect on the subject due to this event"
    },
    {
      "name": "results-interpreter",
      "expression": "DiagnosticReport.resultsInterpreter",
      "base": [
        "DiagnosticReport"
      ],
      "type": "reference",
      "description": "Who was the source of the report"
    },
    {
      "name": "risk",
      "expression": "RiskAssessment.prediction.qualitativeRisk",
      "base": [
        "RiskAssessment"
      ],
      "type": "token",
      "description": "Likelihood of specified outcome as a qualitative value"
    },
    {
      "name": "role",
      "expression": "Ingredient.role",
      "base": [
        "Ingredient"
      ],
      "type": "token",
      "description": "A classification of the ingredient identifying its purpose within the product, e.g. active, inactive"
    },
    {
      "name": "role",
      "expression": "OrganizationAffiliation.code",
      "base": [
        "OrganizationAffiliation"
      ],
      "type": "token",
      "description": "Definition of the role the participatingOrganization plays"
    },
    {
      "name": "role",
      "expression": "RelatedPerson.relationship",
      "base": [
        "RelatedPerson"
      ],
      "type": "token",
      "description": "The functional relationship between the patient and the relatedperson"
    },
    {
      "name": "route",
      "expression": "AdministrableProductDefinition.routeOfAdministration.code",
      "base": [
        "AdministrableProductDefinition"
      ],
      "type": "token",
      "description": "Coded expression for the route"
    },
    {
      "name": "schedule",
      "expression": "Slot.schedule",
      "base": [
        "Slot"
      ],
      "type": "reference",
      "description": "The Schedule Resource that we are seeking a slot within"
    },
    {
      "name": "scope-artifact-conformance",
      "expression": "TestScript.scope",
      "base": [
        "TestScript"
      ],
      "type": "composite",
      "description": "The artifact under test and conformance testing expectation"
    },
    {
      "name": "scope-artifact-phase",
      "expression": "TestScript.scope",
      "base": [
        "TestScript"
      ],
      "type": "composite",
      "description": "The artifact under test and phase of testing"
    },
    {
      "name": "scope-canonical",
      "expression": "TestPlan.scope.artifact.ofType(canonical)",
      "base": [
        "TestPlan"
      ],
      "type": "uri",
      "description": "URL contained in TestPlan.scope.artifactCanonical"
    },
    {
      "name": "scope-uri",
      "expression": "TestPlan.scope.artifact.ofType(uri)",
      "base": [
        "TestPlan"
      ],
      "type": "uri",
      "description": "URL contained in TestPlan.scope.artifactUri"
    },
    {
      "name": "section-code-text",
      "expression": "Composition.section",
      "base": [
        "Composition"
      ],
      "type": "composite",
      "description": "Search on the section narrative of the resource"
    },
    {
      "name": "section-text",
      "expression": "Composition.section.text | Composition.section.section.text",
      "base": [
        "Composition"
      ],
      "type": "special",
      "description": "Search on the section narrative of the resource"
    },
    {
      "name": "security-label",
      "expression": "Consent.provision.securityLabel",
      "base": [
        "Consent"
      ],
      "type": "token",
      "description": "Security Labels that define affected resources"
    },
    {
      "name": "security-label",
      "expression": "DocumentReference.securityLabel",
      "base": [
        "DocumentReference"
      ],
      "type": "token",
      "description": "Document security-tags"
    },
    {
      "name": "security-service",
      "expression": "CapabilityStatement.rest.security.service",
      "base": [
        "CapabilityStatement"
      ],
      "type": "token",
      "description": "OAuth | SMART-on-FHIR | NTLM | Basic | Kerberos | Certificates"
    },
    {
      "name": "sender",
      "expression": "Communication.sender",
      "base": [
        "Communication"
      ],
      "type": "reference",
      "description": "Who shares the information"
    },
    {
      "name": "sender",
      "expression": "MessageHeader.source.sender",
      "base": [
        "MessageHeader"
      ],
      "type": "reference",
      "description": "Real world sender of the message"
    },
    {
      "name": "sent",
      "expression": "Communication.sent",
      "base": [
        "Communication"
      ],
      "type": "date",
      "description": "When sent"
    },
    {
      "name": "serial-number",
      "expression": "BiologicallyDerivedProduct.identifier",
      "base": [
        "BiologicallyDerivedProduct"
      ],
      "type": "token",
      "description": "Identifier"
    },
    {
      "name": "serial-number",
      "expression": "Device.serialNumber | Device.identifier.where(type='SNO')",
      "base": [
        "Device"
      ],
      "type": "string",
      "description": "The serial number of the device"
    },
    {
      "name": "serial-number",
      "expression": "Medication.identifier",
      "base": [
        "Medication"
      ],
      "type": "token",
      "description": "Returns medications in a batch with this lot number"
    },
    {
      "name": "serial-number",
      "expression": "NutritionProduct.instance.identifier",
      "base": [
        "NutritionProduct"
      ],
      "type": "token",
      "description": "The serial number"
    },
    {
      "name": "series",
      "expression": "ImagingStudy.series.uid",
      "base": [
        "ImagingStudy"
      ],
      "type": "token",
      "description": "DICOM Series Instance UID for a series"
    },
    {
      "name": "series",
      "expression": "Immunization.protocolApplied.series",
      "base": [
        "Immunization"
      ],
      "type": "string",
      "description": "The series being followed by the provider"
    },
    {
      "name": "seriousness",
      "expression": "AdverseEvent.seriousness",
      "base": [
        "AdverseEvent"
      ],
      "type": "token",
      "description": "Seriousness or gravity of the event"
    },
    {
      "name": "service",
      "expression": "ChargeItem.service.reference",
      "base": [
        "ChargeItem"
      ],
      "type": "reference",
      "description": "Which rendered service is being charged?"
    },
    {
      "name": "service",
      "expression": "OrganizationAffiliation.healthcareService",
      "base": [
        "OrganizationAffiliation"
      ],
      "type": "reference",
      "description": "Healthcare services provided through the role"
    },
    {
      "name": "service",
      "expression": "PractitionerRole.healthcareService",
      "base": [
        "PractitionerRole"
      ],
      "type": "reference",
      "description": "The list of healthcare services that this worker provides for this role's Organization/Location(s)"
    },
    {
      "name": "service-category",
      "expression": "Appointment.serviceCategory",
      "base": [
        "Appointment"
      ],
      "type": "token",
      "description": "A broad categorization of the service that is to be performed during this appointment"
    },
    {
      "name": "service-category",
      "expression": "HealthcareService.category",
      "base": [
        "HealthcareService"
      ],
      "type": "token",
      "description": "Service Category of the Healthcare Service"
    },
    {
      "name": "service-category",
      "expression": "Schedule.serviceCategory",
      "base": [
        "Schedule"
      ],
      "type": "token",
      "description": "High-level category"
    },
    {
      "name": "service-category",
      "expression": "Slot.serviceCategory",
      "base": [
        "Slot"
      ],
      "type": "token",
      "description": "A broad categorization of the service that is to be performed during this appointment"
    },
    {
      "name": "service-provider",
      "expression": "Encounter.serviceProvider",
      "base": [
        "Encounter"
      ],
      "type": "reference",
      "description": "The organization (facility) responsible for this encounter"
    },
    {
      "name": "service-type",
      "expression": "Appointment.serviceType.concept",
      "base": [
        "Appointment"
      ],
      "type": "token",
      "description": "The specific service (by coding) that is to be performed during this appointment"
    },
    {
      "name": "service-type",
      "expression": "HealthcareService.type",
      "base": [
        "HealthcareService"
      ],
      "type": "token",
      "description": "The type of service provided by this healthcare service"
    },
    {
      "name": "service-type",
      "expression": "Slot.serviceType.concept",
      "base": [
        "Slot"
      ],
      "type": "token",
      "description": "The type (by coding) of appointments that can be booked into the slot"
    },
    {
      "name": "service-type-reference",
      "expression": "Appointment.serviceType.reference",
      "base": [
        "Appointment"
      ],
      "type": "reference",
      "description": "The specific service (by HealthcareService) that is to be performed during this appointment"
    },
    {
      "name": "service-type-reference",
      "expression": "Schedule.serviceType.reference",
      "base": [
        "Schedule"
      ],
      "type": "reference",
      "description": "The type (by HealthcareService) of appointments that can be booked into associated slot(s)"
    },
    {
      "name": "service-type-reference",
      "expression": "Slot.serviceType.reference",
      "base": [
        "Slot"
      ],
      "type": "reference",
      "description": "The type (by HealthcareService) of appointments that can be booked into the slot"
    },
    {
      "name": "setting",
      "expression": "DocumentReference.practiceSetting",
      "base": [
        "DocumentReference"
      ],
      "type": "token",
      "description": "Additional details about where the content was created (e.g. clinical specialty)"
    },
    {
      "name": "severity",
      "expression": "AllergyIntolerance.reaction.severity",
      "base": [
        "AllergyIntolerance"
      ],
      "type": "token",
      "description": "mild | moderate | severe (of event as a whole)"
    },
    {
      "name": "severity",
      "expression": "Condition.severity",
      "base": [
        "Condition"
      ],
      "type": "token",
      "description": "The severity of the condition"
    },
    {
      "name": "sex",
      "expression": "FamilyMemberHistory.sex",
      "base": [
        "FamilyMemberHistory"
      ],
      "type": "token",
      "description": "A search by a sex code of a family member"
    },
    {
      "name": "signal-presence",
      "expression": "DeviceAlert.signal.presence",
      "base": [
        "Resource"
      ],
      "type": "token",
      "description": "Whether the alert is currently occuring"
    },
    {
      "name": "signature-type",
      "expression": "Provenance.signature.type",
      "base": [
        "Provenance"
      ],
      "type": "token",
      "description": "Indication of the reason the entity signed the object(s)"
    },
    {
      "name": "signer",
      "expression": "Contract.signer.party",
      "base": [
        "Contract"
      ],
      "type": "reference",
      "description": "Contract Signatory Party"
    },
    {
      "name": "site",
      "expression": "ResearchStudy.site",
      "base": [
        "ResearchStudy"
      ],
      "type": "reference",
      "description": "Facility where study activities are conducted"
    },
    {
      "name": "slot",
      "expression": "Appointment.slot",
      "base": [
        "Appointment"
      ],
      "type": "reference",
      "description": "The slots that this appointment is filling"
    },
    {
      "name": "software",
      "expression": "CapabilityStatement.software.name",
      "base": [
        "CapabilityStatement"
      ],
      "type": "string",
      "description": "Part of the name of a software application"
    },
    {
      "name": "source",
      "expression": "AuditEvent.source.observer",
      "base": [
        "AuditEvent"
      ],
      "type": "reference",
      "description": "The identity of source detecting the event"
    },
    {
      "name": "source",
      "expression": "DeviceAlert.source",
      "base": [
        "Resource"
      ],
      "type": "reference",
      "description": "The device detecting the condition"
    },
    {
      "name": "source",
      "expression": "Linkage.item.resource",
      "base": [
        "Linkage"
      ],
      "type": "reference",
      "description": "Matches on any item in the Linkage with a type of 'source'"
    },
    {
      "name": "source",
      "expression": "List.source",
      "base": [
        "List"
      ],
      "type": "reference",
      "description": "Who and/or what defined the list contents (aka Author)"
    },
    {
      "name": "source",
      "expression": "MedicationStatement.informationSource",
      "base": [
        "MedicationStatement"
      ],
      "type": "reference",
      "description": "Who or where the information in the statement came from"
    },
    {
      "name": "source",
      "expression": "MessageHeader.source.name",
      "base": [
        "MessageHeader"
      ],
      "type": "string",
      "description": "Name of system"
    },
    {
      "name": "source",
      "expression": "(NutritionIntake.reported as Reference)",
      "base": [
        "NutritionIntake"
      ],
      "type": "reference",
      "description": "Who or where the information in the statement came from"
    },
    {
      "name": "source",
      "expression": "PersonalRelationship.source",
      "base": [
        "Resource"
      ],
      "type": "reference",
      "description": "The source of the relationship"
    },
    {
      "name": "source",
      "expression": "QuestionnaireResponse.source",
      "base": [
        "QuestionnaireResponse"
      ],
      "type": "reference",
      "description": "The individual providing the information reflected in the questionnaire response"
    },
    {
      "name": "source-code",
      "expression": "ConceptMap.group.element.code",
      "base": [
        "ConceptMap"
      ],
      "type": "token",
      "description": "Identifies elements being mapped"
    },
    {
      "name": "source-cost",
      "expression": "MedicationKnowledge.cost.source",
      "base": [
        "MedicationKnowledge"
      ],
      "type": "token",
      "description": "The source or owner for the price information"
    },
    {
      "name": "source-group-system",
      "expression": "ConceptMap.group.source",
      "base": [
        "ConceptMap"
      ],
      "type": "reference",
      "description": "Source system where concepts to be mapped are defined"
    },
    {
      "name": "source-reference",
      "expression": "Consent.sourceReference",
      "base": [
        "Consent"
      ],
      "type": "reference",
      "description": "Search by reference to a Consent, DocumentReference, Contract  or QuestionnaireResponse"
    },
    {
      "name": "source-scope",
      "expression": "(ConceptMap.sourceScope as canonical)",
      "base": [
        "ConceptMap"
      ],
      "type": "reference",
      "description": "The source value set that contains the concepts that are being mapped"
    },
    {
      "name": "special-arrangement",
      "expression": "Encounter.specialArrangement",
      "base": [
        "Encounter"
      ],
      "type": "token",
      "description": "Wheelchair, translator, stretcher, etc."
    },
    {
      "name": "specialty",
      "expression": "Appointment.specialty",
      "base": [
        "Appointment"
      ],
      "type": "token",
      "description": "The specialty of a practitioner that would be required to perform the service requested in this appointment"
    },
    {
      "name": "specialty",
      "expression": "HealthcareService.specialty",
      "base": [
        "HealthcareService"
      ],
      "type": "token",
      "description": "The specialty of the service provided by this healthcare service"
    },
    {
      "name": "specialty",
      "expression": "OrganizationAffiliation.specialty",
      "base": [
        "OrganizationAffiliation"
      ],
      "type": "token",
      "description": "Specific specialty of the participatingOrganization in the context of the role"
    },
    {
      "name": "specialty",
      "expression": "PractitionerRole.specialty",
      "base": [
        "PractitionerRole"
      ],
      "type": "token",
      "description": "The practitioner has this specialty at an organization"
    },
    {
      "name": "specialty",
      "expression": "Schedule.specialty",
      "base": [
        "Schedule"
      ],
      "type": "token",
      "description": "Type of specialty needed"
    },
    {
      "name": "specialty",
      "expression": "Slot.specialty",
      "base": [
        "Slot"
      ],
      "type": "token",
      "description": "The specialty of a practitioner that would be required to perform the service requested in this appointment"
    },
    {
      "name": "specification",
      "expression": "Device.conformsTo.specification",
      "base": [
        "Device"
      ],
      "type": "token",
      "description": "The standards, specifications, or formal guidances."
    },
    {
      "name": "specification",
      "expression": "DeviceDefinition.conformsTo.specification",
      "base": [
        "DeviceDefinition"
      ],
      "type": "token",
      "description": "The specification that the device conforms to"
    },
    {
      "name": "specification-version",
      "expression": "Device.conformsTo",
      "base": [
        "Device"
      ],
      "type": "composite",
      "description": "A composite of both specification and version"
    },
    {
      "name": "specification-version",
      "expression": "DeviceDefinition.conformsTo",
      "base": [
        "DeviceDefinition"
      ],
      "type": "composite",
      "description": "A composite of both specification and version"
    },
    {
      "name": "specimen",
      "expression": "DiagnosticReport.specimen",
      "base": [
        "DiagnosticReport"
      ],
      "type": "reference",
      "description": "The specimen details"
    },
    {
      "name": "specimen",
      "expression": "Observation.specimen",
      "base": [
        "Observation"
      ],
      "type": "reference",
      "description": "Specimen used for this observation"
    },
    {
      "name": "specimen",
      "expression": "ServiceRequest.specimen",
      "base": [
        "ServiceRequest"
      ],
      "type": "reference",
      "description": "Specimen to be tested"
    },
    {
      "name": "stage",
      "expression": "Condition.stage.summary",
      "base": [
        "Condition"
      ],
      "type": "token",
      "description": "Simple summary (disease specific)"
    },
    {
      "name": "start",
      "expression": "GraphDefinition.start",
      "base": [
        "GraphDefinition"
      ],
      "type": "token",
      "description": "Type of resource at which the graph starts"
    },
    {
      "name": "start",
      "expression": "Slot.start",
      "base": [
        "Slot"
      ],
      "type": "date",
      "description": "Appointment date/time."
    },
    {
      "name": "start-date",
      "expression": "(Goal.start.ofType(date))",
      "base": [
        "Goal"
      ],
      "type": "date",
      "description": "When goal pursuit begins"
    },
    {
      "name": "started",
      "expression": "ImagingStudy.started",
      "base": [
        "ImagingStudy"
      ],
      "type": "date",
      "description": "When the study was started"
    },
    {
      "name": "status",
      "expression": "Account.status",
      "base": [
        "Account"
      ],
      "type": "token",
      "description": "active | inactive | entered-in-error | on-hold | unknown"
    },
    {
      "name": "status",
      "expression": "ActivityDefinition.status | ActorDefinition.status | CapabilityStatement.status | ChargeItemDefinition.status | Citation.status | CodeSystem.status | CompartmentDefinition.status | ConceptMap.status | ConditionDefinition.status | EventDefinition.status | Evidence.status | EvidenceVariable.status | ExampleScenario.status | GraphDefinition.status | Group.status | ImplementationGuide.status | Library.status | Measure.status | MedicationKnowledge.status | MessageDefinition.status | NamingSystem.status | ObservationDefinition.status | OperationDefinition.status | PlanDefinition.status | Questionnaire.status | Requirements.status | SearchParameter.status | SpecimenDefinition.status | StructureDefinition.status | StructureMap.status | SubscriptionTopic.status | TerminologyCapabilities.status | TestPlan.status | TestScript.status | ValueSet.status",
      "base": [
        "ActivityDefinition",
        "ActorDefinition",
        "CapabilityStatement",
        "ChargeItemDefinition",
        "Citation",
        "CodeSystem",
        "CompartmentDefinition",
        "ConceptMap",
        "ConditionDefinition",
        "EventDefinition",
        "Evidence",
        "EvidenceVariable",
        "ExampleScenario",
        "GraphDefinition",
        "Group",
        "ImplementationGuide",
        "Library",
        "Measure",
        "MedicationKnowledge",
        "MessageDefinition",
        "NamingSystem",
        "ObservationDefinition",
        "OperationDefinition",
        "PlanDefinition",
        "Questionnaire",
        "Requirements",
        "SearchParameter",
        "SpecimenDefinition",
        "StructureDefinition",
        "StructureMap",
        "SubscriptionTopic",
        "TerminologyCapabilities",
        "TestPlan",
        "TestScript",
        "ValueSet"
      ],
      "type": "token",
      "description": "Multiple Resources: \r\n\r\n* [ActivityDefinition](activitydefinition.html): The current status of the activity definition\r\n* [ActorDefinition](actordefinition.html): The current status of the Actor Definition\r\n* [CapabilityStatement](capabilitystatement.html): The current status of the capability statement\r\n* [ChargeItemDefinition](chargeitemdefinition.html): The current status of the charge item definition\r\n* [Citation](citation.html): The current status of the citation\r\n* [CodeSystem](codesystem.html): The current status of the code system\r\n* [CompartmentDefinition](compartmentdefinition.html): The current status of the compartment definition\r\n* [ConceptMap](conceptmap.html): The current status of the concept map\r\n* [ConditionDefinition](conditiondefinition.html): The current status of the condition definition\r\n* [EventDefinition](eventdefinition.html): The current status of the event definition\r\n* [Evidence](evidence.html): The current status of the evidence\r\n* [EvidenceVariable](evidencevariable.html): The current status of the evidence variable\r\n* [ExampleScenario](examplescenario.html): The current status of the example scenario\r\n* [GraphDefinition](graphdefinition.html): The current status of the graph definition\r\n* [Group](group.html): The current status of the Group\r\n* [ImplementationGuide](implementationguide.html): The current status of the implementation guide\r\n* [Library](library.html): The current status of the library\r\n* [Measure](measure.html): The current status of the measure\r\n* [MedicationKnowledge](medicationknowledge.html): active | inactive | entered-in-error\r\n* [MessageDefinition](messagedefinition.html): The current status of the message definition\r\n* [NamingSystem](namingsystem.html): The current status of the naming system\r\n* [ObservationDefinition](observationdefinition.html): Publication status of the ObservationDefinition: draft, active, retired, unknown\r\n* [OperationDefinition](operationdefinition.html): The current status of the operation definition\r\n* [PlanDefinition](plandefinition.html): The current status of the plan definition\r\n* [Questionnaire](questionnaire.html): The current status of the questionnaire\r\n* [Requirements](requirements.html): The current status of the requirements\r\n* [SearchParameter](searchparameter.html): The current status of the search parameter\r\n* [SpecimenDefinition](specimendefinition.html): Publication status of the SpecimenDefinition: draft, active, retired, unknown\r\n* [StructureDefinition](structuredefinition.html): The current status of the structure definition\r\n* [StructureMap](structuremap.html): The current status of the structure map\r\n* [SubscriptionTopic](subscriptiontopic.html): draft | active | retired | unknown\r\n* [TerminologyCapabilities](terminologycapabilities.html): The current status of the terminology capabilities\r\n* [TestPlan](testplan.html): The current status of the test plan\r\n* [TestScript](testscript.html): The current status of the test script\r\n* [ValueSet](valueset.html): The current status of the value set\r\n"
    },
    {
      "name": "status",
      "expression": "AdministrableProductDefinition.status",
      "base": [
        "AdministrableProductDefinition"
      ],
      "type": "token",
      "description": "The status of this administrable product. Enables tracking the life-cycle of the content."
    },
    {
      "name": "status",
      "expression": "AdverseEvent.status",
      "base": [
        "AdverseEvent"
      ],
      "type": "token",
      "description": "in-progress | completed | entered-in-error | unknown"
    },
    {
      "name": "status",
      "expression": "Appointment.status",
      "base": [
        "Appointment"
      ],
      "type": "token",
      "description": "The overall status of the appointment"
    },
    {
      "name": "status",
      "expression": "BiologicallyDerivedProductDispense.status",
      "base": [
        "BiologicallyDerivedProductDispense"
      ],
      "type": "token",
      "description": "The status of the dispense"
    },
    {
      "name": "status",
      "expression": "CareTeam.status",
      "base": [
        "CareTeam"
      ],
      "type": "token",
      "description": "proposed | active | suspended | inactive | entered-in-error"
    },
    {
      "name": "status",
      "expression": "ChargeItem.status",
      "base": [
        "ChargeItem"
      ],
      "type": "token",
      "description": "Is this charge item active"
    },
    {
      "name": "status",
      "expression": "Claim.status",
      "base": [
        "Claim"
      ],
      "type": "token",
      "description": "The status of the Claim instance."
    },
    {
      "name": "status",
      "expression": "ClaimResponse.status",
      "base": [
        "ClaimResponse"
      ],
      "type": "token",
      "description": "The status of the ClaimResponse"
    },
    {
      "name": "status",
      "expression": "ClinicalAssessment.status",
      "base": [
        "Resource"
      ],
      "type": "token",
      "description": "preparation | in-progress | not-done | on-hold | stopped | completed | entered-in-error | unknown"
    },
    {
      "name": "status",
      "expression": "ClinicalUseDefinition.status",
      "base": [
        "ClinicalUseDefinition"
      ],
      "type": "token",
      "description": "Whether this is a current issue or one that has been retired etc."
    },
    {
      "name": "status",
      "expression": "Communication.status",
      "base": [
        "Communication"
      ],
      "type": "token",
      "description": "preparation | in-progress | not-done | on-hold | stopped | completed | entered-in-error | unknown"
    },
    {
      "name": "status",
      "expression": "CommunicationRequest.status",
      "base": [
        "CommunicationRequest"
      ],
      "type": "token",
      "description": "draft | active | on-hold | revoked | completed | entered-in-error | unknown"
    },
    {
      "name": "status",
      "expression": "Composition.status",
      "base": [
        "Composition"
      ],
      "type": "token",
      "description": "preliminary | final | amended | entered-in-error"
    },
    {
      "name": "status",
      "expression": "Consent.status",
      "base": [
        "Consent"
      ],
      "type": "token",
      "description": "draft | active | inactive | entered-in-error | unknown"
    },
    {
      "name": "status",
      "expression": "Contract.status",
      "base": [
        "Contract"
      ],
      "type": "token",
      "description": "The status of the contract"
    },
    {
      "name": "status",
      "expression": "Coverage.status",
      "base": [
        "Coverage"
      ],
      "type": "token",
      "description": "The status of the Coverage"
    },
    {
      "name": "status",
      "expression": "CoverageEligibilityRequest.status",
      "base": [
        "CoverageEligibilityRequest"
      ],
      "type": "token",
      "description": "The status of the EligibilityRequest"
    },
    {
      "name": "status",
      "expression": "CoverageEligibilityResponse.status",
      "base": [
        "CoverageEligibilityResponse"
      ],
      "type": "token",
      "description": "The EligibilityRequest status"
    },
    {
      "name": "status",
      "expression": "DetectedIssue.status",
      "base": [
        "DetectedIssue"
      ],
      "type": "token",
      "description": "The status of the issue"
    },
    {
      "name": "status",
      "expression": "Device.status",
      "base": [
        "Device"
      ],
      "type": "token",
      "description": "active | inactive | entered-in-error | unknown"
    },
    {
      "name": "status",
      "expression": "DeviceAlert.status",
      "base": [
        "Resource"
      ],
      "type": "token",
      "description": "Status of the alert"
    },
    {
      "name": "status",
      "expression": "DeviceAssociation.status",
      "base": [
        "DeviceAssociation"
      ],
      "type": "token",
      "description": "The status of the device associations"
    },
    {
      "name": "status",
      "expression": "DeviceDispense.status",
      "base": [
        "DeviceDispense"
      ],
      "type": "token",
      "description": "The status of the dispense"
    },
    {
      "name": "status",
      "expression": "DeviceUsage.status",
      "base": [
        "DeviceUsage"
      ],
      "type": "token",
      "description": "The status of the device usage"
    },
    {
      "name": "status",
      "expression": "DocumentReference.status",
      "base": [
        "DocumentReference"
      ],
      "type": "token",
      "description": "current | superseded | entered-in-error"
    },
    {
      "name": "status",
      "expression": "Encounter.status",
      "base": [
        "Encounter"
      ],
      "type": "token",
      "description": "planned | in-progress | on-hold | completed | cancelled | entered-in-error | unknown"
    },
    {
      "name": "status",
      "expression": "EncounterHistory.status",
      "base": [
        "EncounterHistory"
      ],
      "type": "token",
      "description": "Status of the Encounter history entry"
    },
    {
      "name": "status",
      "expression": "Endpoint.status",
      "base": [
        "Endpoint"
      ],
      "type": "token",
      "description": "The current status of the Endpoint (usually expected to be active)"
    },
    {
      "name": "status",
      "expression": "EnrollmentRequest.status",
      "base": [
        "EnrollmentRequest"
      ],
      "type": "token",
      "description": "The status of the enrollment"
    },
    {
      "name": "status",
      "expression": "EnrollmentResponse.status",
      "base": [
        "EnrollmentResponse"
      ],
      "type": "token",
      "description": "The status of the enrollment response"
    },
    {
      "name": "status",
      "expression": "FamilyMemberHistory.status",
      "base": [
        "FamilyMemberHistory"
      ],
      "type": "token",
      "description": "partial | completed | entered-in-error | health-unknown"
    },
    {
      "name": "status",
      "expression": "Flag.status",
      "base": [
        "Flag"
      ],
      "type": "token",
      "description": "active | inactive | entered-in-error"
    },
    {
      "name": "status",
      "expression": "GenomicStudy.status",
      "base": [
        "GenomicStudy"
      ],
      "type": "token",
      "description": "The status of the study"
    },
    {
      "name": "status",
      "expression": "GuidanceResponse.status",
      "base": [
        "GuidanceResponse"
      ],
      "type": "token",
      "description": "The status of the guidance response"
    },
    {
      "name": "status",
      "expression": "ImagingSelection.status",
      "base": [
        "ImagingSelection"
      ],
      "type": "token",
      "description": "The status of the imaging selection"
    },
    {
      "name": "status",
      "expression": "ImagingStudy.status",
      "base": [
        "ImagingStudy"
      ],
      "type": "token",
      "description": "The status of the study"
    },
    {
      "name": "status",
      "expression": "Immunization.status",
      "base": [
        "Immunization"
      ],
      "type": "token",
      "description": "Immunization event status"
    },
    {
      "name": "status",
      "expression": "ImmunizationEvaluation.status",
      "base": [
        "ImmunizationEvaluation"
      ],
      "type": "token",
      "description": "Immunization evaluation status"
    },
    {
      "name": "status",
      "expression": "ImmunizationRecommendation.recommendation.forecastStatus",
      "base": [
        "ImmunizationRecommendation"
      ],
      "type": "token",
      "description": "Vaccine recommendation status"
    },
    {
      "name": "status",
      "expression": "InsuranceProduct.status",
      "base": [
        "Resource"
      ],
      "type": "token",
      "description": "Is the Product record active"
    },
    {
      "name": "status",
      "expression": "InventoryItem.status",
      "base": [
        "InventoryItem"
      ],
      "type": "token",
      "description": "The status of the item"
    },
    {
      "name": "status",
      "expression": "InventoryReport.status",
      "base": [
        "InventoryReport"
      ],
      "type": "token",
      "description": "Search by status"
    },
    {
      "name": "status",
      "expression": "Invoice.status",
      "base": [
        "Invoice"
      ],
      "type": "token",
      "description": "draft | issued | balanced | cancelled | entered-in-error"
    },
    {
      "name": "status",
      "expression": "List.status",
      "base": [
        "List"
      ],
      "type": "token",
      "description": "current | retired | entered-in-error"
    },
    {
      "name": "status",
      "expression": "Location.status",
      "base": [
        "Location"
      ],
      "type": "token",
      "description": "Searches for locations with a specific kind of status"
    },
    {
      "name": "status",
      "expression": "ManufacturedItemDefinition.status",
      "base": [
        "ManufacturedItemDefinition"
      ],
      "type": "token",
      "description": "The status of this item. Enables tracking the life-cycle of the content."
    },
    {
      "name": "status",
      "expression": "MeasureReport.status",
      "base": [
        "MeasureReport"
      ],
      "type": "token",
      "description": "The status of the measure report"
    },
    {
      "name": "status",
      "expression": "Medication.status",
      "base": [
        "Medication"
      ],
      "type": "token",
      "description": "Returns medications for this status"
    },
    {
      "name": "status",
      "expression": "MedicationAdministration.status | MedicationDispense.status | MedicationRequest.status | MedicationStatement.status",
      "base": [
        "MedicationAdministration",
        "MedicationDispense",
        "MedicationRequest",
        "MedicationStatement"
      ],
      "type": "token",
      "description": "Multiple Resources: \r\n\r\n* [MedicationAdministration](medicationadministration.html): MedicationAdministration event status (for example one of active/paused/completed/nullified)\r\n* [MedicationDispense](medicationdispense.html): Returns dispenses with a specified dispense status\r\n* [MedicationRequest](medicationrequest.html): Status of the prescription\r\n* [MedicationStatement](medicationstatement.html): Return statements that match the given status\r\n"
    },
    {
      "name": "status",
      "expression": "MedicinalProductDefinition.status",
      "base": [
        "MedicinalProductDefinition"
      ],
      "type": "token",
      "description": "The status within the lifecycle of this product record. A high-level status, this is not intended to duplicate details carried elsewhere such as legal status, or authorization status"
    },
    {
      "name": "status",
      "expression": "NutritionIntake.status",
      "base": [
        "NutritionIntake"
      ],
      "type": "token",
      "description": "Return statements that match the given status"
    },
    {
      "name": "status",
      "expression": "NutritionOrder.status",
      "base": [
        "NutritionOrder"
      ],
      "type": "token",
      "description": "Status of the nutrition order."
    },
    {
      "name": "status",
      "expression": "NutritionProduct.category",
      "base": [
        "NutritionProduct"
      ],
      "type": "token",
      "description": "The broad product group or category of the nutrition product"
    },
    {
      "name": "status",
      "expression": "Observation.status",
      "base": [
        "Observation"
      ],
      "type": "token",
      "description": "The status of the observation"
    },
    {
      "name": "status",
      "expression": "PackagedProductDefinition.status",
      "base": [
        "PackagedProductDefinition"
      ],
      "type": "token",
      "description": "The status within the lifecycle of this item. A high level status, this is not intended to duplicate details carried elsewhere such as legal status, or authorization or marketing status"
    },
    {
      "name": "status",
      "expression": "PaymentNotice.status",
      "base": [
        "PaymentNotice"
      ],
      "type": "token",
      "description": "The status of the payment notice"
    },
    {
      "name": "status",
      "expression": "PaymentReconciliation.status",
      "base": [
        "PaymentReconciliation"
      ],
      "type": "token",
      "description": "The status of the payment reconciliation"
    },
    {
      "name": "status",
      "expression": "Permission.status",
      "base": [
        "Permission"
      ],
      "type": "token",
      "description": "active | entered-in-error | draft | rejected"
    },
    {
      "name": "status",
      "expression": "Procedure.status",
      "base": [
        "Procedure"
      ],
      "type": "token",
      "description": "preparation | in-progress | not-done | on-hold | stopped | completed | entered-in-error | unknown"
    },
    {
      "name": "status",
      "expression": "QuestionnaireResponse.status",
      "base": [
        "QuestionnaireResponse"
      ],
      "type": "token",
      "description": "The status of the questionnaire response"
    },
    {
      "name": "status",
      "expression": "RegulatedAuthorization.status",
      "base": [
        "RegulatedAuthorization"
      ],
      "type": "token",
      "description": "The status that is authorised e.g. approved. Intermediate states can be tracked with cases and applications"
    },
    {
      "name": "status",
      "expression": "RequestOrchestration.status",
      "base": [
        "RequestOrchestration"
      ],
      "type": "token",
      "description": "The status of the request orchestration"
    },
    {
      "name": "status",
      "expression": "ResearchStudy.status",
      "base": [
        "ResearchStudy"
      ],
      "type": "token",
      "description": "active | active-but-not-recruiting | administratively-completed | approved | closed-to-accrual | closed-to-accrual-and-intervention | completed | disapproved | enrolling-by-invitation | in-review | not-yet-recruiting | recruiting | temporarily-closed-to-accrual | temporarily-closed-to-accrual-and-intervention | terminated | withdrawn"
    },
    {
      "name": "status",
      "expression": "ResearchSubject.status",
      "base": [
        "ResearchSubject"
      ],
      "type": "token",
      "description": "draft | active | retired | unknown"
    },
    {
      "name": "status",
      "expression": "Slot.status",
      "base": [
        "Slot"
      ],
      "type": "token",
      "description": "The free/busy status of the appointment"
    },
    {
      "name": "status",
      "expression": "Specimen.status",
      "base": [
        "Specimen"
      ],
      "type": "token",
      "description": "available | unavailable | unsatisfactory | entered-in-error"
    },
    {
      "name": "status",
      "expression": "Subscription.status",
      "base": [
        "Subscription"
      ],
      "type": "token",
      "description": "The current state of the subscription"
    },
    {
      "name": "status",
      "expression": "Substance.status",
      "base": [
        "Substance"
      ],
      "type": "token",
      "description": "active | inactive | entered-in-error"
    },
    {
      "name": "status",
      "expression": "SupplyDelivery.status",
      "base": [
        "SupplyDelivery"
      ],
      "type": "token",
      "description": "in-progress | completed | abandoned | entered-in-error"
    },
    {
      "name": "status",
      "expression": "SupplyRequest.status",
      "base": [
        "SupplyRequest"
      ],
      "type": "token",
      "description": "draft | active | suspended +"
    },
    {
      "name": "status",
      "expression": "Task.status",
      "base": [
        "Task"
      ],
      "type": "token",
      "description": "Search by task status"
    },
    {
      "name": "status",
      "expression": "TestReport.status",
      "base": [
        "TestReport"
      ],
      "type": "token",
      "description": "The current status of the test report"
    },
    {
      "name": "status",
      "expression": "Transport.status",
      "base": [
        "Transport"
      ],
      "type": "token",
      "description": "in-progress | completed | entered-in-error"
    },
    {
      "name": "status",
      "expression": "VerificationResult.status",
      "base": [
        "VerificationResult"
      ],
      "type": "token",
      "description": "Select validation information with the specified status"
    },
    {
      "name": "status",
      "expression": "VisionPrescription.status",
      "base": [
        "VisionPrescription"
      ],
      "type": "token",
      "description": "The status of the vision prescription"
    },
    {
      "name": "status-date",
      "expression": "VerificationResult.statusDate",
      "base": [
        "VerificationResult"
      ],
      "type": "date",
      "description": "Select validation information with a validation status that occurred at the specified date/time"
    },
    {
      "name": "status-reason",
      "expression": "Immunization.statusReason",
      "base": [
        "Immunization"
      ],
      "type": "token",
      "description": "Reason why the vaccine was not administered"
    },
    {
      "name": "strength-concentration-denominator",
      "expression": "Ingredient.substance.strength.concentration.ofType(Ratio).denominator",
      "base": [
        "Ingredient"
      ],
      "type": "quantity",
      "description": "Ingredient concentration strength denominator (mainly for use in strength-concentration-ratio)"
    },
    {
      "name": "strength-concentration-numerator",
      "expression": "Ingredient.substance.strength.concentration.ofType(Ratio).numerator",
      "base": [
        "Ingredient"
      ],
      "type": "quantity",
      "description": "Ingredient concentration strength numerator (mainly for use in strength-concentration-ratio)"
    },
    {
      "name": "strength-concentration-quantity",
      "expression": "Ingredient.substance.strength.concentration.ofType(Quantity)",
      "base": [
        "Ingredient"
      ],
      "type": "quantity",
      "description": "Ingredient concentration strength as quantity"
    },
    {
      "name": "strength-concentration-ratio",
      "expression": "Ingredient.substance.strength.concentration.ofType(Ratio)",
      "base": [
        "Ingredient"
      ],
      "type": "composite",
      "description": "Ingredient concentration strength as ratio, numerator and denominator parameter pair"
    },
    {
      "name": "strength-presentation-denominator",
      "expression": "Ingredient.substance.strength.presentation.ofType(Ratio).denominator",
      "base": [
        "Ingredient"
      ],
      "type": "quantity",
      "description": "Ingredient presentation strength denominator (mainly for use in strength-presentation-ratio)"
    },
    {
      "name": "strength-presentation-numerator",
      "expression": "Ingredient.substance.strength.presentation.ofType(Ratio).numerator",
      "base": [
        "Ingredient"
      ],
      "type": "quantity",
      "description": "Ingredient presentation strength numerator (mainly for use in strength-presentation-ratio)"
    },
    {
      "name": "strength-presentation-quantity",
      "expression": "Ingredient.substance.strength.presentation.ofType(Quantity)",
      "base": [
        "Ingredient"
      ],
      "type": "quantity",
      "description": "Ingredient presentation strength as quantity"
    },
    {
      "name": "strength-presentation-ratio",
      "expression": "Ingredient.substance.strength.presentation.ofType(Ratio)",
      "base": [
        "Ingredient"
      ],
      "type": "composite",
      "description": "Ingredient presentation strength as ratio, numerator and denominator parameter pair"
    },
    {
      "name": "study",
      "expression": "DiagnosticReport.study",
      "base": [
        "DiagnosticReport"
      ],
      "type": "reference",
      "description": "Studies associated with the diagnostic report"
    },
    {
      "name": "study-design",
      "expression": "ResearchStudy.studyDesign",
      "base": [
        "ResearchStudy"
      ],
      "type": "token",
      "description": "Classifications of the study design characteristics"
    },
    {
      "name": "study-uid",
      "expression": "ImagingSelection.studyUid",
      "base": [
        "ImagingSelection"
      ],
      "type": "token",
      "description": "The DICOM Study Instance UID from which the images were selected"
    },
    {
      "name": "subdetail-udi",
      "expression": "Claim.item.detail.subDetail.udi",
      "base": [
        "Claim"
      ],
      "type": "reference",
      "description": "UDI associated with a line item, detail, subdetail product or service"
    },
    {
      "name": "subdetail-udi",
      "expression": "ExplanationOfBenefit.item.detail.subDetail.udi",
      "base": [
        "ExplanationOfBenefit"
      ],
      "type": "reference",
      "description": "UDI associated with a line item detail subdetail product or service"
    },
    {
      "name": "subject",
      "expression": "Account.subject",
      "base": [
        "Account"
      ],
      "type": "reference",
      "description": "The entity that caused the expenses"
    },
    {
      "name": "subject",
      "expression": "AdverseEvent.subject",
      "base": [
        "AdverseEvent"
      ],
      "type": "reference",
      "description": "Subject impacted by event"
    },
    {
      "name": "subject",
      "expression": "Appointment.subject",
      "base": [
        "Appointment"
      ],
      "type": "reference",
      "description": "One of the individuals of the appointment is this patient"
    },
    {
      "name": "subject",
      "expression": "Basic.subject",
      "base": [
        "Basic"
      ],
      "type": "reference",
      "description": "Identifies the focus of this resource"
    },
    {
      "name": "subject",
      "expression": "CarePlan.subject",
      "base": [
        "CarePlan"
      ],
      "type": "reference",
      "description": "Who the care plan is for"
    },
    {
      "name": "subject",
      "expression": "CareTeam.subject",
      "base": [
        "CareTeam"
      ],
      "type": "reference",
      "description": "Who care team is for"
    },
    {
      "name": "subject",
      "expression": "ChargeItem.subject",
      "base": [
        "ChargeItem"
      ],
      "type": "reference",
      "description": "Individual service was done for/to"
    },
    {
      "name": "subject",
      "expression": "ClinicalAssessment.subject",
      "base": [
        "Resource"
      ],
      "type": "reference",
      "description": "Patient or group assessed"
    },
    {
      "name": "subject",
      "expression": "Communication.subject",
      "base": [
        "Communication"
      ],
      "type": "reference",
      "description": "Focus of message"
    },
    {
      "name": "subject",
      "expression": "Composition.subject",
      "base": [
        "Composition"
      ],
      "type": "reference",
      "description": "Who and/or what the composition is about"
    },
    {
      "name": "subject",
      "expression": "Condition.subject",
      "base": [
        "Condition"
      ],
      "type": "reference",
      "description": "Who has the condition?"
    },
    {
      "name": "subject",
      "expression": "Consent.subject",
      "base": [
        "Consent"
      ],
      "type": "reference",
      "description": "Who the consent applies to"
    },
    {
      "name": "subject",
      "expression": "Contract.subject",
      "base": [
        "Contract"
      ],
      "type": "reference",
      "description": "The identity of the subject of the contract"
    },
    {
      "name": "subject",
      "expression": "DetectedIssue.subject",
      "base": [
        "DetectedIssue"
      ],
      "type": "reference",
      "description": "Associated subject"
    },
    {
      "name": "subject",
      "expression": "DeviceAssociation.subject",
      "base": [
        "DeviceAssociation"
      ],
      "type": "reference",
      "description": "The identity of a patient for whom to list associations"
    },
    {
      "name": "subject",
      "expression": "DeviceDispense.subject",
      "base": [
        "DeviceDispense"
      ],
      "type": "reference",
      "description": "The identity of a patient for whom to list dispenses"
    },
    {
      "name": "subject",
      "expression": "DeviceRequest.subject",
      "base": [
        "DeviceRequest"
      ],
      "type": "reference",
      "description": "Individual the service is ordered for"
    },
    {
      "name": "subject",
      "expression": "DiagnosticReport.subject",
      "base": [
        "DiagnosticReport"
      ],
      "type": "reference",
      "description": "The subject of the report"
    },
    {
      "name": "subject",
      "expression": "DocumentReference.subject",
      "base": [
        "DocumentReference"
      ],
      "type": "reference",
      "description": "Who/what is the subject of the document"
    },
    {
      "name": "subject",
      "expression": "Encounter.subject",
      "base": [
        "Encounter"
      ],
      "type": "reference",
      "description": "The patient or group present at the encounter"
    },
    {
      "name": "subject",
      "expression": "EncounterHistory.subject",
      "base": [
        "EncounterHistory"
      ],
      "type": "reference",
      "description": "The patient or group present at the encounter"
    },
    {
      "name": "subject",
      "expression": "EnrollmentRequest.candidate",
      "base": [
        "EnrollmentRequest"
      ],
      "type": "reference",
      "description": "The party to be enrolled"
    },
    {
      "name": "subject",
      "expression": "EpisodeOfCare.subject",
      "base": [
        "EpisodeOfCare"
      ],
      "type": "reference",
      "description": "The patient/group who is the focus of this episode of care"
    },
    {
      "name": "subject",
      "expression": "Flag.subject",
      "base": [
        "Flag"
      ],
      "type": "reference",
      "description": "The identity of a subject to list flags for"
    },
    {
      "name": "subject",
      "expression": "GenomicStudy.subject",
      "base": [
        "GenomicStudy"
      ],
      "type": "reference",
      "description": "Who the study is about"
    },
    {
      "name": "subject",
      "expression": "Goal.subject",
      "base": [
        "Goal"
      ],
      "type": "reference",
      "description": "Who this goal is intended for"
    },
    {
      "name": "subject",
      "expression": "GuidanceResponse.subject",
      "base": [
        "GuidanceResponse"
      ],
      "type": "reference",
      "description": "The subject that the guidance response is about"
    },
    {
      "name": "subject",
      "expression": "ImagingSelection.subject",
      "base": [
        "ImagingSelection"
      ],
      "type": "reference",
      "description": "The subject of the Imaging Selection, such as the associated Patient"
    },
    {
      "name": "subject",
      "expression": "ImagingStudy.subject",
      "base": [
        "ImagingStudy"
      ],
      "type": "reference",
      "description": "Who the study is about"
    },
    {
      "name": "subject",
      "expression": "InventoryItem.instance.subject",
      "base": [
        "InventoryItem"
      ],
      "type": "reference",
      "description": "The identity of a patient for whom to list associations"
    },
    {
      "name": "subject",
      "expression": "Invoice.subject",
      "base": [
        "Invoice"
      ],
      "type": "reference",
      "description": "Recipient(s) of goods and services"
    },
    {
      "name": "subject",
      "expression": "List.subject",
      "base": [
        "List"
      ],
      "type": "reference",
      "description": "If all resources have the same subject"
    },
    {
      "name": "subject",
      "expression": "MeasureReport.subject",
      "base": [
        "MeasureReport"
      ],
      "type": "reference",
      "description": "The identity of a subject to search for individual measure report results for"
    },
    {
      "name": "subject",
      "expression": "MedicationAdministration.subject",
      "base": [
        "MedicationAdministration"
      ],
      "type": "reference",
      "description": "The identity of the individual or group to list administrations for"
    },
    {
      "name": "subject",
      "expression": "MedicationDispense.subject",
      "base": [
        "MedicationDispense"
      ],
      "type": "reference",
      "description": "The identity of a patient for whom to list dispenses"
    },
    {
      "name": "subject",
      "expression": "MedicationRequest.subject",
      "base": [
        "MedicationRequest"
      ],
      "type": "reference",
      "description": "The identity of a patient to list orders  for"
    },
    {
      "name": "subject",
      "expression": "MedicationStatement.subject",
      "base": [
        "MedicationStatement"
      ],
      "type": "reference",
      "description": "The identity of a patient, animal or group to list statements for"
    },
    {
      "name": "subject",
      "expression": "NutritionIntake.subject",
      "base": [
        "NutritionIntake"
      ],
      "type": "reference",
      "description": "The identity of a patient, animal or group to list statements for"
    },
    {
      "name": "subject",
      "expression": "NutritionOrder.subject",
      "base": [
        "NutritionOrder"
      ],
      "type": "reference",
      "description": "The identity of the individual or set of individuals who requires the diet, formula or nutritional supplement"
    },
    {
      "name": "subject",
      "expression": "Observation.subject",
      "base": [
        "Observation"
      ],
      "type": "reference",
      "description": "The subject that the observation is about"
    },
    {
      "name": "subject",
      "expression": "Procedure.subject",
      "base": [
        "Procedure"
      ],
      "type": "reference",
      "description": "Search by subject"
    },
    {
      "name": "subject",
      "expression": "QuestionnaireResponse.subject",
      "base": [
        "QuestionnaireResponse"
      ],
      "type": "reference",
      "description": "The subject of the questionnaire response"
    },
    {
      "name": "subject",
      "expression": "RegulatedAuthorization.subject",
      "base": [
        "RegulatedAuthorization"
      ],
      "type": "reference",
      "description": "The type of regulated product, treatment, facility or activity that is being authorized"
    },
    {
      "name": "subject",
      "expression": "RequestOrchestration.subject",
      "base": [
        "RequestOrchestration"
      ],
      "type": "reference",
      "description": "The subject that the request orchestration is about"
    },
    {
      "name": "subject",
      "expression": "ResearchSubject.subject",
      "base": [
        "ResearchSubject"
      ],
      "type": "reference",
      "description": "Who or what is part of study"
    },
    {
      "name": "subject",
      "expression": "RiskAssessment.subject",
      "base": [
        "RiskAssessment"
      ],
      "type": "reference",
      "description": "Who/what does assessment apply to?"
    },
    {
      "name": "subject",
      "expression": "ServiceRequest.subject",
      "base": [
        "ServiceRequest"
      ],
      "type": "reference",
      "description": "Search by subject"
    },
    {
      "name": "subject",
      "expression": "Specimen.subject",
      "base": [
        "Specimen"
      ],
      "type": "reference",
      "description": "The subject of the specimen"
    },
    {
      "name": "subject",
      "expression": "SupplyRequest.deliverTo",
      "base": [
        "SupplyRequest"
      ],
      "type": "reference",
      "description": "The destination of the supply"
    },
    {
      "name": "subject_state",
      "expression": "ResearchSubject.subjectState.code",
      "base": [
        "ResearchSubject"
      ],
      "type": "token",
      "description": "candidate | in-prescreening | in-screening | eligible | ineligible | on-study | on-study-intervention | in-follow-up | off-study"
    },
    {
      "name": "subject-canonical",
      "expression": "ActivityDefinition.subject as canonical",
      "base": [
        "ActivityDefinition"
      ],
      "type": "reference",
      "description": "The subject of the ActivityDefinition when expressed as a canonical"
    },
    {
      "name": "subject-canonical",
      "expression": "Library.subject as canonical",
      "base": [
        "Library"
      ],
      "type": "reference",
      "description": "The subject of the Library when expressed as a canonical"
    },
    {
      "name": "subject-canonical",
      "expression": "Measure.subject as canonical",
      "base": [
        "Measure"
      ],
      "type": "reference",
      "description": "The subject of the Measure when expressed as a canonical"
    },
    {
      "name": "subject-canonical",
      "expression": "PlanDefinition.subject as canonical",
      "base": [
        "PlanDefinition"
      ],
      "type": "reference",
      "description": "The subject of the PlanDefinition when expressed as a canonical"
    },
    {
      "name": "subject-code",
      "expression": "ActivityDefinition.subject as CodeableConcept",
      "base": [
        "ActivityDefinition"
      ],
      "type": "token",
      "description": "The subject of the ActivityDefinition when expressed as a code"
    },
    {
      "name": "subject-code",
      "expression": "Library.subject as CodeableConcept",
      "base": [
        "Library"
      ],
      "type": "token",
      "description": "The subject of the Library when expressed as a code"
    },
    {
      "name": "subject-code",
      "expression": "Measure.subject as CodeableConcept",
      "base": [
        "Measure"
      ],
      "type": "token",
      "description": "The subject of the Measure when expressed as a code"
    },
    {
      "name": "subject-code",
      "expression": "PlanDefinition.subject as CodeableConcept",
      "base": [
        "PlanDefinition"
      ],
      "type": "token",
      "description": "The subject of the PlanDefinition when expressed as a code"
    },
    {
      "name": "subject-reference",
      "expression": "ActivityDefinition.subject as Reference",
      "base": [
        "ActivityDefinition"
      ],
      "type": "reference",
      "description": "The subject of the ActivityDefinition when expressed as a reference"
    },
    {
      "name": "subject-reference",
      "expression": "Library.subject as Reference",
      "base": [
        "Library"
      ],
      "type": "reference",
      "description": "The subject of the Library when expressed as a reference"
    },
    {
      "name": "subject-reference",
      "expression": "Measure.subject as Reference",
      "base": [
        "Measure"
      ],
      "type": "reference",
      "description": "The subject of the Measure when expressed as a reference"
    },
    {
      "name": "subject-reference",
      "expression": "PlanDefinition.subject as Reference",
      "base": [
        "PlanDefinition"
      ],
      "type": "reference",
      "description": "The subject of the PlanDefinition when expressed as a reference"
    },
    {
      "name": "subject-status",
      "expression": "Encounter.subjectStatus",
      "base": [
        "Encounter"
      ],
      "type": "token",
      "description": "The current status of the subject in relation to the Encounter"
    },
    {
      "name": "subject-type",
      "expression": "Questionnaire.subjectType",
      "base": [
        "Questionnaire"
      ],
      "type": "token",
      "description": "Resource that can be subject of QuestionnaireResponse"
    },
    {
      "name": "subscriberid",
      "expression": "Coverage.subscriberId",
      "base": [
        "Coverage"
      ],
      "type": "token",
      "description": "Identifier of the subscriber"
    },
    {
      "name": "substance",
      "expression": "AdverseEvent.suspectEntity.instance.reference",
      "base": [
        "AdverseEvent"
      ],
      "type": "reference",
      "description": "Refers to the specific entity that caused the adverse event"
    },
    {
      "name": "substance",
      "expression": "Ingredient.substance.code.reference",
      "base": [
        "Ingredient"
      ],
      "type": "reference",
      "description": "Reference to a resource (by instance)"
    },
    {
      "name": "substance-code",
      "expression": "Ingredient.substance.code.concept",
      "base": [
        "Ingredient"
      ],
      "type": "token",
      "description": "Reference to a concept (by class)"
    },
    {
      "name": "substance-definition",
      "expression": "Ingredient.substance.code.reference",
      "base": [
        "Ingredient"
      ],
      "type": "reference",
      "description": "Reference to a resource (by instance)"
    },
    {
      "name": "subtype",
      "expression": "AuditEvent.subtype",
      "base": [
        "AuditEvent"
      ],
      "type": "token",
      "description": "More specific code for the event"
    },
    {
      "name": "supplement",
      "expression": "NutritionOrder.supplement.type.concept",
      "base": [
        "NutritionOrder"
      ],
      "type": "token",
      "description": "Type of supplement product requested"
    },
    {
      "name": "supplements",
      "expression": "CodeSystem.supplements",
      "base": [
        "CodeSystem"
      ],
      "type": "reference",
      "description": "Find code system supplements for the referenced code system"
    },
    {
      "name": "supplier",
      "expression": "SupplyDelivery.supplier",
      "base": [
        "SupplyDelivery"
      ],
      "type": "reference",
      "description": "Dispenser"
    },
    {
      "name": "supported-profile",
      "expression": "CapabilityStatement.rest.resource.supportedProfile",
      "base": [
        "CapabilityStatement"
      ],
      "type": "reference",
      "description": "Profiles for use cases supported"
    },
    {
      "name": "supporting-info",
      "expression": "Appointment.supportingInformation",
      "base": [
        "Appointment"
      ],
      "type": "reference",
      "description": "Additional information to support the appointment"
    },
    {
      "name": "system",
      "expression": "CodeSystem.url",
      "base": [
        "CodeSystem"
      ],
      "type": "uri",
      "description": "The system for any codes defined by this code system (same as 'url')"
    },
    {
      "name": "system",
      "expression": "OperationDefinition.system",
      "base": [
        "OperationDefinition"
      ],
      "type": "token",
      "description": "Invoke at the system level?"
    },
    {
      "name": "target",
      "expression": "PersonalRelationship.target",
      "base": [
        "Resource"
      ],
      "type": "reference",
      "description": "The target of the relationship"
    },
    {
      "name": "target",
      "expression": "Provenance.target",
      "base": [
        "Provenance"
      ],
      "type": "reference",
      "description": "Target Reference(s) (usually version specific)"
    },
    {
      "name": "target",
      "expression": "SearchParameter.target",
      "base": [
        "SearchParameter"
      ],
      "type": "token",
      "description": "Types of resource (if a resource reference)"
    },
    {
      "name": "target",
      "expression": "VerificationResult.target",
      "base": [
        "VerificationResult"
      ],
      "type": "reference",
      "description": "A resource that was validated"
    },
    {
      "name": "target-code",
      "expression": "ConceptMap.group.element.target.code",
      "base": [
        "ConceptMap"
      ],
      "type": "token",
      "description": "Code that identifies the target element"
    },
    {
      "name": "target-date",
      "expression": "(Goal.target.due.ofType(date))",
      "base": [
        "Goal"
      ],
      "type": "date",
      "description": "Reach goal on or before"
    },
    {
      "name": "target-disease",
      "expression": "Immunization.protocolApplied.targetDisease",
      "base": [
        "Immunization"
      ],
      "type": "token",
      "description": "The target disease the dose is being administered against"
    },
    {
      "name": "target-disease",
      "expression": "ImmunizationEvaluation.targetDisease",
      "base": [
        "ImmunizationEvaluation"
      ],
      "type": "token",
      "description": "The vaccine preventable disease being evaluated against"
    },
    {
      "name": "target-disease",
      "expression": "ImmunizationRecommendation.recommendation.targetDisease",
      "base": [
        "ImmunizationRecommendation"
      ],
      "type": "token",
      "description": "Disease to be immunized against"
    },
    {
      "name": "target-group-system",
      "expression": "ConceptMap.group.target",
      "base": [
        "ConceptMap"
      ],
      "type": "reference",
      "description": "Target system that the concepts are to be mapped to"
    },
    {
      "name": "target-measure",
      "expression": "Goal.target.measure",
      "base": [
        "Goal"
      ],
      "type": "token",
      "description": "The parameter whose value is being tracked"
    },
    {
      "name": "target-scope",
      "expression": "(ConceptMap.targetScope as canonical)",
      "base": [
        "ConceptMap"
      ],
      "type": "reference",
      "description": "The target value set which provides context for the mappings"
    },
    {
      "name": "target-scope-uri",
      "expression": "(ConceptMap.targetScope as uri)",
      "base": [
        "ConceptMap"
      ],
      "type": "uri",
      "description": "The URI for the target value set that contains the concepts being mapped."
    },
    {
      "name": "telecom",
      "expression": "NamingSystem.contact.telecom",
      "base": [
        "NamingSystem"
      ],
      "type": "token",
      "description": "Contact details for individual or organization"
    },
    {
      "name": "telecom",
      "expression": "OrganizationAffiliation.contact.telecom",
      "base": [
        "OrganizationAffiliation"
      ],
      "type": "token",
      "description": "The value in any kind of contact"
    },
    {
      "name": "telecom",
      "expression": "Patient.telecom | Person.telecom | Practitioner.telecom | PractitionerRole.contact.telecom | RelatedPerson.telecom",
      "base": [
        "Patient",
        "Person",
        "Practitioner",
        "PractitionerRole",
        "RelatedPerson"
      ],
      "type": "token",
      "description": "Multiple Resources: \r\n\r\n* [Patient](patient.html): The value in any kind of telecom details of the patient\r\n* [Person](person.html): The value in any kind of contact\r\n* [Practitioner](practitioner.html): The value in any kind of contact\r\n* [PractitionerRole](practitionerrole.html): The value in any kind of contact\r\n* [RelatedPerson](relatedperson.html): The value in any kind of contact\r\n"
    },
    {
      "name": "tester",
      "expression": "TestReport.tester",
      "base": [
        "TestReport"
      ],
      "type": "string",
      "description": "The name of the testing organization"
    },
    {
      "name": "testscript",
      "expression": "TestReport.testScript",
      "base": [
        "TestReport"
      ],
      "type": "reference",
      "description": "The test script executed to produce this report"
    },
    {
      "name": "testscript-capability",
      "expression": "TestScript.metadata.capability.description",
      "base": [
        "TestScript"
      ],
      "type": "string",
      "description": "TestScript required and validated capability"
    },
    {
      "name": "timestamp",
      "expression": "Bundle.timestamp",
      "base": [
        "Bundle"
      ],
      "type": "date",
      "description": "When the bundle was assembled"
    },
    {
      "name": "timing",
      "expression": "DeviceAlert.condition.timing",
      "base": [
        "Resource"
      ],
      "type": "date",
      "description": "When the alert condition occured"
    },
    {
      "name": "title",
      "expression": "ActivityDefinition.title | ActorDefinition.title | CapabilityStatement.title | ChargeItemDefinition.title | Citation.title | CodeSystem.title | ConceptMap.title | ConditionDefinition.title | EventDefinition.title | Evidence.title | EvidenceVariable.title | ImplementationGuide.title | Library.title | Measure.title | MessageDefinition.title | ObservationDefinition.title | OperationDefinition.title | PlanDefinition.title | Questionnaire.title | Requirements.title | SpecimenDefinition.title | StructureDefinition.title | StructureMap.title | SubscriptionTopic.title | TerminologyCapabilities.title | TestPlan.title | TestScript.title | ValueSet.title",
      "base": [
        "ActivityDefinition",
        "ActorDefinition",
        "CapabilityStatement",
        "ChargeItemDefinition",
        "Citation",
        "CodeSystem",
        "ConceptMap",
        "ConditionDefinition",
        "EventDefinition",
        "Evidence",
        "EvidenceVariable",
        "ImplementationGuide",
        "Library",
        "Measure",
        "MessageDefinition",
        "ObservationDefinition",
        "OperationDefinition",
        "PlanDefinition",
        "Questionnaire",
        "Requirements",
        "SpecimenDefinition",
        "StructureDefinition",
        "StructureMap",
        "SubscriptionTopic",
        "TerminologyCapabilities",
        "TestPlan",
        "TestScript",
        "ValueSet"
      ],
      "type": "string",
      "description": "Multiple Resources: \r\n\r\n* [ActivityDefinition](activitydefinition.html): The human-friendly name of the activity definition\r\n* [ActorDefinition](actordefinition.html): The human-friendly name of the Actor Definition\r\n* [CapabilityStatement](capabilitystatement.html): The human-friendly name of the capability statement\r\n* [ChargeItemDefinition](chargeitemdefinition.html): The human-friendly name of the charge item definition\r\n* [Citation](citation.html): The human-friendly name of the citation\r\n* [CodeSystem](codesystem.html): The human-friendly name of the code system\r\n* [ConceptMap](conceptmap.html): The human-friendly name of the concept map\r\n* [ConditionDefinition](conditiondefinition.html): The human-friendly name of the condition definition\r\n* [EventDefinition](eventdefinition.html): The human-friendly name of the event definition\r\n* [Evidence](evidence.html): The human-friendly name of the evidence\r\n* [EvidenceVariable](evidencevariable.html): The human-friendly name of the evidence variable\r\n* [ImplementationGuide](implementationguide.html): The human-friendly name of the implementation guide\r\n* [Library](library.html): The human-friendly name of the library\r\n* [Measure](measure.html): The human-friendly name of the measure\r\n* [MessageDefinition](messagedefinition.html): The human-friendly name of the message definition\r\n* [ObservationDefinition](observationdefinition.html): Human-friendly name of the ObservationDefinition\r\n* [OperationDefinition](operationdefinition.html): The human-friendly name of the operation definition\r\n* [PlanDefinition](plandefinition.html): The human-friendly name of the plan definition\r\n* [Questionnaire](questionnaire.html): The human-friendly name of the questionnaire\r\n* [Requirements](requirements.html): The human-friendly name of the requirements\r\n* [SpecimenDefinition](specimendefinition.html): Human-friendly name of the SpecimenDefinition\r\n* [StructureDefinition](structuredefinition.html): The human-friendly name of the structure definition\r\n* [StructureMap](structuremap.html): The human-friendly name of the structure map\r\n* [SubscriptionTopic](subscriptiontopic.html): Name for this SubscriptionTopic (Human friendly)\r\n* [TerminologyCapabilities](terminologycapabilities.html): The human-friendly name of the terminology capabilities\r\n* [TestPlan](testplan.html): The human-friendly name of the test script\r\n* [TestScript](testscript.html): The human-friendly name of the test script\r\n* [ValueSet](valueset.html): The human-friendly name of the value set\r\n"
    },
    {
      "name": "title",
      "expression": "Composition.title",
      "base": [
        "Composition"
      ],
      "type": "string",
      "description": "Human Readable name/title"
    },
    {
      "name": "title",
      "expression": "List.title",
      "base": [
        "List"
      ],
      "type": "string",
      "description": "Descriptive name for the list"
    },
    {
      "name": "title",
      "expression": "ResearchStudy.title",
      "base": [
        "ResearchStudy"
      ],
      "type": "string",
      "description": "The human readable name of the research study"
    },
    {
      "name": "topic",
      "expression": "ActivityDefinition.topic | CodeSystem.topic | ConceptMap.topic | EventDefinition.topic | Library.topic | Measure.topic | NamingSystem.topic | PlanDefinition.topic | ValueSet.topic",
      "base": [
        "ActivityDefinition",
        "CodeSystem",
        "ConceptMap",
        "EventDefinition",
        "EvidenceVariable",
        "Library",
        "Measure",
        "NamingSystem",
        "PlanDefinition",
        "ValueSet"
      ],
      "type": "token",
      "description": "Multiple Resources: \r\n\r\n* [ActivityDefinition](activitydefinition.html): Topics associated with the module\r\n* [CodeSystem](codesystem.html): Topics associated with the CodeSystem\r\n* [ConceptMap](conceptmap.html): Topics associated with the ConceptMap\r\n* [EventDefinition](eventdefinition.html): Topics associated with the module\r\n* [EvidenceVariable](evidencevariable.html): Topics associated with the EvidenceVariable\r\n* [Library](library.html): Topics associated with the module\r\n* [Measure](measure.html): Topics associated with the measure\r\n* [NamingSystem](namingsystem.html): Topics associated with the NamingSystem\r\n* [PlanDefinition](plandefinition.html): Topics associated with the module\r\n* [ValueSet](valueset.html): Topics associated with the ValueSet\r\n"
    },
    {
      "name": "topic",
      "expression": "Communication.topic",
      "base": [
        "Communication"
      ],
      "type": "token",
      "description": "Description of the purpose/content"
    },
    {
      "name": "topic",
      "expression": "Subscription.topic",
      "base": [
        "Subscription"
      ],
      "type": "uri",
      "description": "The canonical topic url that triggers notifications"
    },
    {
      "name": "topology",
      "expression": "MolecularDefinition.topology",
      "base": [
        "Resource"
      ],
      "type": "token",
      "description": "The structural topology of the molecular entity (e.g., linear, circular)"
    },
    {
      "name": "totalgross",
      "expression": "Invoice.totalGross",
      "base": [
        "Invoice"
      ],
      "type": "quantity",
      "description": "Gross total of this Invoice"
    },
    {
      "name": "totalnet",
      "expression": "Invoice.totalNet",
      "base": [
        "Invoice"
      ],
      "type": "quantity",
      "description": "Net total of this Invoice"
    },
    {
      "name": "trigger-description",
      "expression": "SubscriptionTopic.trigger.description",
      "base": [
        "SubscriptionTopic"
      ],
      "type": "string",
      "description": "Text representation of the trigger"
    },
    {
      "name": "type",
      "expression": "Account.type | AllergyIntolerance.type | Composition.type | Coverage.type | DocumentReference.type | Encounter.type | EpisodeOfCare.type | Invoice.type | MedicationDispense.type | MolecularSequence.type | Specimen.type",
      "base": [
        "Account",
        "AllergyIntolerance",
        "Composition",
        "Coverage",
        "DocumentReference",
        "Encounter",
        "EpisodeOfCare",
        "Invoice",
        "MedicationDispense",
        "MolecularSequence",
        "Specimen"
      ],
      "type": "token",
      "description": "Multiple Resources: \r\n\r\n* [Account](account.html): E.g. patient, expense, depreciation\r\n* [AllergyIntolerance](allergyintolerance.html): allergy | intolerance - Underlying mechanism (if known)\r\n* [Composition](composition.html): Kind of composition (LOINC if possible)\r\n* [Coverage](coverage.html): The kind of coverage (health plan, auto, Workers Compensation)\r\n* [DocumentReference](documentreference.html): Kind of document (LOINC if possible)\r\n* [Encounter](encounter.html): Specific type of encounter\r\n* [EpisodeOfCare](episodeofcare.html): Type/class  - e.g. specialist referral, disease management\r\n* [Invoice](invoice.html): Type of Invoice\r\n* [MedicationDispense](medicationdispense.html): Returns dispenses of a specific type\r\n* [MolecularSequence](molecularsequence.html): Amino Acid Sequence/ DNA Sequence / RNA Sequence\r\n* [Specimen](specimen.html): The specimen type\r\n"
    },
    {
      "name": "type",
      "expression": "ActorDefinition.type",
      "base": [
        "ActorDefinition"
      ],
      "type": "token",
      "description": "The type of actor"
    },
    {
      "name": "type",
      "expression": "AuditEvent.type",
      "base": [
        "AuditEvent"
      ],
      "type": "token",
      "description": "Type (category) of event"
    },
    {
      "name": "type",
      "expression": "Bundle.type",
      "base": [
        "Bundle"
      ],
      "type": "token",
      "description": "document | message | transaction | transaction-response | batch | batch-response | history | searchset | collection | subscription-notification"
    },
    {
      "name": "type",
      "expression": "ClinicalUseDefinition.type",
      "base": [
        "ClinicalUseDefinition"
      ],
      "type": "token",
      "description": "indication | contraindication | interaction | undesirable-effect | warning"
    },
    {
      "name": "type",
      "expression": "Device.type |  Device.definition.resolve().classification.type ",
      "base": [
        "Device"
      ],
      "type": "token",
      "description": "The type of the device"
    },
    {
      "name": "type",
      "expression": "DeviceAlert.type",
      "base": [
        "Resource"
      ],
      "type": "token",
      "description": "Whether the alert is physiological or technical"
    },
    {
      "name": "type",
      "expression": "DeviceDefinition.conformsTo.category",
      "base": [
        "DeviceDefinition"
      ],
      "type": "token",
      "description": "The device type"
    },
    {
      "name": "type",
      "expression": "DeviceMetric.type",
      "base": [
        "DeviceMetric"
      ],
      "type": "token",
      "description": "The type of metric"
    },
    {
      "name": "type",
      "expression": "Group.type",
      "base": [
        "Group"
      ],
      "type": "token",
      "description": "The type of resources the group contains"
    },
    {
      "name": "type",
      "expression": "InsurancePlan.type",
      "base": [
        "InsurancePlan"
      ],
      "type": "token",
      "description": "A code for the type of insurance plan"
    },
    {
      "name": "type",
      "expression": "InsuranceProduct.type",
      "base": [
        "Resource"
      ],
      "type": "token",
      "description": "A code for the type of insurance product"
    },
    {
      "name": "type",
      "expression": "Library.type",
      "base": [
        "Library"
      ],
      "type": "token",
      "description": "The type of the library (e.g. logic-library, model-definition, asset-collection, module-definition)"
    },
    {
      "name": "type",
      "expression": "Location.type",
      "base": [
        "Location"
      ],
      "type": "token",
      "description": "A code for the type of location"
    },
    {
      "name": "type",
      "expression": "MedicinalProductDefinition.type",
      "base": [
        "MedicinalProductDefinition"
      ],
      "type": "token",
      "description": "Regulatory type, e.g. Investigational or Authorized"
    },
    {
      "name": "type",
      "expression": "MolecularDefinition.type",
      "base": [
        "Resource"
      ],
      "type": "token",
      "description": "Classification of the molecule into types other than those defined by moleculeType"
    },
    {
      "name": "type",
      "expression": "NamingSystem.type",
      "base": [
        "NamingSystem"
      ],
      "type": "token",
      "description": "e.g. driver,  provider,  patient, bank etc."
    },
    {
      "name": "type",
      "expression": "OperationDefinition.type",
      "base": [
        "OperationDefinition"
      ],
      "type": "token",
      "description": "Invoke at the type level?"
    },
    {
      "name": "type",
      "expression": "Organization.type",
      "base": [
        "Organization"
      ],
      "type": "token",
      "description": "A code for the type of organization"
    },
    {
      "name": "type",
      "expression": "PlanDefinition.type",
      "base": [
        "PlanDefinition"
      ],
      "type": "token",
      "description": "The type of artifact the plan (e.g. order-set, eca-rule, protocol)"
    },
    {
      "name": "type",
      "expression": "SearchParameter.type",
      "base": [
        "SearchParameter"
      ],
      "type": "token",
      "description": "number | date | string | token | reference | composite | quantity | uri | special"
    },
    {
      "name": "type",
      "expression": "SpecimenDefinition.typeCollected",
      "base": [
        "SpecimenDefinition"
      ],
      "type": "token",
      "description": "The type of collected specimen"
    },
    {
      "name": "type",
      "expression": "StructureDefinition.type",
      "base": [
        "StructureDefinition"
      ],
      "type": "uri",
      "description": "Type defined or constrained by this structure"
    },
    {
      "name": "type",
      "expression": "Subscription.channelType",
      "base": [
        "Subscription"
      ],
      "type": "token",
      "description": "The type of channel for the sent notifications"
    },
    {
      "name": "type-tested",
      "expression": "SpecimenDefinition.typeTested.type",
      "base": [
        "SpecimenDefinition"
      ],
      "type": "token",
      "description": "The type of specimen conditioned for testing"
    },
    {
      "name": "udi-carrier-hrf",
      "expression": "Device.udiCarrier.carrierHRF",
      "base": [
        "Device"
      ],
      "type": "string",
      "description": "UDI Barcode (RFID or other technology) string in *HRF* format."
    },
    {
      "name": "udi-di",
      "expression": "Device.udiCarrier.deviceIdentifier",
      "base": [
        "Device"
      ],
      "type": "string",
      "description": "The udi Device Identifier (DI)"
    },
    {
      "name": "url",
      "expression": "Composition.url",
      "base": [
        "Composition"
      ],
      "type": "uri",
      "description": "The uri that identifies the activity definition"
    },
    {
      "name": "url",
      "expression": "Contract.url",
      "base": [
        "Contract"
      ],
      "type": "uri",
      "description": "The basal contract definition"
    },
    {
      "name": "url",
      "expression": "Subscription.endpoint",
      "base": [
        "Subscription"
      ],
      "type": "uri",
      "description": "The uri that will receive the notifications"
    },
    {
      "name": "use",
      "expression": "Claim.use",
      "base": [
        "Claim"
      ],
      "type": "token",
      "description": "The kind of financial resource"
    },
    {
      "name": "use",
      "expression": "ClaimResponse.use",
      "base": [
        "ClaimResponse"
      ],
      "type": "token",
      "description": "The type of claim"
    },
    {
      "name": "vaccine-code",
      "expression": "Immunization.vaccineCode",
      "base": [
        "Immunization"
      ],
      "type": "token",
      "description": "Vaccine Product Administered"
    },
    {
      "name": "vaccine-type",
      "expression": "ImmunizationRecommendation.recommendation.vaccineCode",
      "base": [
        "ImmunizationRecommendation"
      ],
      "type": "token",
      "description": "Vaccine  or vaccine group recommendation applies to"
    },
    {
      "name": "validator-organization",
      "expression": "VerificationResult.validator.organization",
      "base": [
        "VerificationResult"
      ],
      "type": "reference",
      "description": "Select validation information for data that was validated by the specified organization"
    },
    {
      "name": "value",
      "expression": "(Group.characteristic.value.ofType(CodeableConcept)) | (Group.characteristic.value.ofType(boolean))",
      "base": [
        "Group"
      ],
      "type": "token",
      "description": "Value held by characteristic"
    },
    {
      "name": "value",
      "expression": "NamingSystem.uniqueId.value",
      "base": [
        "NamingSystem"
      ],
      "type": "string",
      "description": "The unique identifier"
    },
    {
      "name": "value-concept",
      "expression": "Observation.value.ofType(CodeableConcept)",
      "base": [
        "Observation"
      ],
      "type": "token",
      "description": "The value of the observation, if the value is a CodeableConcept"
    },
    {
      "name": "value-date",
      "expression": "Observation.value.ofType(dateTime) | Observation.value.ofType(Period)",
      "base": [
        "Observation"
      ],
      "type": "date",
      "description": "The value of the observation, if the value is a date or period of time"
    },
    {
      "name": "value-quantity",
      "expression": "Observation.value.ofType(Quantity) | Observation.value.ofType(SampledData)",
      "base": [
        "Observation"
      ],
      "type": "quantity",
      "description": "The value of the observation, if the value is a Quantity, or a SampledData (just search on the bounds of the values in sampled data)"
    },
    {
      "name": "value-reference",
      "expression": "Observation.value.ofType(Reference)",
      "base": [
        "Observation"
      ],
      "type": "reference",
      "description": "Reference contained in valueReference."
    },
    {
      "name": "value-string",
      "expression": "value.ofType(string)",
      "base": [
        "Observation"
      ],
      "type": "string",
      "description": "String in valueString."
    },
    {
      "name": "valueset",
      "expression": "StructureDefinition.snapshot.element.binding.valueSet",
      "base": [
        "StructureDefinition"
      ],
      "type": "reference",
      "description": "A vocabulary binding reference"
    },
    {
      "name": "verification-status",
      "expression": "AllergyIntolerance.verificationStatus",
      "base": [
        "AllergyIntolerance"
      ],
      "type": "token",
      "description": "unconfirmed | presumed | confirmed | refuted | entered-in-error"
    },
    {
      "name": "verification-status",
      "expression": "Condition.verificationStatus",
      "base": [
        "Condition"
      ],
      "type": "token",
      "description": "unconfirmed | provisional | differential | confirmed | refuted | entered-in-error"
    },
    {
      "name": "verified",
      "expression": "Consent.verification.verified",
      "base": [
        "Consent"
      ],
      "type": "token",
      "description": "Has been verified"
    },
    {
      "name": "verified-date",
      "expression": "Consent.verification.verificationDate",
      "base": [
        "Consent"
      ],
      "type": "date",
      "description": "When consent verified"
    },
    {
      "name": "version",
      "expression": "ActivityDefinition.version | ActorDefinition.version | CapabilityStatement.version | ChargeItemDefinition.version | Citation.version | CodeSystem.version | CompartmentDefinition.version | ConceptMap.version | ConditionDefinition.version | DeviceDefinition.deviceVersion.value | EventDefinition.version | Evidence.version | EvidenceVariable.version | ExampleScenario.version | GraphDefinition.version | ImplementationGuide.version | Library.version | Measure.version | MessageDefinition.version | NamingSystem.version | OperationDefinition.version | PlanDefinition.version | Questionnaire.version | Requirements.version | SearchParameter.version | StructureDefinition.version | StructureMap.version | SubscriptionTopic.version | TerminologyCapabilities.version | TestPlan.version | TestScript.version | ValueSet.version",
      "base": [
        "ActivityDefinition",
        "ActorDefinition",
        "CapabilityStatement",
        "ChargeItemDefinition",
        "Citation",
        "CodeSystem",
        "CompartmentDefinition",
        "ConceptMap",
        "ConditionDefinition",
        "DeviceDefinition",
        "EventDefinition",
        "Evidence",
        "EvidenceVariable",
        "ExampleScenario",
        "GraphDefinition",
        "ImplementationGuide",
        "Library",
        "Measure",
        "MessageDefinition",
        "NamingSystem",
        "OperationDefinition",
        "PlanDefinition",
        "Questionnaire",
        "Requirements",
        "SearchParameter",
        "StructureDefinition",
        "StructureMap",
        "SubscriptionTopic",
        "TerminologyCapabilities",
        "TestPlan",
        "TestScript",
        "ValueSet"
      ],
      "type": "token",
      "description": "Multiple Resources: \r\n\r\n* [ActivityDefinition](activitydefinition.html): The business version of the activity definition\r\n* [ActorDefinition](actordefinition.html): The business version of the Actor Definition\r\n* [CapabilityStatement](capabilitystatement.html): The business version of the capability statement\r\n* [ChargeItemDefinition](chargeitemdefinition.html): The business version of the charge item definition\r\n* [Citation](citation.html): The business version of the citation\r\n* [CodeSystem](codesystem.html): The business version of the code system\r\n* [CompartmentDefinition](compartmentdefinition.html): The business version of the compartment definition\r\n* [ConceptMap](conceptmap.html): The business version of the concept map\r\n* [ConditionDefinition](conditiondefinition.html): The business version of the condition definition\r\n* [DeviceDefinition](devicedefinition.html): The specific version of the device\r\n* [EventDefinition](eventdefinition.html): The business version of the event definition\r\n* [Evidence](evidence.html): The business version of the evidence\r\n* [EvidenceVariable](evidencevariable.html): The business version of the evidence variable\r\n* [ExampleScenario](examplescenario.html): The business version of the example scenario\r\n* [GraphDefinition](graphdefinition.html): The business version of the graph definition\r\n* [ImplementationGuide](implementationguide.html): The business version of the implementation guide\r\n* [Library](library.html): The business version of the library\r\n* [Measure](measure.html): The business version of the measure\r\n* [MessageDefinition](messagedefinition.html): The business version of the message definition\r\n* [NamingSystem](namingsystem.html): The business version of the naming system\r\n* [OperationDefinition](operationdefinition.html): The business version of the operation definition\r\n* [PlanDefinition](plandefinition.html): The business version of the plan definition\r\n* [Questionnaire](questionnaire.html): The business version of the questionnaire\r\n* [Requirements](requirements.html): The business version of the requirements\r\n* [SearchParameter](searchparameter.html): The business version of the search parameter\r\n* [StructureDefinition](structuredefinition.html): The business version of the structure definition\r\n* [StructureMap](structuremap.html): The business version of the structure map\r\n* [SubscriptionTopic](subscriptiontopic.html): Business version of the SubscriptionTopic\r\n* [TerminologyCapabilities](terminologycapabilities.html): The business version of the terminology capabilities\r\n* [TestPlan](testplan.html): The business version of the test script\r\n* [TestScript](testscript.html): The business version of the test script\r\n* [ValueSet](valueset.html): The business version of the value set\r\n"
    },
    {
      "name": "version",
      "expression": "Composition.version",
      "base": [
        "Composition"
      ],
      "type": "token",
      "description": "The business version of the activity definition"
    },
    {
      "name": "version",
      "expression": "Device.deviceVersion.value",
      "base": [
        "Device"
      ],
      "type": "string",
      "description": "The specific version of the device"
    },
    {
      "name": "version",
      "expression": "DocumentReference.version",
      "base": [
        "DocumentReference"
      ],
      "type": "string",
      "description": "The business version identifier"
    },
    {
      "name": "version-type",
      "expression": "Device.deviceVersion",
      "base": [
        "Device"
      ],
      "type": "composite",
      "description": "Value and type of version"
    },
    {
      "name": "version-type",
      "expression": "DeviceDefinition.deviceVersion",
      "base": [
        "DeviceDefinition"
      ],
      "type": "composite",
      "description": "Value and type of version"
    },
    {
      "name": "whenhandedover",
      "expression": "MedicationDispense.whenHandedOver",
      "base": [
        "MedicationDispense"
      ],
      "type": "date",
      "description": "Returns dispenses handed over on this date"
    },
    {
      "name": "whenprepared",
      "expression": "MedicationDispense.whenPrepared",
      "base": [
        "MedicationDispense"
      ],
      "type": "date",
      "description": "Returns dispenses prepared on this date"
    }
  ],
  "uniqueExpressions": [
    "(ActivityDefinition.useContext.value.ofType(Quantity)) | (ActivityDefinition.useContext.value.ofType(Range)) | (ActorDefinition.useContext.value.ofType(Quantity)) | (ActorDefinition.useContext.value.ofType(Range)) | (CapabilityStatement.useContext.value.ofType(Quantity)) | (CapabilityStatement.useContext.value.ofType(Range)) | (ChargeItemDefinition.useContext.value.ofType(Quantity)) | (ChargeItemDefinition.useContext.value.ofType(Range)) | (Citation.useContext.value.ofType(Quantity)) | (Citation.useContext.value.ofType(Range)) | (CodeSystem.useContext.value.ofType(Quantity)) | (CodeSystem.useContext.value.ofType(Range)) | (CompartmentDefinition.useContext.value.ofType(Quantity)) | (CompartmentDefinition.useContext.value.ofType(Range)) | (ConceptMap.useContext.value.ofType(Quantity)) | (ConceptMap.useContext.value.ofType(Range)) | (ConditionDefinition.useContext.value.ofType(Quantity)) | (ConditionDefinition.useContext.value.ofType(Range)) | (EventDefinition.useContext.value.ofType(Quantity)) | (EventDefinition.useContext.value.ofType(Range)) | (Evidence.useContext.value.ofType(Quantity)) | (Evidence.useContext.value.ofType(Range)) | (EvidenceVariable.useContext.value.ofType(Quantity)) | (EvidenceVariable.useContext.value.ofType(Range)) | (ExampleScenario.useContext.value.ofType(Quantity)) | (ExampleScenario.useContext.value.ofType(Range)) | (GraphDefinition.useContext.value.ofType(Quantity)) | (GraphDefinition.useContext.value.ofType(Range)) | (ImplementationGuide.useContext.value.ofType(Quantity)) | (ImplementationGuide.useContext.value.ofType(Range)) | (Library.useContext.value.ofType(Quantity)) | (Library.useContext.value.ofType(Range)) | (Measure.useContext.value.ofType(Quantity)) | (Measure.useContext.value.ofType(Range)) | (MessageDefinition.useContext.value.ofType(Quantity)) | (MessageDefinition.useContext.value.ofType(Range)) | (NamingSystem.useContext.value.ofType(Quantity)) | (NamingSystem.useContext.value.ofType(Range)) | (OperationDefinition.useContext.value.ofType(Quantity)) | (OperationDefinition.useContext.value.ofType(Range)) | (PlanDefinition.useContext.value.ofType(Quantity)) | (PlanDefinition.useContext.value.ofType(Range)) | (Questionnaire.useContext.value.ofType(Quantity)) | (Questionnaire.useContext.value.ofType(Range)) | (Requirements.useContext.value.ofType(Quantity)) | (Requirements.useContext.value.ofType(Range)) | (SearchParameter.useContext.value.ofType(Quantity)) | (SearchParameter.useContext.value.ofType(Range)) | (StructureDefinition.useContext.value.ofType(Quantity)) | (StructureDefinition.useContext.value.ofType(Range)) | (StructureMap.useContext.value.ofType(Quantity)) | (StructureMap.useContext.value.ofType(Range)) | (TerminologyCapabilities.useContext.value.ofType(Quantity)) | (TerminologyCapabilities.useContext.value.ofType(Range)) | (TestPlan.useContext.value.ofType(Quantity)) | (TestPlan.useContext.value.ofType(Range)) | (TestScript.useContext.value.ofType(Quantity)) | (TestScript.useContext.value.ofType(Range)) | (ValueSet.useContext.value.ofType(Quantity)) | (ValueSet.useContext.value.ofType(Range))",
    "(Citation.classification.classifier)",
    "(Citation.classification.type)",
    "(ConceptMap.sourceScope as canonical)",
    "(ConceptMap.targetScope as canonical)",
    "(ConceptMap.targetScope as uri)",
    "(DeviceRequest.occurrence.ofType(dateTime)) | (DeviceRequest.occurrence.ofType(Period))",
    "(DocumentReference.content.profile.value.ofType(Coding))",
    "(DocumentReference.content.profile.value.ofType(canonical))",
    "(DocumentReference.content.profile.value.ofType(uri))",
    "(Goal.start.ofType(date))",
    "(Goal.target.due.ofType(date))",
    "(Group.characteristic.value.ofType(CodeableConcept)) | (Group.characteristic.value.ofType(boolean))",
    "(NutritionIntake.reported as Reference)",
    "(Patient.deceased.ofType(dateTime))",
    "(Person.deceased.ofType(dateTime))",
    "(Practitioner.deceased.ofType(dateTime))",
    "Account.guarantor.account",
    "Account.guarantor.party",
    "Account.name",
    "Account.owner",
    "Account.servicePeriod",
    "Account.status",
    "Account.subject",
    "Account.type | AllergyIntolerance.type | Composition.type | Coverage.type | DocumentReference.type | Encounter.type | EpisodeOfCare.type | Invoice.type | MedicationDispense.type | MolecularSequence.type | Specimen.type",
    "ActivityDefinition.date | ActorDefinition.date | CapabilityStatement.date | ChargeItemDefinition.date | Citation.date | CodeSystem.date | CompartmentDefinition.date | ConceptMap.date | ConditionDefinition.date | EventDefinition.date | Evidence.date | EvidenceVariable.date | ExampleScenario.date | GraphDefinition.date | ImplementationGuide.date | Library.date | Measure.date | MessageDefinition.date | NamingSystem.date | OperationDefinition.date | PlanDefinition.date | Questionnaire.date | Requirements.date | SearchParameter.date | StructureDefinition.date | StructureMap.date | SubscriptionTopic.date | TerminologyCapabilities.date | TestPlan.date | TestScript.date | ValueSet.date",
    "ActivityDefinition.effectivePeriod | ChargeItemDefinition.applicability.effectivePeriod | Citation.effectivePeriod | CodeSystem.effectivePeriod | ConceptMap.effectivePeriod | EventDefinition.effectivePeriod | Library.effectivePeriod | Measure.effectivePeriod | NamingSystem.effectivePeriod | PlanDefinition.effectivePeriod | Questionnaire.effectivePeriod | ValueSet.effectivePeriod",
    "ActivityDefinition.identifier | ActorDefinition.identifier | CapabilityStatement.identifier | ChargeItemDefinition.identifier | Citation.identifier | CodeSystem.identifier | ConceptMap.identifier | ConditionDefinition.identifier | DeviceDefinition.identifier | DeviceDefinition.udiDeviceIdentifier | EventDefinition.identifier | Evidence.identifier | EvidenceVariable.identifier | ExampleScenario.identifier | GraphDefinition.identifier | Group.identifier | ImplementationGuide.identifier | Library.identifier | Measure.identifier | MedicationKnowledge.identifier | MessageDefinition.identifier | NamingSystem.identifier | ObservationDefinition.identifier | OperationDefinition.identifier | PlanDefinition.identifier | Questionnaire.identifier | Requirements.identifier | SearchParameter.identifier | SpecimenDefinition.identifier | StructureDefinition.identifier | StructureMap.identifier | SubscriptionTopic.identifier | TerminologyCapabilities.identifier | TestPlan.identifier | TestScript.identifier | ValueSet.identifier",
    "ActivityDefinition.kind",
    "ActivityDefinition.name | CapabilityStatement.name | Citation.name | CodeSystem.name | CompartmentDefinition.name | ConceptMap.name | ConditionDefinition.name | EventDefinition.name | EvidenceVariable.name | ExampleScenario.name | GraphDefinition.name | Group.name | ImplementationGuide.name | Library.name | Measure.name | MessageDefinition.name | NamingSystem.name | OperationDefinition.name | PlanDefinition.name | Questionnaire.name | Requirements.name | SearchParameter.name | StructureDefinition.name | StructureMap.name | TerminologyCapabilities.name | TestPlan.name | TestScript.name | ValueSet.name",
    "ActivityDefinition.relatedArtifact.where(type='depends-on').resource | ActivityDefinition.library | EventDefinition.relatedArtifact.where(type='depends-on').resource | Library.relatedArtifact.where(type='depends-on').resource | Measure.relatedArtifact.where(type='depends-on').resource | Measure.library | PlanDefinition.relatedArtifact.where(type='depends-on').resource | PlanDefinition.library",
    "ActivityDefinition.relatedArtifact.where(type='derived-from').resource | CodeSystem.relatedArtifact.where(type='derived-from').resource | ConceptMap.relatedArtifact.where(type='derived-from').resource | EventDefinition.relatedArtifact.where(type='derived-from').resource | Library.relatedArtifact.where(type='derived-from').resource | Measure.relatedArtifact.where(type='derived-from').resource | NamingSystem.relatedArtifact.where(type='derived-from').resource | PlanDefinition.relatedArtifact.where(type='derived-from').resource | ValueSet.relatedArtifact.where(type='derived-from').resource",
    "ActivityDefinition.relatedArtifact.where(type='predecessor').resource | CodeSystem.relatedArtifact.where(type='predecessor').resource | ConceptMap.relatedArtifact.where(type='predecessor').resource | EventDefinition.relatedArtifact.where(type='predecessor').resource | Library.relatedArtifact.where(type='predecessor').resource | Measure.relatedArtifact.where(type='predecessor').resource | NamingSystem.relatedArtifact.where(type='predecessor').resource | PlanDefinition.relatedArtifact.where(type='predecessor').resource | ValueSet.relatedArtifact.where(type='predecessor').resource",
    "ActivityDefinition.status | ActorDefinition.status | CapabilityStatement.status | ChargeItemDefinition.status | Citation.status | CodeSystem.status | CompartmentDefinition.status | ConceptMap.status | ConditionDefinition.status | EventDefinition.status | Evidence.status | EvidenceVariable.status | ExampleScenario.status | GraphDefinition.status | Group.status | ImplementationGuide.status | Library.status | Measure.status | MedicationKnowledge.status | MessageDefinition.status | NamingSystem.status | ObservationDefinition.status | OperationDefinition.status | PlanDefinition.status | Questionnaire.status | Requirements.status | SearchParameter.status | SpecimenDefinition.status | StructureDefinition.status | StructureMap.status | SubscriptionTopic.status | TerminologyCapabilities.status | TestPlan.status | TestScript.status | ValueSet.status",
    "ActivityDefinition.subject as CodeableConcept",
    "ActivityDefinition.subject as Reference",
    "ActivityDefinition.subject as canonical",
    "ActivityDefinition.title | ActorDefinition.title | CapabilityStatement.title | ChargeItemDefinition.title | Citation.title | CodeSystem.title | ConceptMap.title | ConditionDefinition.title | EventDefinition.title | Evidence.title | EvidenceVariable.title | ImplementationGuide.title | Library.title | Measure.title | MessageDefinition.title | ObservationDefinition.title | OperationDefinition.title | PlanDefinition.title | Questionnaire.title | Requirements.title | SpecimenDefinition.title | StructureDefinition.title | StructureMap.title | SubscriptionTopic.title | TerminologyCapabilities.title | TestPlan.title | TestScript.title | ValueSet.title",
    "ActivityDefinition.topic | CodeSystem.topic | ConceptMap.topic | EventDefinition.topic | Library.topic | Measure.topic | NamingSystem.topic | PlanDefinition.topic | ValueSet.topic",
    "ActivityDefinition.useContext | ActorDefinition.useContext | CapabilityStatement.useContext | ChargeItemDefinition.useContext | Citation.useContext | CodeSystem.useContext | CompartmentDefinition.useContext | ConceptMap.useContext | ConditionDefinition.useContext | EventDefinition.useContext | Evidence.useContext | EvidenceVariable.useContext | ExampleScenario.useContext | GraphDefinition.useContext | ImplementationGuide.useContext | Library.useContext | Measure.useContext | MessageDefinition.useContext | NamingSystem.useContext | OperationDefinition.useContext | PlanDefinition.useContext | Questionnaire.useContext | Requirements.useContext | SearchParameter.useContext | StructureDefinition.useContext | StructureMap.useContext | TerminologyCapabilities.useContext | TestPlan.useContext | TestScript.useContext | ValueSet.useContext",
    "ActivityDefinition.version | ActorDefinition.version | CapabilityStatement.version | ChargeItemDefinition.version | Citation.version | CodeSystem.version | CompartmentDefinition.version | ConceptMap.version | ConditionDefinition.version | DeviceDefinition.deviceVersion.value | EventDefinition.version | Evidence.version | EvidenceVariable.version | ExampleScenario.version | GraphDefinition.version | ImplementationGuide.version | Library.version | Measure.version | MessageDefinition.version | NamingSystem.version | OperationDefinition.version | PlanDefinition.version | Questionnaire.version | Requirements.version | SearchParameter.version | StructureDefinition.version | StructureMap.version | SubscriptionTopic.version | TerminologyCapabilities.version | TestPlan.version | TestScript.version | ValueSet.version",
    "ActorDefinition.type",
    "AdministrableProductDefinition.administrableDoseForm",
    "AdministrableProductDefinition.device",
    "AdministrableProductDefinition.formOf",
    "AdministrableProductDefinition.identifier",
    "AdministrableProductDefinition.ingredient",
    "AdministrableProductDefinition.producedFrom",
    "AdministrableProductDefinition.routeOfAdministration.code",
    "AdministrableProductDefinition.status",
    "AdverseEvent.actuality",
    "AdverseEvent.category",
    "AdverseEvent.cause.ofType(dateTime) | AdverseEvent.cause.ofType(Period)",
    "AdverseEvent.code | AllergyIntolerance.code | AllergyIntolerance.reaction.substance | Basic.code | ChargeItem.code | Condition.code | DetectedIssue.code | DeviceRequest.code.concept | DiagnosticReport.code | FamilyMemberHistory.condition.code | ImagingSelection.code | List.code | Medication.code | MedicationAdministration.medication.concept | MedicationDispense.medication.concept | MedicationRequest.medication.concept | MedicationStatement.medication.concept | NutritionIntake.code | Observation.code | Procedure.code | RequestOrchestration.code | Task.code",
    "AdverseEvent.effect.ofType(dateTime) | AdverseEvent.effect.ofType(Period)",
    "AdverseEvent.location",
    "AdverseEvent.recorder",
    "AdverseEvent.resultingEffect.concept",
    "AdverseEvent.resultingEffect.reference",
    "AdverseEvent.seriousness",
    "AdverseEvent.status",
    "AdverseEvent.subject",
    "AdverseEvent.suspectEntity.instance.reference",
    "AllergyIntolerance.asserter",
    "AllergyIntolerance.category",
    "AllergyIntolerance.clinicalStatus",
    "AllergyIntolerance.criticality",
    "AllergyIntolerance.lastReactionOccurrence",
    "AllergyIntolerance.reaction.manifestation.concept",
    "AllergyIntolerance.reaction.manifestation.reference",
    "AllergyIntolerance.reaction.severity",
    "AllergyIntolerance.recordedDate | (start | requestedPeriod.start).first() | AuditEvent.recorded | CarePlan.period | Composition.date | Consent.date | DiagnosticReport.effective.ofType(dateTime) | DiagnosticReport.effective.ofType(Period) | DocumentReference.date | Encounter.actualPeriod | EpisodeOfCare.period | FamilyMemberHistory.date | Flag.period | (Immunization.occurrence.ofType(dateTime)) | ImmunizationEvaluation.date | ImmunizationRecommendation.date | Invoice.date | List.date | MeasureReport.date | NutritionIntake.occurrence.ofType(dateTime) | NutritionIntake.occurrence.ofType(Period) | Observation.effective.ofType(dateTime) | Observation.effective.ofType(Period) | Observation.effective.ofType(Timing) | Observation.effective.ofType(instant) | Procedure.occurrence.ofType(dateTime) | Procedure.occurrence.ofType(Period) | Procedure.occurrence.ofType(Timing) | ResearchSubject.period | (RiskAssessment.occurrence.ofType(dateTime)) | SupplyRequest.authoredOn",
    "AllergyIntolerance.verificationStatus",
    "Appointment.appointmentType",
    "Appointment.basedOn",
    "Appointment.occurrenceChanged",
    "Appointment.originatingAppointment",
    "Appointment.participant.actor",
    "Appointment.participant.actor.where(resolve() is Group) | Appointment.subject.where(resolve() is Group)",
    "Appointment.participant.actor.where(resolve() is Location)",
    "Appointment.participant.actor.where(resolve() is Practitioner)",
    "Appointment.participant.status",
    "Appointment.reason.concept",
    "Appointment.reason.reference",
    "Appointment.recurrenceTemplate.exists()",
    "Appointment.recurrenceTemplate.exists() | Appointment.originatingAppointment.exists()",
    "Appointment.serviceCategory",
    "Appointment.serviceType.concept",
    "Appointment.serviceType.reference",
    "Appointment.slot",
    "Appointment.specialty",
    "Appointment.status",
    "Appointment.subject",
    "Appointment.supportingInformation",
    "AppointmentResponse.actor.where(resolve() is Group)",
    "AppointmentResponse.actor.where(resolve() is Location)",
    "AppointmentResponse.actor.where(resolve() is Practitioner)",
    "AppointmentResponse.appointment",
    "AppointmentResponse.participantStatus",
    "ArtifactAssessment.date",
    "ArtifactAssessment.identifier",
    "AuditEvent.action",
    "AuditEvent.agent.policy",
    "AuditEvent.agent.role",
    "AuditEvent.agent.who",
    "AuditEvent.authorization | AuditEvent.agent.authorization",
    "AuditEvent.basedOn",
    "AuditEvent.entity.description",
    "AuditEvent.entity.role",
    "AuditEvent.entity.what",
    "AuditEvent.outcome.code",
    "AuditEvent.source.observer",
    "AuditEvent.subtype",
    "AuditEvent.type",
    "Basic.created",
    "Basic.subject",
    "BiologicallyDerivedProduct.biologicalSourceEvent",
    "BiologicallyDerivedProduct.collection.collector",
    "BiologicallyDerivedProduct.identifier",
    "BiologicallyDerivedProduct.productCategory",
    "BiologicallyDerivedProduct.productCode",
    "BiologicallyDerivedProduct.productStatus",
    "BiologicallyDerivedProduct.request",
    "BiologicallyDerivedProductDispense.identifier",
    "BiologicallyDerivedProductDispense.performer.actor",
    "BiologicallyDerivedProductDispense.product",
    "BiologicallyDerivedProductDispense.status",
    "BodyStructure.excludedStructure.structure",
    "BodyStructure.includedStructure.structure",
    "BodyStructure.morphology",
    "Bundle.entry[0].resource",
    "Bundle.entry[0].resource as Composition",
    "Bundle.entry[0].resource as MessageHeader",
    "Bundle.identifier",
    "Bundle.timestamp",
    "Bundle.type",
    "CapabilityStatement.fhirVersion",
    "CapabilityStatement.format",
    "CapabilityStatement.implementationGuide",
    "CapabilityStatement.rest.mode",
    "CapabilityStatement.rest.resource.profile",
    "CapabilityStatement.rest.resource.supportedProfile",
    "CapabilityStatement.rest.security.service",
    "CapabilityStatement.software.name",
    "CarePlan.activity.plannedActivityReference",
    "CarePlan.addresses.reference",
    "CarePlan.basedOn",
    "CarePlan.careTeam",
    "CarePlan.category",
    "CarePlan.custodian",
    "CarePlan.goal",
    "CarePlan.intent",
    "CarePlan.partOf",
    "CarePlan.replaces",
    "CarePlan.subject",
    "CareTeam.category",
    "CareTeam.name | CareTeam.extension('http://hl7.org/fhir/StructureDefinition/careteam-alias').value",
    "CareTeam.participant.member",
    "CareTeam.status",
    "CareTeam.subject",
    "ChargeItem.account",
    "ChargeItem.enteredDate",
    "ChargeItem.enterer",
    "ChargeItem.occurrence.ofType(dateTime) | ChargeItem.occurrence.ofType(Period) | ChargeItem.occurrence.ofType(Timing)",
    "ChargeItem.performer.actor",
    "ChargeItem.performer.function",
    "ChargeItem.performingOrganization",
    "ChargeItem.quantity",
    "ChargeItem.requestingOrganization",
    "ChargeItem.service.reference",
    "ChargeItem.status",
    "ChargeItem.subject",
    "ChargeItem.totalPriceComponent.factor",
    "ChargeItemDefinition.account",
    "Citation.classification",
    "Claim.careTeam.provider",
    "Claim.created",
    "Claim.enterer",
    "Claim.insurer",
    "Claim.item.detail.subDetail.udi",
    "Claim.item.detail.udi",
    "Claim.item.udi",
    "Claim.payee.party",
    "Claim.priority",
    "Claim.procedure.udi",
    "Claim.provider",
    "Claim.status",
    "Claim.use",
    "ClaimResponse.created",
    "ClaimResponse.disposition",
    "ClaimResponse.insurer",
    "ClaimResponse.outcome",
    "ClaimResponse.payment.date",
    "ClaimResponse.request",
    "ClaimResponse.status",
    "ClaimResponse.use",
    "ClinicalAssessment.date",
    "ClinicalAssessment.encounter",
    "ClinicalAssessment.finding.item.concept",
    "ClinicalAssessment.finding.item.reference",
    "ClinicalAssessment.identifier",
    "ClinicalAssessment.performer",
    "ClinicalAssessment.previous",
    "ClinicalAssessment.problem",
    "ClinicalAssessment.status",
    "ClinicalAssessment.subject",
    "ClinicalAssessment.subject.where(resolve() is Patient)",
    "ClinicalUseDefinition.contraindication.diseaseSymptomProcedure.concept",
    "ClinicalUseDefinition.contraindication.diseaseSymptomProcedure.reference",
    "ClinicalUseDefinition.identifier",
    "ClinicalUseDefinition.indication.diseaseSymptomProcedure.concept",
    "ClinicalUseDefinition.indication.diseaseSymptomProcedure.reference",
    "ClinicalUseDefinition.interaction.type",
    "ClinicalUseDefinition.status",
    "ClinicalUseDefinition.subject.where(resolve() is MedicinalProductDefinition)",
    "ClinicalUseDefinition.type",
    "ClinicalUseDefinition.undesirableEffect.symptomConditionEffect.concept",
    "ClinicalUseDefinition.undesirableEffect.symptomConditionEffect.reference",
    "CodeSystem.concept.code",
    "CodeSystem.concept.designation.language",
    "CodeSystem.content",
    "CodeSystem.supplements",
    "CodeSystem.url",
    "Communication.basedOn",
    "Communication.category",
    "Communication.inResponseTo",
    "Communication.medium",
    "Communication.partOf",
    "Communication.reason.reference",
    "Communication.received",
    "Communication.recipient",
    "Communication.sender",
    "Communication.sent",
    "Communication.status",
    "Communication.subject",
    "Communication.topic",
    "CommunicationRequest.about",
    "CommunicationRequest.basedOn",
    "CommunicationRequest.category",
    "CommunicationRequest.groupIdentifier",
    "CommunicationRequest.informationProvider",
    "CommunicationRequest.medium",
    "CommunicationRequest.occurrence.ofType(dateTime) | CommunicationRequest.occurrence.ofType(Period)",
    "CommunicationRequest.priority",
    "CommunicationRequest.recipient",
    "CommunicationRequest.replaces",
    "CommunicationRequest.requester",
    "CommunicationRequest.status",
    "CompartmentDefinition.code",
    "CompartmentDefinition.resource.code",
    "Composition.attester.party",
    "Composition.author",
    "Composition.category",
    "Composition.event.detail.concept",
    "Composition.event.detail.reference",
    "Composition.event.period",
    "Composition.section",
    "Composition.section.entry",
    "Composition.section.text | Composition.section.section.text",
    "Composition.status",
    "Composition.subject",
    "Composition.title",
    "Composition.url",
    "Composition.version",
    "ConceptMap.group.element.code",
    "ConceptMap.group.element.target.code",
    "ConceptMap.group.source",
    "ConceptMap.group.target",
    "ConceptMap.group.unmapped.otherMap",
    "ConceptMap.property.uri",
    "Condition.abatement.ofType(Age) | Condition.abatement.ofType(Range)",
    "Condition.abatement.ofType(dateTime) | Condition.abatement.ofType(Period)",
    "Condition.abatement.ofType(string)",
    "Condition.asserter",
    "Condition.bodySite",
    "Condition.category",
    "Condition.clinicalStatus",
    "Condition.evidence.concept",
    "Condition.onset.ofType(Age) | Condition.onset.ofType(Range)",
    "Condition.onset.ofType(dateTime) | Condition.onset.ofType(Period)",
    "Condition.onset.ofType(string)",
    "Condition.recordedDate",
    "Condition.severity",
    "Condition.stage.summary",
    "Condition.subject",
    "Condition.verificationStatus",
    "Consent.category",
    "Consent.controller",
    "Consent.grantee",
    "Consent.manager",
    "Consent.provision.actor.reference",
    "Consent.provision.code",
    "Consent.provision.period",
    "Consent.provision.purpose",
    "Consent.provision.securityLabel",
    "Consent.sourceReference",
    "Consent.status",
    "Consent.subject",
    "Consent.verification.verificationDate",
    "Consent.verification.verified",
    "Contract.authority",
    "Contract.domain",
    "Contract.instantiatesUri",
    "Contract.signer.party",
    "Contract.status",
    "Contract.subject",
    "Contract.url",
    "Coverage.beneficiary",
    "Coverage.class.type",
    "Coverage.class.value",
    "Coverage.dependent",
    "Coverage.insurer",
    "Coverage.paymentBy.party",
    "Coverage.policyHolder",
    "Coverage.status",
    "Coverage.subscriberId",
    "CoverageEligibilityRequest.created",
    "CoverageEligibilityRequest.enterer",
    "CoverageEligibilityRequest.facility",
    "CoverageEligibilityRequest.provider",
    "CoverageEligibilityRequest.status",
    "CoverageEligibilityResponse.created",
    "CoverageEligibilityResponse.disposition",
    "CoverageEligibilityResponse.insurer",
    "CoverageEligibilityResponse.outcome",
    "CoverageEligibilityResponse.request",
    "CoverageEligibilityResponse.requestor",
    "CoverageEligibilityResponse.status",
    "DetectedIssue.category",
    "DetectedIssue.identified.ofType(dateTime) | DetectedIssue.identified.ofType(Period)",
    "DetectedIssue.implicated",
    "DetectedIssue.status",
    "DetectedIssue.subject",
    "Device",
    "Device.biologicalSourceEvent",
    "Device.conformsTo",
    "Device.conformsTo.specification",
    "Device.definition",
    "Device.deviceVersion",
    "Device.deviceVersion.value",
    "Device.expirationDate",
    "Device.identifier",
    "Device.location",
    "Device.manufactureDate",
    "Device.manufacturer",
    "Device.modelNumber",
    "Device.name.value | Device.type.coding.display | Device.type.text",
    "Device.parent",
    "Device.serialNumber | Device.identifier.where(type='SNO')",
    "Device.status",
    "Device.type |  Device.definition.resolve().classification.type ",
    "Device.udiCarrier.carrierHRF",
    "Device.udiCarrier.deviceIdentifier",
    "DeviceAlert.condition.code",
    "DeviceAlert.condition.presence",
    "DeviceAlert.condition.timing",
    "DeviceAlert.derivedFrom",
    "DeviceAlert.identifier",
    "DeviceAlert.priority",
    "DeviceAlert.signal.annunciator.reference",
    "DeviceAlert.signal.indication",
    "DeviceAlert.signal.manifestation",
    "DeviceAlert.signal.presence",
    "DeviceAlert.source",
    "DeviceAlert.status",
    "DeviceAlert.subject.where(resolve() is Patient)",
    "DeviceAlert.type",
    "DeviceAssociation.device",
    "DeviceAssociation.identifier",
    "DeviceAssociation.operation.operator",
    "DeviceAssociation.period",
    "DeviceAssociation.relationship",
    "DeviceAssociation.status",
    "DeviceAssociation.subject",
    "DeviceDefinition.conformsTo",
    "DeviceDefinition.conformsTo.category",
    "DeviceDefinition.conformsTo.specification",
    "DeviceDefinition.deviceName.name | DeviceDefinition.classification.type.coding.display | DeviceDefinition.classification.type.text",
    "DeviceDefinition.deviceVersion",
    "DeviceDefinition.hasPart.reference",
    "DeviceDefinition.manufacturer",
    "DeviceDefinition.modelNumber",
    "DeviceDispense.device.concept",
    "DeviceDispense.identifier",
    "DeviceDispense.status",
    "DeviceDispense.subject",
    "DeviceDispense.subject.where(resolve() is Patient)",
    "DeviceMetric.category",
    "DeviceMetric.device",
    "DeviceMetric.identifier",
    "DeviceMetric.type",
    "DeviceRequest.authoredOn",
    "DeviceRequest.code.reference",
    "DeviceRequest.groupIdentifier",
    "DeviceRequest.instantiatesCanonical",
    "DeviceRequest.instantiatesUri",
    "DeviceRequest.insurance",
    "DeviceRequest.intent",
    "DeviceRequest.performer.concept",
    "DeviceRequest.performer.reference",
    "DeviceRequest.replaces",
    "DeviceRequest.requester",
    "DeviceRequest.subject",
    "DeviceUsage.device.concept",
    "DeviceUsage.status",
    "DiagnosticReport.basedOn",
    "DiagnosticReport.category",
    "DiagnosticReport.conclusionCode.concept",
    "DiagnosticReport.conclusionCode.reference",
    "DiagnosticReport.issued",
    "DiagnosticReport.media.link",
    "DiagnosticReport.performer",
    "DiagnosticReport.procedure",
    "DiagnosticReport.result",
    "DiagnosticReport.resultsInterpreter",
    "DiagnosticReport.specimen",
    "DiagnosticReport.study",
    "DiagnosticReport.subject",
    "DocumentReference.attester.party",
    "DocumentReference.author",
    "DocumentReference.basedOn",
    "DocumentReference.bodySite.concept",
    "DocumentReference.bodySite.reference",
    "DocumentReference.category",
    "DocumentReference.content.attachment.contentType",
    "DocumentReference.content.attachment.creation",
    "DocumentReference.content.attachment.language",
    "DocumentReference.content.attachment.url",
    "DocumentReference.context",
    "DocumentReference.custodian",
    "DocumentReference.description",
    "DocumentReference.event.concept",
    "DocumentReference.event.reference",
    "DocumentReference.facilityType",
    "DocumentReference.modality",
    "DocumentReference.period",
    "DocumentReference.practiceSetting",
    "DocumentReference.relatesTo",
    "DocumentReference.relatesTo.code",
    "DocumentReference.relatesTo.target",
    "DocumentReference.securityLabel",
    "DocumentReference.status",
    "DocumentReference.subject",
    "DocumentReference.version",
    "Encounter.account",
    "Encounter.actualPeriod.end",
    "Encounter.actualPeriod.start",
    "Encounter.appointment",
    "Encounter.careTeam",
    "Encounter.class",
    "Encounter.diagnosis.condition.concept",
    "Encounter.diagnosis.condition.reference",
    "Encounter.episodeOfCare",
    "Encounter.length",
    "Encounter.location",
    "Encounter.location.location",
    "Encounter.location.period",
    "Encounter.partOf",
    "Encounter.participant.actor",
    "Encounter.participant.actor.where(resolve() is Practitioner)",
    "Encounter.participant.type",
    "Encounter.reason.value.reference",
    "Encounter.serviceProvider",
    "Encounter.specialArrangement",
    "Encounter.status",
    "Encounter.subject",
    "Encounter.subjectStatus",
    "EncounterHistory.identifier",
    "EncounterHistory.status",
    "EncounterHistory.subject",
    "EncounterHistory.subject.where(resolve() is Patient)",
    "Endpoint.connectionType",
    "Endpoint.identifier",
    "Endpoint.name",
    "Endpoint.payload.type",
    "Endpoint.status",
    "EnrollmentRequest.candidate",
    "EnrollmentRequest.status",
    "EnrollmentResponse.identifier",
    "EnrollmentResponse.request",
    "EnrollmentResponse.status",
    "EpisodeOfCare.careManager.where(resolve() is Practitioner)",
    "EpisodeOfCare.diagnosis.condition.concept",
    "EpisodeOfCare.diagnosis.condition.reference",
    "EpisodeOfCare.managingOrganization",
    "EpisodeOfCare.reason.value.concept",
    "EpisodeOfCare.reason.value.reference",
    "EpisodeOfCare.referralRequest",
    "EpisodeOfCare.subject",
    "ExplanationOfBenefit.careTeam.provider",
    "ExplanationOfBenefit.claim",
    "ExplanationOfBenefit.created",
    "ExplanationOfBenefit.disposition",
    "ExplanationOfBenefit.enterer",
    "ExplanationOfBenefit.facility",
    "ExplanationOfBenefit.insurance.coverage",
    "ExplanationOfBenefit.item.detail.subDetail.udi",
    "ExplanationOfBenefit.item.detail.udi",
    "ExplanationOfBenefit.item.udi",
    "ExplanationOfBenefit.payee.party",
    "ExplanationOfBenefit.procedure.udi",
    "ExplanationOfBenefit.provider",
    "FamilyMemberHistory.relationship",
    "FamilyMemberHistory.sex",
    "FamilyMemberHistory.status",
    "Flag.author",
    "Flag.category",
    "Flag.status",
    "Flag.subject",
    "FormularyItem.code",
    "FormularyItem.identifier",
    "GenomicStudy.analysis.focus",
    "GenomicStudy.identifier",
    "GenomicStudy.status",
    "GenomicStudy.subject",
    "Goal.achievementStatus",
    "Goal.addresses",
    "Goal.category",
    "Goal.description",
    "Goal.lifecycleStatus",
    "Goal.subject",
    "Goal.target.measure",
    "GraphDefinition.start",
    "Group.characteristic",
    "Group.characteristic.code",
    "Group.characteristic.exclude",
    "Group.code",
    "Group.managingEntity",
    "Group.member.entity",
    "Group.membership",
    "Group.type",
    "GuidanceResponse.requestIdentifier",
    "GuidanceResponse.status",
    "GuidanceResponse.subject",
    "HealthcareService.active",
    "HealthcareService.category",
    "HealthcareService.characteristic",
    "HealthcareService.coverageArea",
    "HealthcareService.eligibility.code",
    "HealthcareService.endpoint",
    "HealthcareService.identifier",
    "HealthcareService.location",
    "HealthcareService.name",
    "HealthcareService.offeredIn",
    "HealthcareService.program",
    "HealthcareService.providedBy",
    "HealthcareService.specialty",
    "HealthcareService.type",
    "ImagingSelection.basedOn",
    "ImagingSelection.bodySite.concept",
    "ImagingSelection.category",
    "ImagingSelection.derivedFrom",
    "ImagingSelection.issued",
    "ImagingSelection.status",
    "ImagingSelection.studyUid",
    "ImagingSelection.subject",
    "ImagingStudy.basedOn",
    "ImagingStudy.endpoint | ImagingStudy.series.endpoint",
    "ImagingStudy.reason.reference",
    "ImagingStudy.referrer",
    "ImagingStudy.series.bodySite.concept",
    "ImagingStudy.series.bodySite.reference",
    "ImagingStudy.series.instance.sopClass",
    "ImagingStudy.series.instance.uid",
    "ImagingStudy.series.modality",
    "ImagingStudy.series.performer.actor",
    "ImagingStudy.series.uid",
    "ImagingStudy.started",
    "ImagingStudy.status",
    "ImagingStudy.subject",
    "Immunization.encounter",
    "Immunization.location",
    "Immunization.lotNumber",
    "Immunization.manufacturer.reference",
    "Immunization.performer.actor",
    "Immunization.protocolApplied.series",
    "Immunization.protocolApplied.targetDisease",
    "Immunization.reaction.date",
    "Immunization.reaction.manifestation.reference",
    "Immunization.reason.concept",
    "Immunization.status",
    "Immunization.statusReason",
    "Immunization.vaccineCode",
    "ImmunizationEvaluation.doseStatus",
    "ImmunizationEvaluation.immunizationEvent",
    "ImmunizationEvaluation.status",
    "ImmunizationEvaluation.targetDisease",
    "ImmunizationRecommendation.recommendation.forecastStatus",
    "ImmunizationRecommendation.recommendation.supportingPatientInformation",
    "ImmunizationRecommendation.recommendation.targetDisease",
    "ImmunizationRecommendation.recommendation.vaccineCode",
    "ImplementationGuide.definition.resource.reference",
    "ImplementationGuide.dependsOn.uri",
    "ImplementationGuide.experimental",
    "ImplementationGuide.global.profile",
    "Ingredient.for",
    "Ingredient.function",
    "Ingredient.identifier",
    "Ingredient.manufacturer.manufacturer",
    "Ingredient.role",
    "Ingredient.substance.code.concept",
    "Ingredient.substance.code.reference",
    "Ingredient.substance.strength.concentration.ofType(Quantity)",
    "Ingredient.substance.strength.concentration.ofType(Ratio)",
    "Ingredient.substance.strength.concentration.ofType(Ratio).denominator",
    "Ingredient.substance.strength.concentration.ofType(Ratio).numerator",
    "Ingredient.substance.strength.presentation.ofType(Quantity)",
    "Ingredient.substance.strength.presentation.ofType(Ratio)",
    "Ingredient.substance.strength.presentation.ofType(Ratio).denominator",
    "Ingredient.substance.strength.presentation.ofType(Ratio).numerator",
    "InsurancePlan.coverageArea",
    "InsurancePlan.network",
    "InsurancePlan.product",
    "InsurancePlan.type",
    "InsuranceProduct.administeredBy",
    "InsuranceProduct.contact.address",
    "InsuranceProduct.contact.address.city",
    "InsuranceProduct.contact.address.country",
    "InsuranceProduct.contact.address.postalCode",
    "InsuranceProduct.contact.address.state",
    "InsuranceProduct.contact.address.use",
    "InsuranceProduct.endpoint",
    "InsuranceProduct.identifier",
    "InsuranceProduct.name",
    "InsuranceProduct.name | InsuranceProduct.alias",
    "InsuranceProduct.status",
    "InsuranceProduct.type",
    "InventoryItem.code",
    "InventoryItem.identifier",
    "InventoryItem.instance.subject",
    "InventoryItem.status",
    "InventoryReport.identifier",
    "InventoryReport.inventoryListing.item.item.concept",
    "InventoryReport.inventoryListing.item.item.reference",
    "InventoryReport.status",
    "Invoice.account",
    "Invoice.issuer",
    "Invoice.participant.role",
    "Invoice.recipient",
    "Invoice.status",
    "Invoice.subject",
    "Invoice.totalGross",
    "Invoice.totalNet",
    "Library.content.contentType",
    "Library.subject as CodeableConcept",
    "Library.subject as Reference",
    "Library.subject as canonical",
    "Library.type",
    "Linkage.author",
    "Linkage.item.resource",
    "List.emptyReason",
    "List.entry.item",
    "List.note.text",
    "List.source",
    "List.status",
    "List.subject",
    "List.title",
    "Location.address.city",
    "Location.address.country",
    "Location.address.postalCode",
    "Location.address.state",
    "Location.address.use",
    "Location.endpoint",
    "Location.extension('http://hl7.org/fhir/StructureDefinition/location-boundary-geojson').value",
    "Location.form",
    "Location.identifier",
    "Location.mode",
    "Location.name | Location.alias",
    "Location.operationalStatus",
    "Location.partOf",
    "Location.position",
    "Location.status",
    "Location.type",
    "ManufacturedItemDefinition.identifier",
    "ManufacturedItemDefinition.ingredient",
    "ManufacturedItemDefinition.manufacturedDoseForm",
    "ManufacturedItemDefinition.name",
    "ManufacturedItemDefinition.status",
    "Measure.subject as CodeableConcept",
    "Measure.subject as Reference",
    "Measure.subject as canonical",
    "MeasureReport.location",
    "MeasureReport.measure",
    "MeasureReport.period",
    "MeasureReport.reporter",
    "MeasureReport.status",
    "MeasureReport.subject",
    "Medication.batch.expirationDate",
    "Medication.batch.lotNumber",
    "Medication.doseForm",
    "Medication.identifier",
    "Medication.ingredient.item.concept",
    "Medication.ingredient.item.reference",
    "Medication.marketingAuthorizationHolder",
    "Medication.status",
    "MedicationAdministration.device.reference",
    "MedicationAdministration.encounter | MedicationRequest.encounter",
    "MedicationAdministration.medication.reference | MedicationDispense.medication.reference | MedicationRequest.medication.reference | MedicationStatement.medication.reference",
    "MedicationAdministration.performer.actor.concept",
    "MedicationAdministration.performer.actor.reference",
    "MedicationAdministration.reason.concept",
    "MedicationAdministration.reason.reference",
    "MedicationAdministration.request",
    "MedicationAdministration.status | MedicationDispense.status | MedicationRequest.status | MedicationStatement.status",
    "MedicationAdministration.statusReason",
    "MedicationAdministration.subject",
    "MedicationDispense.authorizingPrescription",
    "MedicationDispense.destination",
    "MedicationDispense.performer.actor",
    "MedicationDispense.receiver",
    "MedicationDispense.recorded",
    "MedicationDispense.subject",
    "MedicationDispense.substitution.responsibleParty",
    "MedicationDispense.whenHandedOver",
    "MedicationDispense.whenPrepared",
    "MedicationKnowledge.code",
    "MedicationKnowledge.cost.source",
    "MedicationKnowledge.definitional.doseForm",
    "MedicationKnowledge.definitional.ingredient.item.reference",
    "MedicationKnowledge.medicineClassification.type",
    "MedicationKnowledge.monitoringProgram.name",
    "MedicationKnowledge.monitoringProgram.type",
    "MedicationKnowledge.monograph.source",
    "MedicationKnowledge.monograph.type",
    "MedicationKnowledge.packaging.cost.cost as CodeableConcept",
    "MedicationKnowledge.packaging.cost.cost as Quantity",
    "MedicationKnowledge.productType",
    "MedicationRequest.authoredOn",
    "MedicationRequest.category",
    "MedicationRequest.dosageInstruction.timing.event | (MedicationRequest.dosageInstruction.timing.repeat.bounds.ofType(Period))",
    "MedicationRequest.groupIdentifier",
    "MedicationRequest.groupIdentifier | MedicationRequest.identifier",
    "MedicationRequest.intent",
    "MedicationRequest.performer",
    "MedicationRequest.performerType",
    "MedicationRequest.priority",
    "MedicationRequest.requester",
    "MedicationRequest.subject",
    "MedicationStatement.adherence.code",
    "MedicationStatement.category",
    "MedicationStatement.effective.ofType(dateTime) | MedicationStatement.effective.ofType(Period)",
    "MedicationStatement.informationSource",
    "MedicationStatement.subject",
    "MedicinalProductDefinition.characteristic.type",
    "MedicinalProductDefinition.characteristic.value.ofType(Quantity) | MedicinalProductDefinition.characteristic.value.ofType(CodeableConcept)",
    "MedicinalProductDefinition.classification",
    "MedicinalProductDefinition.domain",
    "MedicinalProductDefinition.identifier",
    "MedicinalProductDefinition.ingredient",
    "MedicinalProductDefinition.masterFile",
    "MedicinalProductDefinition.name.productName",
    "MedicinalProductDefinition.name.usage.language",
    "MedicinalProductDefinition.status",
    "MedicinalProductDefinition.type",
    "MessageDefinition.category",
    "MessageDefinition.event.ofType(Coding)",
    "MessageDefinition.focus.code",
    "MessageHeader.destination.receiver",
    "MessageHeader.event.ofType(Coding) | MessageHeader.event.ofType(canonical)",
    "MessageHeader.focus",
    "MessageHeader.response.code",
    "MessageHeader.response.identifier",
    "MessageHeader.source.name",
    "MessageHeader.source.sender",
    "MolecularDefinition.identifier",
    "MolecularDefinition.member",
    "MolecularDefinition.moleculeType",
    "MolecularDefinition.topology",
    "MolecularDefinition.type",
    "NamingSystem.contact.telecom",
    "NamingSystem.kind",
    "NamingSystem.responsible",
    "NamingSystem.type",
    "NamingSystem.uniqueId.period",
    "NamingSystem.uniqueId.type",
    "NamingSystem.uniqueId.value",
    "NutritionIntake.nutritionItem.nutritionProduct.concept",
    "NutritionIntake.status",
    "NutritionIntake.subject",
    "NutritionOrder.additive.modularType.concept",
    "NutritionOrder.dateTime",
    "NutritionOrder.enteralFormula.type.concept",
    "NutritionOrder.oralDiet.type",
    "NutritionOrder.requester",
    "NutritionOrder.status",
    "NutritionOrder.subject",
    "NutritionOrder.supplement.type.concept",
    "NutritionProduct.category",
    "NutritionProduct.code",
    "NutritionProduct.ingredient.item.concept",
    "NutritionProduct.instance.expiry",
    "NutritionProduct.instance.identifier",
    "NutritionProduct.instance.lotNumber",
    "Observation",
    "Observation | Observation.component",
    "Observation.basedOn",
    "Observation.category",
    "Observation.component",
    "Observation.component.code",
    "Observation.component.dataAbsentReason",
    "Observation.component.interpretation",
    "Observation.component.value.ofType(CodeableConcept)",
    "Observation.component.value.ofType(Quantity) | Observation.component.value.ofType(SampledData)",
    "Observation.component.value.ofType(Reference)",
    "Observation.component.value.ofType(canonical)",
    "Observation.dataAbsentReason",
    "Observation.dataAbsentReason | Observation.component.dataAbsentReason",
    "Observation.derivedFrom",
    "Observation.focus",
    "Observation.hasMember",
    "Observation.instantiates.ofType(Reference)",
    "Observation.instantiates.ofType(canonical)",
    "Observation.interpretation",
    "Observation.interpretation | Observation.component.interpretation",
    "Observation.method",
    "Observation.partOf",
    "Observation.performer",
    "Observation.specimen",
    "Observation.status",
    "Observation.subject",
    "Observation.value.ofType(CodeableConcept)",
    "Observation.value.ofType(CodeableConcept) | Observation.component.value.ofType(CodeableConcept)",
    "Observation.value.ofType(Quantity) | Observation.value.ofType(SampledData)",
    "Observation.value.ofType(Quantity) | Observation.value.ofType(SampledData) | Observation.component.value.ofType(Quantity) | Observation.component.value.ofType(SampledData)",
    "Observation.value.ofType(Reference)",
    "Observation.value.ofType(dateTime) | Observation.value.ofType(Period)",
    "ObservationDefinition.category",
    "ObservationDefinition.code",
    "ObservationDefinition.experimental",
    "ObservationDefinition.method",
    "OperationDefinition.base",
    "OperationDefinition.code",
    "OperationDefinition.inputProfile",
    "OperationDefinition.instance",
    "OperationDefinition.kind",
    "OperationDefinition.outputProfile",
    "OperationDefinition.system",
    "OperationDefinition.type",
    "Organization.active",
    "Organization.contact.address",
    "Organization.contact.address.country",
    "Organization.contact.address.postalCode",
    "Organization.contact.address.state",
    "Organization.contact.address.use",
    "Organization.endpoint",
    "Organization.identifier | Organization.qualification.identifier",
    "Organization.name",
    "Organization.name | Organization.alias",
    "Organization.partOf",
    "Organization.type",
    "OrganizationAffiliation.active",
    "OrganizationAffiliation.code",
    "OrganizationAffiliation.contact.telecom",
    "OrganizationAffiliation.contact.telecom.where(system='email')",
    "OrganizationAffiliation.contact.telecom.where(system='phone')",
    "OrganizationAffiliation.endpoint",
    "OrganizationAffiliation.healthcareService",
    "OrganizationAffiliation.location",
    "OrganizationAffiliation.network",
    "OrganizationAffiliation.organization",
    "OrganizationAffiliation.participatingOrganization",
    "OrganizationAffiliation.period",
    "OrganizationAffiliation.specialty",
    "PackagedProductDefinition.identifier",
    "PackagedProductDefinition.name",
    "PackagedProductDefinition.packageFor",
    "PackagedProductDefinition.packaging.containedItem.item.reference",
    "PackagedProductDefinition.status",
    "Patient.active",
    "Patient.address | Person.address | Practitioner.address | RelatedPerson.address",
    "Patient.address.city | Person.address.city | Practitioner.address.city | RelatedPerson.address.city",
    "Patient.address.country | Person.address.country | Practitioner.address.country | RelatedPerson.address.country",
    "Patient.address.state | Person.address.state | Practitioner.address.state | RelatedPerson.address.state",
    "Patient.address.use | Person.address.use | Practitioner.address.use | RelatedPerson.address.use",
    "Patient.birthDate | Person.birthDate | RelatedPerson.birthDate",
    "Patient.communication.language",
    "Patient.deceased.exists() and Patient.deceased != false",
    "Patient.extension('http://example.org/fhir/StructureDefinition/participation-agreement').value",
    "Patient.gender | Person.gender | Practitioner.gender | RelatedPerson.gender",
    "Patient.generalPractitioner",
    "Patient.identifier",
    "Patient.link.other",
    "Patient.managingOrganization",
    "Patient.name",
    "Patient.name | Person.name | Practitioner.name | RelatedPerson.name",
    "Patient.name.family | Practitioner.name.family",
    "Patient.telecom | Person.telecom | Practitioner.telecom | PractitionerRole.contact.telecom | RelatedPerson.telecom",
    "Patient.telecom.where(system='email') | Person.telecom.where(system='email') | Practitioner.telecom.where(system='email') | PractitionerRole.contact.telecom.where(system='email') | RelatedPerson.telecom.where(system='email')",
    "Patient.telecom.where(system='phone') | Person.telecom.where(system='phone') | Practitioner.telecom.where(system='phone') | PractitionerRole.contact.telecom.where(system='phone') | RelatedPerson.telecom.where(system='phone')",
    "PaymentNotice.created",
    "PaymentNotice.identifier",
    "PaymentNotice.paymentStatus",
    "PaymentNotice.reporter",
    "PaymentNotice.response",
    "PaymentNotice.status",
    "PaymentReconciliation.allocation.account",
    "PaymentReconciliation.allocation.encounter",
    "PaymentReconciliation.created",
    "PaymentReconciliation.disposition",
    "PaymentReconciliation.identifier",
    "PaymentReconciliation.outcome",
    "PaymentReconciliation.request",
    "PaymentReconciliation.requestor",
    "PaymentReconciliation.status",
    "Permission.identifier",
    "Permission.status",
    "Person.deceased.exists() and Person.deceased != false",
    "Person.link.target",
    "Person.link.target.where(resolve() is Practitioner)",
    "Person.link.target.where(resolve() is RelatedPerson)",
    "Person.managingOrganization",
    "Person.name",
    "Person.name.family",
    "Person.name.given",
    "PersonalRelationship.relationshipType",
    "PersonalRelationship.source",
    "PersonalRelationship.target",
    "PlanDefinition.action.definition.ofType(canonical) | PlanDefinition.action.definition.ofType(uri)",
    "PlanDefinition.subject as CodeableConcept",
    "PlanDefinition.subject as Reference",
    "PlanDefinition.subject as canonical",
    "PlanDefinition.type",
    "Practitioner.active",
    "Practitioner.communication.language",
    "Practitioner.deceased.exists() and Practitioner.deceased != false",
    "Practitioner.identifier | Practitioner.qualification.identifier",
    "Practitioner.qualification",
    "Practitioner.qualification.code",
    "Practitioner.qualification.period",
    "PractitionerRole.active",
    "PractitionerRole.characteristic",
    "PractitionerRole.communication",
    "PractitionerRole.endpoint",
    "PractitionerRole.healthcareService",
    "PractitionerRole.identifier",
    "PractitionerRole.location",
    "PractitionerRole.network",
    "PractitionerRole.organization",
    "PractitionerRole.period",
    "PractitionerRole.practitioner",
    "PractitionerRole.specialty",
    "Procedure.basedOn",
    "Procedure.category",
    "Procedure.location",
    "Procedure.partOf",
    "Procedure.performer.actor",
    "Procedure.reason.concept",
    "Procedure.reason.reference",
    "Procedure.report",
    "Procedure.status",
    "Procedure.subject",
    "Provenance.activity",
    "Provenance.agent.type",
    "Provenance.agent.who",
    "Provenance.basedOn",
    "Provenance.entity.what",
    "Provenance.location",
    "Provenance.recorded",
    "Provenance.signature.type",
    "Provenance.target",
    "Questionnaire.code",
    "Questionnaire.code | Questionnaire.item.code",
    "Questionnaire.item.code",
    "Questionnaire.item.definition",
    "Questionnaire.subjectType",
    "QuestionnaireResponse",
    "QuestionnaireResponse.authored",
    "QuestionnaireResponse.basedOn",
    "QuestionnaireResponse.item.answer.value.ofType(Quantity)",
    "QuestionnaireResponse.item.answer.value.ofType(Reference)",
    "QuestionnaireResponse.item.answer.value.ofType(boolean) | QuestionnaireResponse.item.answer.value.ofType(Coding)",
    "QuestionnaireResponse.item.answer.value.ofType(date) | QuestionnaireResponse.item.answer.value.ofType(dateTime)",
    "QuestionnaireResponse.item.answer.value.ofType(integer) | QuestionnaireResponse.item.answer.value.ofType(decimal)",
    "QuestionnaireResponse.item.answer.value.ofType(string)",
    "QuestionnaireResponse.item.linkId",
    "QuestionnaireResponse.item.where(extension('http://hl7.org/fhir/StructureDefinition/questionnaireresponse-isSubject').exists()).answer.value.ofType(Reference)",
    "QuestionnaireResponse.partOf",
    "QuestionnaireResponse.questionnaire",
    "QuestionnaireResponse.source",
    "QuestionnaireResponse.status",
    "QuestionnaireResponse.subject",
    "RegulatedAuthorization.case.identifier",
    "RegulatedAuthorization.case.type",
    "RegulatedAuthorization.holder",
    "RegulatedAuthorization.identifier",
    "RegulatedAuthorization.status",
    "RegulatedAuthorization.subject",
    "RelatedPerson.active",
    "RelatedPerson.name",
    "RelatedPerson.name.family",
    "RelatedPerson.name.given",
    "RelatedPerson.relationship",
    "RequestOrchestration.action.participant.actor.ofType(Reference) | RequestOrchestration.action.participant.actor.ofType(canonical)",
    "RequestOrchestration.action.resource",
    "RequestOrchestration.author",
    "RequestOrchestration.authoredOn",
    "RequestOrchestration.groupIdentifier",
    "RequestOrchestration.instantiatesCanonical",
    "RequestOrchestration.instantiatesUri",
    "RequestOrchestration.intent",
    "RequestOrchestration.priority",
    "RequestOrchestration.status",
    "RequestOrchestration.subject",
    "Requirements.actor.reference",
    "Requirements.derivedFrom",
    "ResearchStudy.classifier",
    "ResearchStudy.description",
    "ResearchStudy.focus.concept",
    "ResearchStudy.focus.reference",
    "ResearchStudy.identifier",
    "ResearchStudy.keyword",
    "ResearchStudy.name",
    "ResearchStudy.objective.description",
    "ResearchStudy.objective.type",
    "ResearchStudy.partOf",
    "ResearchStudy.period",
    "ResearchStudy.phase",
    "ResearchStudy.progressStatus",
    "ResearchStudy.progressStatus.actual",
    "ResearchStudy.progressStatus.period",
    "ResearchStudy.protocol",
    "ResearchStudy.recruitment.actualNumber",
    "ResearchStudy.recruitment.eligibility",
    "ResearchStudy.recruitment.targetNumber",
    "ResearchStudy.region",
    "ResearchStudy.site",
    "ResearchStudy.status",
    "ResearchStudy.studyDesign",
    "ResearchStudy.title",
    "ResearchSubject.status",
    "ResearchSubject.subject",
    "ResearchSubject.subjectState.code",
    "Resource.id",
    "Resource.language",
    "Resource.meta.lastUpdated",
    "Resource.meta.profile",
    "Resource.meta.security",
    "Resource.meta.source",
    "Resource.meta.tag",
    "RiskAssessment.condition",
    "RiskAssessment.method",
    "RiskAssessment.performer",
    "RiskAssessment.prediction.probability.ofType(decimal)",
    "RiskAssessment.prediction.qualitativeRisk",
    "RiskAssessment.subject",
    "Schedule.active",
    "Schedule.actor",
    "Schedule.identifier",
    "Schedule.name",
    "Schedule.planningHorizon",
    "Schedule.serviceCategory",
    "Schedule.serviceType.reference",
    "Schedule.specialty",
    "SearchParameter.base",
    "SearchParameter.code",
    "SearchParameter.component.definition",
    "SearchParameter.derivedFrom",
    "SearchParameter.target",
    "SearchParameter.type",
    "ServiceRequest.authoredOn",
    "ServiceRequest.basedOn",
    "ServiceRequest.bodySite",
    "ServiceRequest.bodyStructure",
    "ServiceRequest.category",
    "ServiceRequest.code.concept",
    "ServiceRequest.code.reference",
    "ServiceRequest.instantiatesCanonical",
    "ServiceRequest.instantiatesUri",
    "ServiceRequest.intent",
    "ServiceRequest.location.concept",
    "ServiceRequest.location.reference",
    "ServiceRequest.occurrence.ofType(dateTime) | ServiceRequest.occurrence.ofType(Period) | ServiceRequest.occurrence.ofType(Timing)",
    "ServiceRequest.performer",
    "ServiceRequest.performerType",
    "ServiceRequest.priority",
    "ServiceRequest.replaces",
    "ServiceRequest.requester",
    "ServiceRequest.requisition",
    "ServiceRequest.specimen",
    "ServiceRequest.subject",
    "Slot.appointmentType",
    "Slot.identifier",
    "Slot.schedule",
    "Slot.serviceCategory",
    "Slot.serviceType.concept",
    "Slot.serviceType.reference",
    "Slot.specialty",
    "Slot.start",
    "Slot.status",
    "Specimen.accessionIdentifier",
    "Specimen.collection.bodySite.reference",
    "Specimen.collection.collected.ofType(dateTime) | Specimen.collection.collected.ofType(Period)",
    "Specimen.collection.collector",
    "Specimen.collection.procedure",
    "Specimen.container.device.resolve().location",
    "Specimen.container.device.resolve().owner",
    "Specimen.parent",
    "Specimen.request",
    "Specimen.status",
    "Specimen.subject",
    "SpecimenDefinition.experimental",
    "SpecimenDefinition.typeCollected",
    "SpecimenDefinition.typeTested.container.type",
    "SpecimenDefinition.typeTested.isDerived",
    "SpecimenDefinition.typeTested.type",
    "StructureDefinition.abstract",
    "StructureDefinition.baseDefinition",
    "StructureDefinition.context",
    "StructureDefinition.context.expression",
    "StructureDefinition.context.type",
    "StructureDefinition.derivation",
    "StructureDefinition.experimental",
    "StructureDefinition.keyword",
    "StructureDefinition.kind",
    "StructureDefinition.snapshot.element.binding.valueSet",
    "StructureDefinition.snapshot.element.path | StructureDefinition.differential.element.path",
    "StructureDefinition.type",
    "Subscription.channelType",
    "Subscription.contact",
    "Subscription.content",
    "Subscription.contentType",
    "Subscription.endpoint",
    "Subscription.filterBy.event",
    "Subscription.filterBy.value",
    "Subscription.identifier",
    "Subscription.managingEntity",
    "Subscription.status",
    "Subscription.topic",
    "SubscriptionTopic.effectivePeriod",
    "SubscriptionTopic.trigger.description",
    "SubscriptionTopic.trigger.event",
    "SubscriptionTopic.trigger.resource",
    "SubscriptionTopic.url | SubscriptionTopic.derivedFrom",
    "Substance.category",
    "Substance.code.concept",
    "Substance.code.reference",
    "Substance.expiry",
    "Substance.quantity",
    "Substance.status",
    "SubstanceDefinition.classification",
    "SubstanceDefinition.code.code",
    "SubstanceDefinition.domain",
    "SubstanceDefinition.identifier",
    "SubstanceDefinition.name.name",
    "SupplyDelivery.receiver",
    "SupplyDelivery.status",
    "SupplyDelivery.supplier",
    "SupplyRequest.category",
    "SupplyRequest.deliverTo",
    "SupplyRequest.requester",
    "SupplyRequest.status",
    "Task.authoredOn",
    "Task.basedOn",
    "Task.businessStatus",
    "Task.executionPeriod",
    "Task.focus",
    "Task.groupIdentifier",
    "Task.input.value.ofType(Reference)",
    "Task.lastModified",
    "Task.output.value.ofType(Reference)",
    "Task.owner",
    "Task.partOf",
    "Task.performer.actor",
    "Task.priority",
    "Task.requestedPerformer.concept",
    "Task.requestedPerformer.reference",
    "Task.requester",
    "Task.status",
    "TestPlan.category",
    "TestPlan.scope.artifact.ofType(canonical)",
    "TestPlan.scope.artifact.ofType(uri)",
    "TestPlan.testCase.requirement",
    "TestPlan.testCase.requirement.reference",
    "TestReport.identifier",
    "TestReport.issued",
    "TestReport.participant.uri",
    "TestReport.result",
    "TestReport.status",
    "TestReport.testScript",
    "TestReport.tester",
    "TestScript.metadata.capability.description",
    "TestScript.scope",
    "TestScript.scope.conformance.ofType(CodeableConcept)",
    "TestScript.scope.phase.ofType(CodeableConcept)",
    "Transport.identifier",
    "Transport.status",
    "ValueSet.compose.include.system",
    "ValueSet.expansion.contains.code | ValueSet.compose.include.concept.code",
    "ValueSet.expansion.identifier",
    "VerificationResult.attestation.communicationMethod",
    "VerificationResult.attestation.onBehalfOf",
    "VerificationResult.attestation.who",
    "VerificationResult.primarySource.type",
    "VerificationResult.primarySource.who",
    "VerificationResult.status",
    "VerificationResult.statusDate",
    "VerificationResult.target",
    "VerificationResult.validator.organization",
    "VisionPrescription.dateWritten",
    "VisionPrescription.prescriber",
    "VisionPrescription.status",
    "id",
    "requestedPeriod",
    "value.ofType(string)"
  ]
}